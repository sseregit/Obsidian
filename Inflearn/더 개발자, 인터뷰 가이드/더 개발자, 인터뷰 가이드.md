## 개발자 채용
- 면접관
	- 어떤 질문을 해야 할까?
	- 채용 절차는 어떻게 바뀌고 있는가.
	- 이력서 검토 및 면접시 주의할 사항
	- 어떤 개발자를 채용해야 하는가.
- 면접자
	- 질문의 핵심이 무엇일까?
	- 면접관은 어떤 것에 주목하는가.
	- 변화하고 있는 채용 절차에 대한 이해
	- 면접에 임하는 마음가짐

## 고전적인 채용 절차

## 변하고 있는 채용 절차
- 개발자
	- 하드 스킬
		- 기술적인 지식, 능력, 코딩 스킬
	- 소프트 스킬
		- 의사소통 능력

## 대면 면접 구성

## 채용 공고 작성 가이드

## 이력서 검토 가이드

## 면접 가이드

### 지원자의 면접 경험

### 지원자 평가

### 피드백 공유

## 개발자 채용 정리
- 대면 면접의 다각화
- **하드 스킬과 소프트 스킬**

## 구직 또는 이직

## 적절한 이직 시기

## 주 업종 정하기

## 취업 또는 이직할 목표 회사 정하기

## 면접 가이드

### 준비
- 집중 준비 기간 약 3개월!
- 매일 코딩 퀴즈 최소 한 문제씩 풀기!
- 예상 질문에 답변 준비하기
- 프로그래밍 관련 서적 일기
	- 운영체제, GOF등등의 서적을 이야기 하는것
- 코딩 꾸준히
	- 사이드 프로젝트나 일하면서 생긴 이슈들
- 자료 구조와 알고리듬
	- Big O 노테이션
		- 시간 복잡도나 공간 복잡도를 표현할수 있음.
	- 자료 구조 리마인드
	- 정렬 알고리듬
	- Collection API
	- BFS, DFS

### 실전

### 결과

## 연봉 협상

## 오퍼 수락 전에 확인 할 것

## 입사 또는 이직 이후 업무 적응 가이드

## 핵심 역량
- 6가지 주요 소프트 스킬
	- 고객 중심
	- 결과 도출
	- 영향력
	- 적응력
	- 판단력
	- 협업

## 고객 중심
- 고객
	- 사용하는 유저, 제품의 end유저, 회사내에 다른 팀

## 결과 도출
- 결과를 만들어내는 것
- 품질. 일정. 비용
	- 3가지를 만족하는 프로젝트는 없다고 보면 된다.

## 영향력

## 적응력
- 끊임없이 탐구하고 학습한다.

## 판단력

## 협업

## 질문에 대한 답변 프레임워크
- STAR 프레임워크
	- Situation
		- 어떠한 상황에서
	- Task
		- 어떤 업무 하거나 또는 목표를 달성해야 했었는지
	- Action
		- 그래서 본인이 왜, 무엇을, 어떻게 했으며
	- Result
		- 결과는 어땠는지, 그 결과로 얻은 성과는? 또는 실패했다면 그로부터 배운것은?

## 면접관에게 묻기 좋은 질문

## 그밖에...

## 코딩 인터뷰

## 코딩 인터뷰 프레임워크
- 문제 풀이 프레임워크
	1. 문제를 명확히 이해했는지 확인한다.
	2. 가정하고 있거나 가정할 수 있는 것들을 확인한다.
	3. 실제 예를 들어가며 다시 확인한다. (나중에 테스트 케이스로 활용할 수 있다.)
	4. 문제 해결책을 고민한다.
	5. 해결책을 설명하고 해당 시간과 공간 알고리듬 **복잡도**를 설명한다.
	6. 코드를 작성한다.
	7. 앞서 예씨로 사용했던 입력값을 케이스로 삼아 코드를 테스트한다.

## 알고리듬 복잡도
- 빅 오 노테이션(O(n)...)
	- 주어진 함수에서 엄밀한 점근적 상한을 나타내는 점근적 표기법
	- 숫자는 다 빼기
	- 가장 증가율이 높은 수식만 남기기
	- 코드를 작성하기전에 예측할수 있어야 한다
		- 시간 복잡도와 공간 복잡도

- 공간 복잡도
	- 메서드, 알고리듬을 실행할때 필요로 하는 메모리  
	- 자료구조가 늘어나는 것도 n으로 봐야한다.

- 시간 복잡도와 공간 복잡도를 계산할때 내가 사용하는 자료구조의 API가 어떤 구조인지도 꼭 봐야한다.
	- loop를 돌리는 코드에서 loop를 돌리는 API를 호출한다면 O(n^2)이 될 수 있다.

## 배열
- 연속된 메모리 영역에 저장된 데이터
- 조회가 O(1), 추가 및 삭제가 O(n) 복잡도를 가지고 있다
- 조회는 빠르고 추가 및 삭제는 느리다.

## 배열 퀴즈 1
- 솔루션1: 가장 단순한 방법
```java
/**  
 * 시간 복잡도 : O(n^2) 
 * 공간 복잡도 : O(1) 
 */ 
private boolean solution(int[] numbers) {  
  
    for (int i = 0; i < numbers.length; i++) {  
        for (int j = i + 1; j < numbers.length; j++) {  
            if (numbers[i] == numbers[j]) return true;  
        }  
    }  
  
    return false;  
}
```

- 솔루션2: 정렬후 순회
```java
   /**
     * 시간 복잡도 : O(nLogn)
     * 공간 복잡도 : O(Logn)
     */
    private boolean solution(int[] numbers) {

        Arrays.sort(numbers); // Quick sort 가 O(nLogn), O(Logn)

        for (int i = 0; i < numbers.length-1; i++) {
            if (numbers[i] == numbers[i + 1]) return true;
        }

        return false;
    }
```

- 솔루션3: Set 활용하기
```java
    /**
     * 시간 복잡도 : O(n)
     * 공간 복잡도 : O(n)
     */
    private boolean solution(int[] numbers) {

        Set<Integer> set = new HashSet<>();

        for (int i = 0; i < numbers.length; i++) {
            if (set.contains(numbers[i])) {
                return true;
            } else {
                set.add(numbers[i]);
            }
        }

        return false;
    }
```


## 배열 문제2 학습
- 솔루션1: 가장 단순한 방법
```java
    /**
     * 시간 복잡도 : O(n)
     * 공간 복잡도 : O(n)
     */
    private char[] solution1(char[] message) {
        char[] result = new char[message.length];
        for (int i = message.length - 1; i >= 0; i--) {
           result[(message.length-1) - i] = message[i];
        }
        return result;
    }
```

- 솔루션2: 공간복잡도를 줄이는 방법
```java
    /**
     * 시간 복잡도 : O(n)
     * 공간 복잡도 : O(1)
     */
    private char[] solution1(char[] message) {

        for (int i = 0; i < message.length / 2; i++) {
            char temp = message[i];
            message[i] = message[message.length - i - 1];
            message[message.length - i - 1] = temp;
        }

        return message;
    }
```

## 배열 문제 3

- 솔루션 1. 가장 단순한 방법
```java
    /**
     * 시간 복잡도 : O(n^2)
     * 공간 복잡도 : O(1)
     */
    private int[] solution(int[] numbers, int target) {
        for (int i = 0; i < numbers.length; i++) {
            for (int j = i+1; j < numbers.length; j++) {
                if (numbers[i] + numbers[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }
```

- 솔루션 2. HashMap을 사용하는 방법
```java
    /**
     * 시간 복잡도 : O(n^2)
     * 공간 복잡도 : O(n)
     */
    private int[] solution(int[] numbers, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < numbers.length; i++) {
            map.put(numbers[i], i);
        }

        for (Integer key : map.keySet()) {
            int numberToFind = target - key;
            if (map.containsKey(numberToFind) && map.get(numberToFind) != map.get(key)) {
                return new int[]{map.get(key), map.get(numberToFind)};
            }
        }
        
        return null;
    }
```

## 배열 문제 4
- 솔루션
```java
    /**
     * 시간 복잡도: O(n)
     * 공간 복잡도: O(1)
     */
    private int[] solution(int[] numbers) {
        boolean[] visited = new boolean[101];

        for (int number : numbers) {
            visited[number] = true;
        }

        for (int i = 0, index = 0; i < visited.length; i++) {
            if (visited[i]) {
                numbers[index++] = i;
            }
        }

        return numbers;
    }

```

## 리스트
- 자바가 제공하는 대표적인 리스트
	- Vector
		- ArrayList와 같지만 synchronized가 적용되어 있다.
	- ArrayList
		- 배열 기반 동적으로 길이를 조절
		- index기반
		- 추가 및 삭제 O(1) 하지만 최악의 경우 O(n)
	- LinkedList
		- 연결되어 있는 노드로 존재
		- 추가 및 삭제 O(1)
		- 조회 O(n)

## 리스트 문제 1
- 솔루션 1. 순회
- 솔루션 2. 재귀

## 리스트 문제 2

## 리스트 문제 3

## 리스트 문제 4

## 스택

## 스택1

## 스택2

## 스택3

## 스택4

## 큐