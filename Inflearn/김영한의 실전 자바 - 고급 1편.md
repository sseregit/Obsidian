
## 멀티태스킹과 멀티프로세싱

### 멀티태스킹
하나의 컴퓨터 시스템이 동시에 여러 작업을 수행하는 능력

### 시분할
프로그램의 실행 시간을 분할해서 마치 동시에 실행되는 것 처럼 하는 기법

### 스케줄링
CPU에 어떤 프로그램이 얼마만큼 실행될지는 운영체제가 결정한다.

### 멀티프로세싱
둘 이상의 프로세서를 사용하여 여러 작업을 동시에 처리하는 기술

### 멀티태스킹 vs 멀티프로세싱
- 멀티프로세싱
	- 여러 CPU를 사용하여 동시에 여러 작업을 수행하는 것을 의미
	- 하드웨어 기반으로 성능을 향상시킨다.
- 멀티태스킹
	- 단일 CPU가 여러 작업을 동시에 수행하는 것 처럼 보이게 하는 것을 의미한다.
	- 소프트웨어 기반으로 CPU 시간을 분할하여 각 작업에 할당한다.

## 프로세스와 스레드

### 프로세스
운영체제 안에서 실행중인 프로그램

#### 프로세스의 메모리 구성
- 코드 섹션
	- 실행할 프로그램의 코드가 저장되는 부분
- 데이터 섹션
	- 전역 변수 및 정적 변수가 저장되는 부분
- 힙(Heap)
	- 동적으로 할당되는 메모리 영역
- 스택(Stack)
	- 메서드(함수)호출 시 생성되는 지역 변수와 반환 주소가 저장되는 영역(스레드에 포함)

### 스레드(Thread)
**프로세스는 하나 이상의 스레드를 반드시 포함한다.**

#### 스레드의 메모리 구성
- 공유 메모리
	- 같은 프로세스의 코드 섹션, 데이터 섹션, 힙(메모리)은 프로세스 안의 모든 스레드가 공유한다
- 개별 스택
	- 각 스레드는 자신의 스택을 갖고 있다.

#### 단일 스레드
한 프로세스 내에 하나의 스레드 존재
#### 멀티 스레드
한 프로세스 내에 여러 스레드가 존재

## 스레드와 스케줄링

### 멀티태스킹과 스케줄링
멀티태스킹이란 동시에 여러 작업을 수행하는 것을 말하고
이를 위해 운영체제는 스케줄링이라는 기법을 사용한다.
#### 스케줄링
CPU 시간을 여러 작업에 나누어 배분하는 방법이다.

### 프로세스와 스레드
#### 프로세스
실행 중인 프로그램의 인스턴스
- 역할
	- 실행 환경을 제공한다
	- 메모리 공간, 파일 핸들, 시스템 자원 등이 포함된다.
#### 스레드
프로세스 내에서 실행되는 작은 단위
여러 스레드는 하나의 프로세스 내에서 자원을 공유한다
CPU에 의해 실행되는 단위는 스레드이다.

## 컨텍스트 스위칭

### 컨텍스트 스위칭
컨텍스트는 현재 작업하는 문맥을 뜻하고 작업하는 문맥이 변하기 때문에 컨텍스트 스위칭이다.

**멀티스레드는 대부분 효율적이지만,** 컨텍스트 스위칭 과정이 필요하므로 항상 효율적인것은 아니다.
### CPU-바운드 작업(CPU-bound tasks)
- CPU의 연산 능력을 많이 요구하는 작업
- 계산, 데이터처리, 알고리즘 실행등 CPU의 처리 속도가 완료 시간을 결정하는 경우

### I/O-바운드 작업(I/O-bound tasks)
- 디스크, 네트워크, 파일 시스템 등과 같은 입출력 작업을 많이 요구하는 작업을 의미한다.
- I/O 작업이 완료될 때까지 대기 시간이 많이 발생하며, CPU는 상대적으로 유휴 상태에 있는 경우가 많다.
- 스레드가 CPU를 사용하지 않고, I/O 작업이 완료될 때 까지 대기한다.

### 웹 애플리케이션 서버
실무에서는 CPU-바운드 작업 <<<< I/O-바운드 작업이 많다
스레드가 CPU를 많이 사용하지 않는 I/O-바운드 작업이 많다는 뜻

#### CPU-바운드 작업이 많을 경우
- CPU 코어 수 + 1개
- CPU를 거의 100% 사용하는 작업
#### I/O-바운드 작업이 많을 경우
- CPU 코어 수 보다 많은 스레드를 생성, CPU를 최대한 사용할 수 있는 숫자까지 스레드 생성
- CPU를 많이 사용하지 않으므로 성능 테스트를 통해 CPU를 최대한 활용하는 숫자까지 스레드 생성
- 단 너무 많은 스레드를 생성하면 컨텍스트 스위칭 비용도 함께 증가 - 적절한 성능 테스트 필요

## 프로젝트 환경 구성

## 스레드 시작1

`Thread.run()`이 아닌 `start()`를 호출해야 스택 공간을 할당 받고 스레드가 작동한다

## 스레드 시작2

### start() vs run()
- run()
	- 실행중인 스레드에서 실행됨
- start()
	- 별도의 스레드에서 run()을 실행한다

## 데몬 스레드

### 스레드의 종류

#### 사용자 스레드(non-daemon 스레드)
- 프로그램의 주요 작업을 수행한다.
- 작업이 완료될 때까지 실행된다.
- 모든 user 스레드가 종료되면 JVM도 종료된다.

#### 데몬 스레드
- 백그라운드에서 보조적인 작업을 수행한다.
- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.

JVM은 모든 사용자 스레드가 종료되면 종료된다.
- 메인 메서드의 종료가 아니다.

**run() 메서드는 throws로 Exception을 던질 수 없다**

## 스레드 생성 - Runnable

### 스레드를 만드는 방법
- Thread 클래스 상속 받는 방법
- Runnable 인터페이스를 구현하는 방법
- 

Runnable 구현을 사용하는것이 더 나은 방법

#### Thread 클래스 상속
- 장점
	- 간단한 구현 상속받아 run()만 재정의하면된다.
- 단점
	- 상속의 제한
	- 유연성 부족

#### Runnable 인터페이스를 구현방식
- 장점
	- 상속에 자유롭다
	- 코드의 분리
		- 스레드와 실행할 작업의 분리
	- 여러 스레드가 Runnable 객체를 공유할 수 있어 자원 관리를 효율적
- 단점
	- 코드가 약간 복잡해질 수 있다.

## 로거 만들기

## 여러 스레드 만들기

## Runnable을 만드는 다양한 방법

## 스레드 기본 정보
- getState()
	- NEW
		- 스레드가 아직 시작되지 않은 상태
	- RUNNABLE
		- 스레드가 실행 중이거나 실행될 준비가 된 상태
		- BLOCKED
			- 스레드가 동기화 락을 기다리는 상태
		- WAITING
			- 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태이다
		- TIMED_WAITING
			- 일정 시간 동안 기다리는 상태이다.
	- TERMINATED
		- 스레드가 실행을 마친 상태이다.

## 스레드의 생명 주기 - 설명

### New
스레드가 생성되고 아직 시작되지 않은 상태

### Runnable
스레드가 실행될 준비가 된 상태이다. 스레드는 실제로 CPU에서 실행될 수 있는 상태
스케줄러의 실행 대기열에 있든, CPU에서 실제 실행되고 있든 모두 RUNNABLE 상태이고 자바는 이 둘을 구분해서 확인할 수 없다.

### Blocked
스레드가 다른 스레드에 의해 동기화 락을 얻기 위해 기다리는 상태

### Waiting
스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태

### Timed Waiting
스레드가 특정 시간 동안 다른 스레드의 작업이 완료되기를 기다리는 상태

### Terminated
스레드의 실행이 완료된 상태
스레드는 종료되면 다시 시작할 수 없다.

## 스레드의 생명 주기 - 코드

## 체크 예외 재정의

### 재정의 메서드가 지켜야할 예외와 관련된 규칙
- 체크 예외
	- 부모 메서드가 체크 예외를 던지지 않는 경우, 재정의된 자식 메서드도 체크 예외를 던질 수 없다.
	- 자식 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.
- 언체크(런타임) 예외
	- 예외 처리를 강제하지 않으므로 상관없이 던질 수 있다.

## Join - 시작

### Waiting
스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.

## Join - 필요한 상황

## Join - sleep 사용

## Join - join 사용

### join의 단점
다른 스레드가 완료될 때 까지 무기한 기다리는 단점

## Join - 특정 시간 만큼만 대기

## 인터럽트 - 시작1

## 인터럽트 - 시작2

## 인터럽트 - 시작3

## 인터럽트 - 시작4

## 프린터 예제1 - 시작

여러 스레드가 해당 변수에 접근한다면 volatile 키워드를 붙어줘야 한다.

여러 스레드가 동시에 접근하는 경우 컬렉션 프레임워크가 제공하는 일반적인 자료구조가 아닌 동시성 컬렉션을 사용해야 한다.

## 프린터 예제2 - 인터럽트 도입

## yield - 양보하기

CPU 실행 기회를 양보하는 것을 의미한다.

자바의 스레드가 RUNNABLE 상태일 때 운영체제의 스케줄링은 다음과 같은 상태들을 가질 수 있다.
1. 실행 상태(Running): 스레드가 CPU에서 실제로 실행 중이다.
2. 실행 대기 상태(Ready): 스레드가 실행될 준비가 되었지만, CPU가 바빠서 스케줄링 큐에서 대기 중이다.
자바는 이 둘을 구분할 수 없다. 모두 RUNNABLE 상태임.

### yield()의 작동
- `Thread.yield()`메서드는 현재 실행중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다.
- `yield()`메서드를 호출한 스레드는 RUNNABLE상태를 유지하면서 CPU를 양보한다. 즉, 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에서 CPU 사용 기회를 넘긴다.

## 프린터 예제4 - yield 도입

## volatile, 메모리 가시성1

## volatile, 메모리 가시성2

### 메모리 가시성 문제
멀티 스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제를 메모리 가시성(memory visibility)이라 한다.

## volatile, 메모리 가시성3

자바에서는 volatile이라는 키워드를 통해 성능을 약간 포기하는 대신에 값을 읽을 때 값을 쓸 때 모두 메인 메모리에 직접 접근하게 해준다.

## volatile, 메모리 가시성4

## 자바 메모리 모델(Java Memory Model)

### Java Memory Model
자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며, 특히 멀티 스레드 프로그래밍에서 스레드 간의 상호작용을 정의한다
여러 내용이 있지만 핵심은 여러 스레드들의 작업 순서를 보장하는 happens-before 관계에 대한 정의다.

### happens-before
자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념이다.
A 작업에서 변경된 내용은 B 작업이 시작 되기 전에 모두 메모리에 반영된다.
- 한 동작이 다른 동작보다 먼저 발생함을 보장한다.
- 스레드 간의 메모리 가시성을 보장하는 규칙이다.
- 한 스레드의 작업을 다른 스레드에서 볼 수 있게 된다.
- 한 스레드에서 수행한 작업을 다른 스레드가 참조할 때 최신 상태가 보장되는 것

#### 프로그램 순서 규칙
#### volatile 변수 규칙
#### 스레드 시작 규칙
#### 스레드 종료 규칙
#### 인터럽트 규칙
#### 객체 생성 규칙
#### 모니터 락 규칙
#### 전이 규칙(Transitivity Rule)

**volatile 또는 스레드 동기화 기법(synchronized, ReentrantLock)을 사용하면 메모리 가시성의 문제가 발생하지 않는다.**

## 출금 예제 - 시작

멀티스레드의 가장 주의해야 할점은
같은 자원(리소스)에 여러 스레드가 동시에 접근할 때 발생하는 동시성 문제이다.

## 동시성 문제

## 임계 영역

### 임계 영역(critical section)
- 여러 스레드가 동시에 접근하면 데이터 불일치나 예상치 못한 동작이 발생할 수 있는 위험하고 또 중요한 코드 부분을 뜻한다.
- 여러 스레드가 동시에 접근해서는 안 되는 공유 자원을 접근하거나 수정하는 부분을 의미한다.

## synchronized 메서드

### synchronized 분석
- **모든 객체(인스턴스)는 내부에 자신만의 락(lock)을 가지고 있다.**
	- 모니터 락(monitor lock)이라고도 부른다.
	- 객체 내부에 있고 우리가 확인하기는 어렵다.
- 스레드가 `synchronized`키워드가 있는 메서드에 진입하려면 반드시 해당 인스턴스의 락이 있어야 한다.
- 락을 획득하는 순서는 보장되지 않는다.
- volatile를 사용하지 않아도 synchronized안에서 접근하는 변수의 메모리 가시성 문제는 해결된다.

## synchronized 코드 블럭

`synchronized`의 가장 큰 장점이자 단점은 한 번에 하나의 스레드만 실행할 수 있다는 점이다.
`synchronized`를 통해 여러 스레드를 동시에 실행할 수 없는 코드 구간은 꼭! 필요한 곳으로 한정해서 설정해야 한다.

하나의 스레드만 실행할 수 있는 안전한 임계 영역은 가능한 최소한의 범위에 적용해야 한다

동기화를 사용하면 해결할 수 있는 문제
- 경합조건(Race condition)
	- 두 개 이상의 스레드가 경쟁적으로 동일한 자원을 수정할 때 발생하는 문제
- 데이터 일관성
	- 여러 스레드가 동시에 읽고 쓰는 데이터의 일관성을 유지

## 정리

### synchronized 단점
- 무한 대기
	- `BLOCKED`상태의 스레드는 락이 풀릴 때 까지 무한 대기
		- 타임아웃 X
		- 인터럽트 X
- 공정성
	- 락이 돌아 왔을 대 `BLOCKED`상태의 여러 스레드 중에 어떤 스레드가 락을 획득할 지 알 수 없다.

## LockSupport1

`LockSupport`를 사용하면 synchronized의 가장 큰 단점인 무한대기 문제를 해결할 수 있다.

### LockSupoort의 대표 기능
- park()
	- 스레드를 `WAITING`상태로 변경한다.
- parkNanos(nanos)
	- 스레드를 나노초 동안만 `TIMED_WAITING`상태로 변경한다.
- unpark(thread)
	- `WAITING`상태의 대상 스레드를 `RUNNABLE`상태로 변경한다

## LockSupport2

### 시간대기
- parkNanos(nanos)
	- 스레드를 나노초 동안만 `TIME_WAITING`상태로 변경한다. 지정한 나노초가 지나면 `TIME_WAITING`상태에서 빠져나와서 `RUNNABLE`상태로 변경된다.

### BLOCKED vs WAITING

#### 인터럽트
- `BLOCKED`상태는 인터럽트가 걸려도 대기 상태를 빠져나오지 못한다.
- `WAITING`, `TIMED_WAITING`상태는 인터럽트가 걸리면 대기 상태를 빠져나온다. 그래서 `RUNNABLE`상태로 변한다.

#### 용도
- `BLOCKED`상태는 자바의 `synchronized`에서 락을 획득하기 위해 대기할 때 사용된다.
- `WAITING`, `TIMED_WAITING` 상태는 스레드가 특정 조건이나 시간동안 대기할 때 발생하는 상태이다.
- `WAITING`상태는 다양한 상황에서 사용된다.
	- `Thread.join()`,`LockSupport.park()`, `Object.wait()`등등..
- `TIMED_WAITING`상태
	- `Thread.sleep(ms)`, `Object.wait(long timeout)`, `Thread.join(long millis)`, `LockSupport.parkNanos(ns)`등 시간 제한이 있는 대기 메서드를 호출할 때 발생한다.

## ReentrantLock - 이론

### Lock 인터페이스
- 동시성 프로그래밍에서 쓰이는 안전한 임계 영역을 위한 락을 구현하는데 사용된다.

## ReentrantLock - 활용

## ReentrantLock - 대기 중단

## 생산자 소비자 문제 - 소개

### 기본개념
- 생산자(Producer)
- 소비자(Consumer)
- 버퍼(Buffer)

### 생산자 소비자 문제(producer-consumer problem)
- 생산자 스레드와 소비자 스레드가 특정 자원을 함께 생산하고, 소비하면서 발생하는 문제
### 한정된 버퍼 문제(bounded-buffer problem)
- 결국 중간에 있는 버퍼의 크기가 한정되어 있기 때문에 발생한다.

둘다 같은 뜻이다.

## 생산자 소비자 문제 - 예제1 코드

## 생산자 소비자 문제 - 예제1 분석 - 생산자 우선

## 생산자 소비자 문제 - 예제1 분석 - 소비자 우선

## 생산자 소비자 문제 - 예제2 코드

## 생산자 소비자 문제 - 예제2 분석

## Object - wait, notify - 예제3 코드

자바는 처음부터 멀티스레드를 고려하며 탄생한 언어다.

### Object
#### wait()
- 현재 스레드가 가진 락을 반납하고 대기(`WAITING`)한다.
- 현재 스레드가 `synchronized`블록이나 메서드에서 락을 소유하고 있을 때만 호출할 수 있다.
- 대기 상태로 전환된 스레드는 다른 스레드가 `notify()` or `notifyAll()`을 호출할 때까지 대기 상태를 유지한다.
#### notify()
- 대기 중인 스레드중 하나를 깨운다
- `synchronized`블록이나 메서드에서 호출되어야 한다.
#### notifyAll()
- 대기 중인 모든 스레드를 깨운다.
- `synchronized`블록이나 메서드에서 호출되어야 한다.

## Object - wait, notify - 예제3 분석 - 생산자 우선
## Object - wait, notify - 예제3 분석 - 소비자 우선

어떤 스레드가 깨어날지는 알 수 없다.

## Object - wait, notify - 한계

생산자, 소비자 모두 하나의 스레드 대기 집합에서 관리한다. 

### 스레드 기아(thread starvation)
- 어떤 스레드가 깨어날 지 알 수 없기 때문에 발생할 수 있는 문제   

### notifyAll()
- 모든 대기 집합에 있는 스레드를 다 깨운다. `WAIT -> BLOCKED`

## Look Condition - 예제4

### Condition
`Condition condition = lock.newCondition()`
ReentrantLock을 사용하는 스레드가 대기하는 스레드 대기 공간이다.

#### await()
지정한 condition에 현재 스레드를 대기(`WAITING`)상태로 보관한다.
ReentrantLock에서 획득한 락을 반납

#### signal()
condition에서 대기중인 스레드를 하나 깨운다

## 생산자 소비자 대기 공간 분리 - 예제5 코드

## 생산자 소비자 대기 공간 분리 - 예제5 분석

### Object.notify() vs Condition.signal()
#### notify()
- 스레드가 깨어나는 순서는 정의되어 있지 않으며 JVM 구현에 따라 다르다.
- `synchronized`블록 내에서 모니터 락을 가지고 있는 스레드가 호출해야 한다.

#### signal()
- 대기 중인 스레드 중 하나를 깨우며, 일반적으로 FIFO 순서로 깨운다.
- `ReentrantLock`을 가지고 있는 스레드가 호출해야 한다.

## 스레드의 대기

### synchronized 대기
- 2가지 단계의 대기 상태
	1. 락 획득 대기
	2. wait() 대기

자바의 모든 객체 인스턴스는 멀티스레드와 임계 영역을 다루기 위해 내부에 3가지 기본 요소를 가진다.
- 모니터 락
- 락 대기 집합(모니터 락 대기 집합)
- 스레드 대기 집합

## 중간 정리 - 생산자 소비자 문제

### BlockingQueue
- 데이터 추가 차단
- 데이터 획득 차단

## BlockingQueue - 예제6

## BlockingQueue - 기능 설명

**실무에서 멀티스레드를 사용할 때는 응답성이 중요하다.**

## BlockingQueue - 기능 확인

## 정리

## 원자적 연산 - 소개

### 원자적 연산
해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미한다.

## 원자적 연산 - 시작

## 원자적 연산 - volatile, synchronized

## 원자적 연산 - AtomicInteger

## 원자적 연산 - 성능 테스트

`AtomicInteger`가 제공하는 `incrementAndGet()`은 락을 사용하지 않고 원자적 연산을 만들어 낸다.

## CAS 연산1

### 락 기반 방식의 문제점
락을 획득하고 반납하는 과정의 반복
### CAS
락을 걸지 않고 원자적인 연산을 수행할 수 있는 방법
락을 사용하지 않아 락 프리(lock-free)기법이라 한다.
락을 완전히 대체하는 것은 아니고, 작은 단위의 일부 영역에 적용할 수 있다.

### CPU 하드웨어의 지원
CAS 연산은 원자적이지 않은 두 개의 연산을 CPU 하드웨어 차원에서 특별하게 하나의 원자적인 연산으로 묶어서 제공하는 기능이다.

## CAS 연산2

## CAS 연산3

### CAS(Compare-And-Swap)와 락(Lock) 방식의 비교
#### 락(Lock) 방식
- 비관적(pessimistic) 접근법
- 데이터에 접근하기 전에 항상 락을 획득
- 다른 스레드의 접근을 막는다.
- "다른 스레드가 발행할 것이다" 라고 가정

#### CAS(Compare-And-Swap)방식
- 낙관적(optimistic) 접근법
- 락을 사용하지 않고 데이터에 바로 접근
- 충돌이 발생하면 그때 재시도
- "대부분의 경우 충돌이 없을 것이다"라고 가정

## CAS 락 구현1

## CAS 락 구현2

### CAS 단점
`RUNNABLE`상태로 while문을 반복 실행하는 방식은 CPU 자원을 계속해서 사용하는 것이다.

안전한 임계 영역이 필요하지만, 연산이 매우매우매우 짧게 끝날 때 사용해야 한다.

## 정리

### CAS의 장점
- 낙관적 동기화
- 락 프리(Lock-Free)

### CAS의 단점
- 충돌이 빈번한 경우
- 스핀락과 유사한 오버헤드

### 동기화 락의 장점
- 충돌 관리
- 안정성
- 스레드 대기

### 동기화 락의 단점
- 락 획득 대기 시간
- 컨텍스트 스위칭 오버헤드

### 결론
일반적으로 동기화 락을 사용하고, 아주 특별한 경우에 한정해서 CAS를 사용해서 최적화해야 한다.

CAS를 통한 최적화가 더 나은 경우는 스레드가 `RUNNABLE` -> `BLOCKED`, `WAITING`상태에서 다시 `RUNNABLE` 상태로 가는것보다는 스레드를 `RUNNABLE`로 살려둔 상태에서 계속 락 획득을 반복 체크하는 것이 더 효율적인 경우 사용해야 한다.

## 동시성 컬렉션이 필요한 이유1 - 시작

### 스레드 세이프(Thread Safe)
여러 스레드가 접근해도 안전하다

## 동시성 컬렉션이 필요한 이유2 - 동시성 문제

### 컬렉션 프레임워크 대부분은 스레드 세이프 하지 않다.
`ArrayList`, `LinkedList`, `HashSet`, `HashMap`등등...

## 동시성 컬렉션이 필요한 이유3 - 동기화

## 동시성 컬렉션이 필요한 이유4 - 프록시 도입

### 프록시(Proxy)
대신 처리해주는 자

### 프록시 패턴
어떤 객체에 대한 접근을 제어하기 위해 그 객체의 대리인 또는 인터페이스 역할을 하는 객체를 제공하는 패턴이다.

#### 주요 목적
- 접근제어
- 성능 향상
- 부가 기능 제공

## 자바 동시성 컬렉션1 - synchronized

### synchronized 프록시 방식의 단점
1. 동기화 오버헤드가 발생한다.
2. 전체 컬렉션에 대해 동기화가 이루어지기 때문에 잠금범위가 넓어질 수 있다.
3. 정교한 동기화가 불가능하다.

## 자바 동시성 컬렉션2 - 동시성 컬렉션

### 동시성 컬렉션의 종류
- `List`
	- `CopyOnWriteArrayList` -> `ArrayList`의 대안
- `Set`
	- `CopyOnWriteArraySet` -> `HashSet`의 대안
	- `ConcurrentSkipListSet` -> `TreeSet`의 대안(정렬된 순서 유지, `Comparator` 사용가능)
- `Map`
	- `ConcurrentHashMap` -> `HashMap`의 대안
	- `ConcurrentSkipListMap` -> `TreeMap`의 대안(정렬된 순서 유지, `Comparator` 사용 가능)
- `Queue`
	- `ConcurrentLinkedQueue` -> 동시성 큐, 비 차단(non-blocking) 큐이다
- `Deque`
	- `ConcurrentLinkedDeque` -> 동시성 데크, 비 차단(non-blocking) 큐이다
- `LinkedHashSet`, `LinkedHashMap`처럼 입력 순서를 유지하는 동시에 멀티스레드 환경에서 사용할 수 있는 `Set`, `Map`구현체는 제공하지 않는다. 필요하다면 `Collections.synchronizedXxx()`를 사용해야 한다.
- `BlockingQueue`
	- 스레드를 차단하는 블로킹 큐
	- `ArrayBlockingQueue`
		- 크기가 고정된 블로킹 큐
		- 공정(fair) 모드를 사용할 수 있다. 성능이 저하될 수 있다.
	- `LinkedBlockingQueue`
		- 우선순위가 높은 요소를 먼저 처리하는 블로킹 큐
	- `SynchronousQueue`
		- 데이터를 저장하지 않는 블로킹 큐
		- 생산자가 데이터를 추가하면 소비자가 그 데이터를 받을 때까지 대기한다.
		- 생산자-소비자 간의 직접적인 핸드오프(hand-off) 메커니즘을 제공한다.
	- `DelayQueue`
		- 지연된 요소를 처리하는 블로킹 큐
		- 지연 시간이 지난 후에야 소비될 수 있다.
		- 일정 시간이 지난후 작업을 처리해야 하는 스케줄링 작업에 사용된다.

## 정리

## 스레드를 직접 사용할 때의 문제점

### 스레드 생성 시간으로 인한 성능 문제
- 메모리 할당
- 운영체제 자원 사용
- 운영체제 스케줄러 설정
참고로 스레드 하나는 보통 1MB 이상의 메모리를 사용한다.
### 스레드 관리 문제
### `Runnable` 인터페이스의 불편함
- 반환 값이 없다.
- 예외 처리


