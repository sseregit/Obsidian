# 강좌 소개
## 인트로

## 커리큘럼 소개

## 강의 자료 및 소스 코드
****
# 초기화 과정 이해

## 프로젝트 생성 / 의존성 추가

## SecurityBuilder / SecurityConfigurer

Spring Security는 **filter**기반 보안 프레임워크이다.

스프링 시큐리티는 초기화 때 인증이나 또는 인가와 관련된 여러가지 작업들을 한다 여러 개의 객체, 설정들을 종합적으로 처리하는 두개의 클래스
### SecurityBuilder
- 웹 보안을 구성하는 빈 객체와 설정 클래스들을 생성하는 역할
- 대표적으로는 WebSecurity, **HttpSecurity**가 있다.

### SecurityConfigurer
- Http 요청과 관련된 보안처리르 담당하는 필터들을 생성하고 여러 초기화 설정에 관여한다.

SecurityBuilder는 SecurityConfigurer를 참조하고 있으며 인증 및 인가 초기화 작업은 SecurityConfigurer에 의해 진행된다.

## WebSecurity / HttpSecurity

### HttpSecurity
- HttpSecurityConfiguration에서 HttpSecurity를 생성하고 초기화를 진행한다.
- 보안에 필요한 각 설정 클래스와 필터들을 생성하고 최종적으로 **SecurityFilterChain**빈 생성하는것이 목적

### WebSecurity
- WebSecurityConfiguration에서 WebSecurity를 생성하고 초기화를 진행한다.
- HttpSecurity에서 생성한 SecurityFilterChain 빈을 SecurityBuilder에 저장한다.
- WebSecurity가 build()를 실행하면 SecurityBuilder에서 SecurityFilterChain을 꺼내어 **FilterChainProxy** 생성자에게 전달한다.

## DelegatingFilterProxy / FilterChainProxy

### Filter
- 웹 애플리케이션에서 클라이언트의 요청(ServletRequest)과 서버의 응답(ServletResponse)을 가공하거나 검사하는데 사용되는 구성요소이다.
- 클라이언트의 요청이 서블릿에 도달하기 전이나 서블릿이 응답을 클라이언트에게 보내기 전에 특정 작업을 수행할 수 있다.
- 서블릿 컨테이너(WAS)에서 생성되고 실행되고 종료된다.

### DelegatingFilterProxy
- 스프링에서 사용되는 특별한 서블릿 필터, 서블릿 컨테이너와 스프링 애플리케이션 컨텍스트 간의 연결고리 역할을 하는 필터
- 서블릿 필터의 기능을 수행하는 동시에 스프링의 의존성 주입 및 빈 관리 기능과 연동되도록 설계된 필터라 할 수 있다.
- "springSecurityFilterChain" 이름으로 생성된 빈을 ApplicationContext에서 찾아 요청을 위임한다.
- 실제 보안처리를 수행하지 않는다.

#### 이놈이 Servlet Filter에서 Spring DI를 사용하는게 가능한 이유를 설명해준다.

### FilterChainProxy
- "springSecurityFilterChain"의 이름으로 생성되는 필터 빈으로서 DelegatingFilterProxy 으로 부터 요청을 위임 받고 보안 처리 역할을 한다.
- 내부적으로 하나 이상의 SecurityFilterChain 객체들을 가지고 있으며 요청 URL 정보를 기준으로 적절한 SecurityFilterChain을 선택하여 필터들을 호출한다
- HttpSecurity를 통해 API 추가 시 관련 필터들을 추가 된다.
- 사용자의 요청을 필터 순서대로 호출함으로 보안 기능을 동작시키고 필요 시 직접 필터를 생성해서 기존의 필터전, 후로 추가 가능하다.

## 사용자 정의 보안 설정하기

### 사용자 정의 보안 기능 구현
- 한개 이상의 SecurityFilterChain 타입의 빈을 정의한 후 인증 API 및 인가 API를 설정한다.
****
# 인증 프로세스

## 폼 인증 - formLogin()

### 폼 인증
- HTTP 기반의 폼 로그인 인증 메커니즘을 활성화하는 API로서 사용자 인증을 위한 사용자 정의 로그인 페이지를 쉽게 구현할 수 있다.
- 기본적으로 스프링 시큐리티가 제공하는 기본 로그인 페이지를 사용하며 사용자 이름과 비밀번호 필드가 포함된 간단한 로그인 양식을 제공한다.
- 사용자는 웹 폼을 통해 자격증명(사용자 이름과 비밀번호)을 제공하고 Spring Security는 HttpServletRequest에서 이값을 읽어 온다.

## 폼 인증 필터 - UsernamePasswordAuthenticationFilter

### 개요
- 스프링 시큐리티는 AbstractAuthenticationProcessingFilter 클래스를 사용자의 자격 증명을 인증하는 기본 필터로 사용한다.
- UsernamePasswordAuthenticationFilter는 AbstractAuthenticationProcessingFilter를 확장한 클래스로서 HttpServletRequest에서 제출된 사용자 이름과 비밀번호로 부터 인증을 수행한다.
- 인증 프로세스가 초기화 될 때 페이지와 로그아웃 페이지 생성을 위한 DefaultLoginPageGeneratingFilter 및 DefaultLogoutPageGeneratingFilter가 초기화 된다.

## 기본 인증 – httpBasic()

### HTTP Basic 인증
- HTTP는 액세스 제어와 인증을 위한 프레임워크를 제공하며 가장 일반적인 인증 방식은 "Basic" 인증 방식이다.
- RFC 7235 표준이며 인증 프로토콜은 HTTP 인증 헤더에 기술되어 있다.

#### 주의사항
- base-64 인코딩된 값은 디코딩이 가능하기 때문에 인증정보가 노출된다.
- HTTP Basic 인증은 반드시 HTTPS 와 같이 TLS 기술과 함께 사용해야 한다.

## 기본 인증 필터 - BasicAuthenticationFilter

### BasicAuthenticationFilter
- 기본 인증 서비스를 제공하는 데 사용된다.
- BasicAuthenticationConverter를 사용해서 요청 헤더에 기술된 인증정보의 유효성을 체크하며 Base64 인코딩된 username과 password를 추출한다
- 인증 이후 세션을 사용하는 경우와 사용하지 않는 경우에 따라 처리되는 흐름에 차이가 있다. 기본적으로는 사용하지 않는다.
- 세션을 사용하는 경우 매 요청마다 인증과정을 거치지 않으나 세션을 사용하지 않는 경우 매 요청마다 인증과정을 거쳐야 한다.

## 기억하기 인증 – rememberMe()

### RememberMe 인증
- 사용자가 웹 사이트나 애플리케이션에 로그인할 때 자동으로 인증 정보를 기억하는 기능이다
- UsernamePasswordAuthenticationFilter 와 함께 사용되며, AbstractAuthenticationProcessingFilter 슈퍼 클래스에서 훅을 통해 구현된다.
	- 인증 성공시 RememberMeServices.loginSuccess()를 통해 RemeberMe 토큰을 생성하고 쿠키로 전달한다.
	- 인증 실패시 RememberMeServices.loginFail()를 통해 쿠키를 지운다.
	- LogoutFilter 와 연계해서 로그아웃 시 쿠키를 지운다.

#### 토큰 생성
- 기본적으로 암호화된 토큰으로 생성 되어지며 브라우저에 쿠키르 보내고, 향후 세션에서 이 쿠키를 감지하여 자동 로그인이 이루어지는 방식으로 달성된다.
- base64(username + ":" + expirationTime + ":" algorithmName + ":" + algorithmHex(username + ":" + expirationTime + ":" + password + ":" + key))
	- username: UserDetailsService로 식별 가능한 사용자 이름
	- password: 검색된 UserDetails 에 일치하는 비밀번호
	- expirationTime: remeber-me 토큰이 만료되는 날짜와 시간, 밀리초로 표현
	- key: remember-me 토큰의 수정을 방지하기 위한 개인키
	- algorithmName: remember-me 토큰 서명을 생성하고 검증하는 데 사용되는 알고리즘 (기본적으로 SHA-256 알고리즘을 사용)

### RememberMeServices 구현체

#### TokenBasedRememberMeServices
- 쿠키 기반 토큰의 보안을 위해 해싱을 사용한다

#### PersistentTokenBasedRememberMeServices
- 생성된 토큰을 저장하기 위해 데이터베이스나 다른 영구 저장 매체를 사용한다.

두 구현 모두 사용자의 정보를 검색하기 위한 UserDetailsService가 필요하다.

## 기억하기 인증 필터 - RememberMeAuthenticationFilter

### RememberMeAuthenticationFilter
- SecurityContextHolder에 Authentication이 포함되지 않은 경우 실행되는 필터이다.
- 세션이 만료되었거나 어플리케이션 종료로 인해 인증 상태가 소멸된 경우 토큰 기반 인증을 사용해 유효성을 검사하고 토큰이 검증되면 자동 로그인 처리를 수행한다.

## 익명 인증 사용자 – anonymous()

### 익명사용자
- 스프링 시큐리티에서 "익명으로 인증된" 사용자와 인증되지 않은 사용자 간에 실제 개념적 차이는 없으며 단지 액세스 제어 속성을 구성하는 더 편리한 방법을 제공한다고 볼 수 있다.
- SecurityContextHolder 가 항상 Authentication 객체를 포함하고 null을 포함하지 않는다는 것을 규칙을 세우게 되면 크래스를 더 견고하게 작성할 수 있다.
- 인증 사용자와 익명 인증 사용자를 구분해서 어떤 기능을 수행하고자 할 때 유용할 수 있으며 익명 인증 객체를 세션에 저장하지 않는다.
- 익명 인증 사용자의 권한을 별도로 운용할 수 있다. 즉 인증된 사용자가 접근할 수 없도록 구성이 가능하다.

### AnonymousAuthenticationFilter
- SecurityContextHolder에 Authentication 객체가 없을 경우 감지하고 필요한 경우 새로운 Authentication 객체로 채운다.

## 로그 아웃 – logout() -1

### 로그아웃
- 스프링 시큐리티는 기본적으로 DefaultLogoutPageGeneratingFilter 를 통해 로그아웃 페이지를 제공하며 "GET/logout" URL 로 접근이 가능하다
- 로그아웃 실행은 기본적으로 "POST/logout" 으로만 가능하나 CSRF 기능을 비활성화 할 경우 혹은 RequestMatcher를 사용할 경우 GET, PUT, DELETE 모두 가능하다.
- 로그 아웃 필터를 거치지 않고 스프링 MVC에서 커스텀 하게 구현할 수 있으며 로그인 페이지가 커스텀하게 생성될 경우 로그아웃 기능도 커스텀하게 구현해야 한다.

## 로그 아웃 – logout() -2

## 요청 캐시 RequestCache / SavedRequest

### RequestCache
- 인증 절차 문제로 리다이렉트 된 후에 이전에 했던 요청 정보를 담고 있는 'SaveRequest' 객체를 쿠키 혹은 세션에 저장하고 필요시 다시 가져와 실행하는 캐시 메커니즘이다.

### SaveRequest
- 로그인과 같은 인증 절차 후 사용자를 인증 이전의 원래 페이지로 안내하며 이전 요청과 관련된 여러 정보를 저장한다.

### RequestCacheAwareFilter
- 이전에 저장했던 웹 요청을 다시 불러오는 역할을 한다.
- SavedRequest가 현재 Request와 일치하면 이 요청을 필터 체인의 doFilter 메소드에 전달하고 SavedRequest 가 없으면 필터는 원래 Request 을 그대로 진행시킨다.
****
# 인증 아키텍처

## 인증 – Authentication

### Authentication
- 인증은 특정 자원에 접근하려는 사람의 신원을 확인하는 방법을 의미한다.
- 사용자 인증의 일반적인 방법은 사용자 이름과 비밀번호를 입력하게 하는 것으로서 인증이 수행되면 신원을 알고 권한 부여를 할 수 있다.
- 사용자의 인증 정보를 저장하는 토큰 개념의 객체로 활용되며 인증 이후 SecurityContext 에 저장되어 전역적으로 참조가 가능하다.

## 인증 컨텍스트 - SecurityContext / SecurityContextHolder -1

### SecurityContext

#### Authentication 저장
- 현재 인증된 사용자의 Authentication 객체를 저장한다.
#### ThreadLocal 저장소 사용
- SecurityContextHolder 를 통해 접근되며 ThreadLocal 저장소를 사용해 각 스레드가 자신만의 보안 컨텍스트를 유지한다.
#### 애플리케이션 전반에 걸친 접근성
- 애플리케이션의 어느 곳에서나 접근 가능하며 현재 사용자의 인증 상태나 권한을 확인하는 데 사용된다.5

### SecurityContextHolder
#### SecurityContext 저장
- 현재 인증된 사용자의 Authentication 객체를 담고 있는 SecurityContext 객체를 저장한다.
#### 전략 패턴 사용
- 다양한 저장 전략을 지원하기 위해 SecurityContextHolderStrategy 인터페이스를 사용한다.
#### 기본 전략
- MODE_THREADLOCAL
#### 전략 모드 직접 지정
- SecurityContextHolder.setStrategyName(String)

### SecurityContextHolder 저장모드
#### MODE_THREADLOCAL
- 기본 모드로, 각 스레드가 독립적인 보안 컨텍스트를 가진다. 대부분의 서버 환경에 적합하다.
#### MODE_INHERITABLETHREADLOCAL
- 부모 스레드로부터 자식 스레드로 보안 컨텍스트가 상속되며 작업을 스레드 간 분산 실행하는 경우 유욜 할 수 있다.
#### MODE_GLOBAL
- 전역적으로 단일 보안 컨텍스트를 사용하며 서버 환경에서는 부적합하며 주로 간단한 어플리케이션에 적합하다.

### SecurityContextHolder & SecurityContext 구조
- 스레드 마다 할당 되는 전용 저장소에 SecurityContext를 저장하기 때문에 동시성의 문제가 없다.
- 스레드 풀에서 운용되는 스레드일 경우 새로운 요청이더라도 기존의 ThreadLocal이 재사용될 수 있기 때문에 클라이언트로 응답 직전에 항상 SecurityContext를 삭제 해 주고 있다.

### 스레드풀의 스레드 로컬 사용 주의점
- 항상 스레드 로컬을 사용할 때는 요청에 대해서 처리를 하다가 응답할 때는 그 스레드 로컬에 포함되어 있는 어떤값들을 다 초기화해 주고 해야 된다.

## 인증 컨텍스트 - SecurityContext / SecurityContextHolder -2

## 인증 관리자 - AuthenticationManager - 1

### AuthenticationManager
- 인증 필터로 부터 Authentication 객체를 전달 받아 인증을 시도하며 인증에 성공할 경우 사용자 정보, 권한 등을 포함한 **완전히 채워진 Authentication 객체를 반환**한다.
- 여러 AuthenticationProvider 들을 관리하며 AuthenticationProvider 목록을 순차적으로 순회하며 인증 요청을 처리한다.
- AuthenticationProvider 목록 중에서 인증 처리 요건에 맞는 적절한 AuthenticationProvider 를 찾아 인증처리를 위임한다.
- AuthenticationManagerBuilder에 의해 객체가 생성되며 주로 사용하는 구현체로 ProviderManager가 제공된다.

### AuthenticationManagerBuilder
- AuthenticationManager 객체를 생성하며 UserDetailsService 및 AuthenticationProvider 를 추가할 수 있다.
- HttpSecurity.getSharedObject(AuthenticationManagerBuilder.class)를 통해 객체를 참조할 수 있다.

## 인증 관리자 - AuthenticationManager - 2

## 인증 제공자 - AuthenticationProvider - 1

### AuthenticationProvider
- 사용자의 자격 증명을 확인하고 인증 과정을 관리하는 클래스로서 사용자가 시스템에 액세스하기 위해 제공한 정보(예:아이디와 비밀번호)가 유효한지 검증하는 과정을 포함한다.
- 다양한 유형의 인증 메커니즘을 지원할 수 있는데, 예를 들어 표준 사용자 이름과 비밀번호를 기반으로 한 인증, 토큰 기반 인증, 지문 인식 등을 처리할 수 있다.
- 성공적인 인증 후에는 Authentication 객체를 반환하며 이 객체에는 사용자의 신원 정보와 인증된 자격 증명을 포함한다.
- 인증 과정 중에 문제가 발생할 경우 AuthenticationException 과 같은 예외를 발생시켜 문제를 알리는 역할을 한다.

## 인증 제공자 - AuthenticationProvider - 2

### Bean으로 하나만 올릴경우
```java
@Bean  
AuthenticationProvider authenticationProvider() {  
    return new CustomAuthenticationProvider();  
}
```
- parent.providers에 기본적으로 생성되는 new DaoAuthenticationProvider()를 대체 해버린다.

### Bean으로 2개이상 올릴경우
```java
AuthenticationManagerBuilder builder = http.getSharedObject(AuthenticationManagerBuilder.class);
        builder.authenticationProvider(authenticationProvider());
        builder.authenticationProvider(authenticationProvider2());

@Bean  
AuthenticationProvider authenticationProvider() {  
    return new CustomAuthenticationProvider();  
}  
  
@Bean  
AuthenticationProvider authenticationProvider2() {  
    return new CustomAuthenticationProvider();  
}
```
- 자동으로 등록되지는 않고 직접 추가해줘야 한다.

## 사용자 상세 서비스 - UserDetailsService

### UserDetailsService
- 주요 기능은 사용자와 관련된 상세 데이터를 로드하는 것이며 사용자의 신원, 권한, 자격 증명 등과 같은 정보를 포함할 수 있다.
- 이 인터페이스를 사용하는 클래스는 주로 AuthenticationProvider 이며 사용자가 시스템에 존재하는지 여부와 사용자 데이터를 검색하고 인증 과정을 수행한다.

## 사용자 상세 - UserDetails

### UserDetails
- 사용자의 기본 정보를 저장하는 인터페이스로서 Spring Security 에서 사용하는 사용자 타입이다.
- 저장된 사용자 정보는 추후에 인증 절차에서 사용되기 위해 Authentication 객체에 포함되며 구현체로서 User 클래스가 제공된다.
****
# 인증 상태 영속성

## SecurityContextRepository / SecurityContextHolderFilter - 1

### SecurityContextRepository
- 사용자가 인증을 한 이후 요청에 대해 계속 사용자의 인증을 유지하기 위해 사용되는 클래스
- 인증 상태의 영속 메커니즘은 사용자가 인증을 하게 되면 해당 사용자의 인증 정보와 권한이 SecurityContext에 저장되고 HttpSession 을 통해 요청 간 영속이 이루어 지는 방식이다.

### SecurityContextHolderFilter
- SecurityContextRepository 를 사용하여 SecurityContext를 얻고 이를 SecurityContextHolder 에 설정하는 필터 클래스이다.
- 이 필터 클래스는 SecurityContextRepository.saveContext()를 강제로 실행시키지 않고 사용자가 명시적으로 호출되어야 SecurityContext를 저장할 수 있는데 이는 SecurityContextPersistenceFilter 와 다른점이다.
- 인증이 지속되어야 하는지를 각 인증 메커니즘이 독립적으로 선택할 수 있게 하여 더 나은 유연서을 제공하고 HttpSession 에 필요할 때만 저장함으로써 성능을 향상시킨다.

## SecurityContextRepository / SecurityContextHolderFilter - 2

## SecurityContextRepository / SecurityContextHolderFilter - 3

## 스프링 MVC 로그인 구현

### 스프링 MVC 인증 구현
- 스프링 시큐리티 필터에 의존하는 대신 수동으로 사용자를 인증하는 경우 스프링 MVC 컨트롤러 엔드포인트를 사용할 수 있다.
- 요청 간에 인증을 저장하고 싶다면 HttpSessionSecurityContextRepository를 사용하여 인증 상태를 저장 할 수있다.
****
# 세션 관리

## 동시 세션 제어 - sessionManagement().maximumSessions()

### 동시 세션 제어
- 사용자가 동시에 여러 세션을 생성하는 것을 관리하는 전략
- 이 전략은 사용자의 인증 후에 활성화된 세션의 수가 설정된 maximumSessions 값과 비교하여 제어 여부를 결정한다.
****
# 예외 처리
****
# 악용 보호
****
# 인가 프로세스
****
# 인가 아키텍처
****
# 이벤트 처리
****
# 통합하기
****
# 고급설정
****
# 실전 프로젝트 - 회원 인증 시스템
****
# 실전 프로젝트 - 비동기 인증
****
# 실전 프로젝트 - 회원 관리 시스템
****
# 번외
****
# 마무리
****