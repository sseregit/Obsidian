# 시작에 앞서...
## 알고 있다고 가정하는 것과 학습목표
## C/C++ 개발자에게 드리는 말씀
### C/C++ 개발자에게 드리는 말씀
- Java는 void형 변수 선언은 불가하며 반환 형식으로만 사용
- null값은 참조형에만 적용 가능
	- int a = null (불가)
	- null은 값(인스턴스)가 없다는 의미
	- 클래스 형식을 반환하는 메서드는 null 반환 가능
- 연산자 함수 없음
- Java에서 클래스 형식은 모두 참조자이며 포인터라고 생각하는 것이 용이
### Pointer스러운 참조형
- 참조형에 대한 관계연산(`==, !=`)은 객체의 메모리 주소에 대한 비교(Pointer와 동일)
- 포인터처럼 참조자 값은 변경될 수 있음
	- C++처럼 선언과 동시에 초기화 하지 않아도 무방
- null 대입 가능하며 참조 대상이 없는 참조자를 이용해 멤버접근 연산을 수행하면 NullPointerException 에러 발생
****
# 클래스 - 첫 번째
## 객체, 클래스, 인스턴스
### 객체(Object)란 무엇인가?
- OOP환경에서 소프트웨어(소스코드)를 구성한느 단위요소
- 변수 및 그와 관련한 메서드(Method)가 모여서 이뤄진 하나의 집합체
	- **클래스는 반드시 존재 이유와 목적이 명확해야함**
- Java에서는 클래스(Class)로 객체를 기술
### 항, 식, 구문
- 여러 항이 모여 식을 이룸
- 식은 평가 대상(식을 평가하기 위해서는 계산(연산)을 해야함)
- 여러 식을 모아 하나의 구문을 이루며 고급어 기준 실행단위가 됨
- 연속되는 구문을 위에서 아래로 순차적 실행
### 클래스, 객체, 인스턴스
- 클래스는 변수와 같은 자료형으로 이해
	- 클래스(집합체)는 객체(단위)를 기술하는 문법
	- 클래스 형식에 대해 선언 할 수 있는 것은 참조(null 가능)
- 사전적 의미는 '예시' 혹은 '경우'
- 변수 대신 인스턴스라고 표현
	- int형식에 대한 인스턴스 a
- 다양하게 사용되는 용어
	- 프로세스 인스턴스
## 클래스 기본 문법과 두 가지 관점
### 클래스 기본 문법
	`class class-name {}`
- 관계에 관해 생각하지 않는다면 함수(메서드)를 구성요소로 포함하는 단순 집합체로 이해
- 구성요소(변수나 함수)를 멤버라 지칭
	- 변수는 필드(Field), 함수는 메서드(Method)
	- 변수는 메모리를 사용하는 보편적인 수단
- 선언과 정의가 공존하는 구조
- **객체 작성자와 사용자를 구분해 생각하는 능력 필수**
#### Convention
	`className.java`
- 클래스 이름은 영문으로 작성하되 첫 글자는 대문자로 표기하는 것이 보편적 규칙
- 클래스 이름과 저장되는 .java 파일명이 같아야 함
	- 대소문자 구분
	- public 선언 시 필수
	- 단, 특정 .java 파일에 여러 클래스를 함께 정의할 경우 별도 파일로 저장하지 않음
## 생성자와 필드 초기화
### 멤버 선언 및 초기화
- 필드 선언 시 초깃값 정의 가능
	- 초깃값을 기술하지 않을 경우 기본 값은 0
- 생성자를 통해 초기화 가능
	- 필드 선언 시 기술한 초깃값과 생성자에서 정의하는 값이 서로 다를 경우 생성자에 기술한 코드가 우선
- `동적 == Dynamic == Runtime`
### 생성자
- 생성자는 객체가 생성되는 시점에 자동으로 호출 되는 메서드
	- 이름이 클래스 이름과 동일
	- 생략 시 컴파일러가 빈 생성자를 자동으로 추가
	- 반환자료와 호출자가 없다는 점에 유의
- 객체의 생성은 new 연산에 따른 동적 생성
- 다중 정의 가능
- **클래스 자체와 관련된 코드만 기술할 것**
### 인스턴스 동적 생성
- new 연산자를 이용해 인스턴스 동적 생성
- 클래스 형식에 대한 변수 선언은 모두 참조
	- 인스턴스가 존재하지 않는 경우는 null
- 한 인스턴스에 대해 여러 참조자가 존재할 수 있음
	- 사이드 이펙트 문제 고려
## 클래스 멤버에 대한 접근 제어
### 접근 제어 지시자
#### public
- 외부접근 허용
#### protected
- 외부접근 차단
- 같은 패키지 및 파생 클래스의 접근은 허용
#### default
- 같은 패키지 소속 클래스만 접근 허용
#### private
- 외부접근 차단
### getter()와 setter()
- 감춰진 필드에 대해 외부에서 접근 할 수 있도록 허용된 메서드
- 필드에 대한 읽기, 쓰기 접근을 분리해 통제 가능
- 도구에서 자동 생성 지원
- 객체지향 프로그래밍에서는 객체를 제작하는 관점과 생성하고 사용하는 관점 두 가지를 분리해 생각해야 함
## this
### this
- 클래스로 구현한 객체 자신의 인스턴스에 대한 참조자
- 클래스(현재 코드)에 대한 인스턴스(미래, 외부) 선언 시 값이 결정될 수 있음 (주소)
- 같은 클래스에 대한 인스턴스라 하더라도 this 값은 각자 다른값이 됨
- 메서드 호출 시 스택(0번 슬롯)에 값이 저장
- 정적 메서드에서는 사용 할 수 없음
## [실습] 문자열 처리를 위한 MyString 클래스 개발
## MyString 클래스 작성 실습 해설
****
# 클래스 - 두 번째
## 생성자 다중 정의
### 생성자 다중 정의
- 일반 메서드처럼 생성자도 매개변수 구성이 다른 생성자를 여럿 정의할 수 있음
	- 여러 개가 다중 정의되어 있다하더라도 new 연산 시 호출되는 생성자는 1개
- 생성자에서 다른 생성자 호출 가능
## [실습] MyString 클래스 생성자 다중 정의
## 깊은 복사와 얕은 복사 (※매우 중요)
### Shallow copy
- 참조의 대상은 복사해서 늘리지 않고 참조자만 늘리는 형태
	- 사이드 이펙트 발생의 원인
- 대상 인스턴스는 그대로 두고 참조만 늘어나는 경우
### Deep copy
- 원본 자체도 새로 할당하고 복사하는 방식
- Shallow copy와 달리 두 개의 원본 두 개의 참조가 각각 별도로 존재
- 사이드 이펙트 오류 가능성이 없음
- 참조를 멤버로 가지며 인스턴스를 동적 할당하는 경우 복사 생성자 구현
	- clone()
## 복사 생성자 (※매우 중요)
### 복사 생성자
	`class-name(class-name rhs)`
- 객체의 사본을 생성할 때 사용하기 적절한 생성자 함수
	- C++ 스타일 문법
- rhs는 Right Hand Side의 약어이며 복사의 원본 인스턴스에 대한 참조
- clone() 메서드를 만드는 방법이 있으나 규약에 모호한 부분이 있고 예외처리가 복잡한 단점이 있음
## [실습] MyString에 복사 생성자 추가
## 보이지 않는 임시 객체
### 보이지 않는 임시 객체
- 클래스가 함수의 반환 자료형이 될 경우 (이름이 없는) 임시 객체를 생성
- String 클래스는 덧셈 연산 시 임시 객체 생성
	- 비효율의 직접적 원인이 될 수 있음
## 정적 멤버와 특이한 코드
### 정적 멤버
- 클래스 인스턴스가 없어도 **독립적으로 존재**가능
	- 필드(**모든 인스턴스에서 공유**), 메서드
- 일반 메서드와 달리 인스턴스 선언 없이 호출 가능
- 메서드에서 this를 사용할 수 없음
- 정적 필드는 final 선언 함으로써 심볼릭 상수로 활용하는 경우가 많음
### 정적 필드와 인스턴스 메모리 차이
- 정적 필드는 인스턴스 메모리와 독립적이며 메소드 코드는 인스턴스 마다 다르지 않고 하나만 존재
## [실습] 정적 메서드로 MyString 클래스 객체 생성하기
****
# 상속과 관계
## 상속에 대한 기본 이론
### 상속에 대한 기본 이론
	`class child extends parent`
- 객체단위 코드를 재사용(확장)하는 문법
- is-a, has-a 관계로 설명 가능
- 부모/자식 클래스, 기본/파생 클래스로 구분 할 수 있음
- C++과 달리 다중 상속은 허용하지 않음
- Java에서 모든 클래스는 Object의 파생형식
- **파생 클래스 생성 시 기본 클래스도 함께 생성**(생성자 호출)
- 파생 클래스는 기본 클래스 멤버에 접근 가능
	- 접근제어 지시자에 따라 제어
- 파생 클래스에서 **기본 클래스 메서드 재정의(Override) 가능**(다중 정의와 다름에 주의)
- 추상 자료형 개념 적용 가능
- 상속 관계가 적용될 경우 코드의 흐름이 2차원적 구조를 갖게 되어 감춰지는 경향이 있음
## 상속과 생성자 (신박한 바보짓)
### 상속과 생성자 호출스택
- **파생 클래스 생성자는 가장 먼저 호출되지만 가장 나중에 실행된다.**
- 재귀호출과 비슷하게 생성자 함수에 대한 호출 스택이 쌓여 올라가는 것이 특징
- 파생 클래스에서 기본 클래스 필드를 정의하는 것은 적절하지 않은 경우가 대부분
### 상속관계에서 인스턴스 메모리 구조
- 파생 클래스 인스턴스는 부모 클래스(들) 인스턴스를 내부에 포함하고 있는 구조
- 파생 클래스는 부모 클래스의 멤버를 가진것
	- private이면 파생 클래스 접근도 차단
	- protected면 파생 클래스 접근 허용
### 상속을 배우는 순간부터 알아야 할 시간차
- 부모 클래스와 파생 클래스가 정의되는 시점
	- 부모 클래스 기준 '현재'는 파생 클래스가 '미래'에 정의되는 것임을 확정
	- 6개월 후 미래의 당신은 오늘 이 클래스에 대해 얼마나 기억할 수 있을 것인지 고려
- 이해도 부족에 따른 문제
	- 증조 할아버지에 대해 얼마나 알고 있는가?
	- 상속에 상속이 이어지는 것은 결코 바람직하지 않음
- 미래의 파생 클래스를 고려해 현재 클래스 코드 작성
## 부모 클래스 생성자 선택
### 부모 클래스 생성자 선택
- 파생 클래스 생성자에서 부모 클래스의 (다중정의 된) 여러 생성자 중 원하는 것이 호출되도록 강제화
- `super();`
## 메서드 재정의(Overriding, ※매우 중요)
### 메서드 재정의(Overriding)
- 파생 클래스에서 기본 클래스 메서드 재정의(Override) 가능 (다중 정의와 다름에 주의)
	- @Override 어노테이션
- 기본 클래스 메서드를 재정의 하는 것은 기존 메서드를 대체하거나 코드를 추가할 목적으로 볼 수 있음
- 메서드 재정의 시 실제 인스턴스 형식이 우선
- final 선언으로 파생 클래스에서 메서드가 재정의되지 못하도록 차단할 수 있음
### 어노테이션(Annotaion) 소개
- 코드에 추가 할 수 있는 메타 데이터로 단순히 주석처럼 쓰이거나 코드를 간소화 할 수 있는 도구로 사용
- 대표적 표준 어노테이션
	- @Override (재정의)
	- @SuppressWarning (컴파일러 경고 메시지 무시)
	- 메타 어노테이션 (어노테이션에 대한 어노테이션)
	- 사용자 정의 어노테이션
## 불필요한 호출로 미래와 대화하기 (※매우 중요)
### 불필요한 호출로 미래와 대화하기
- 부모 클래스에서 정한 함수 호출 관계로 파생 클래스에서 재정의된 메서드가 호출 될 수 있음
- 구조가 정한 흐름을 확장해 (그 구조에) 내 코드를 추가하는 방식으로 올라 탈 수 있음
	- Called by framework
	- onXxx() 메서드
## [실습] 상속과 문자열 필터 구현
## 객체간 관계와 UML
## Java와 C++ 메모리 관리 차이
### UML(Unified Modeling Language)
- 모델링 언어 표준으로 클래스 및 연관 관계를 시작화 할 수 있는 방법론
- **Class, Sequence diagram**등에 대해서는 반드시 알아야함
#### Class diagram
- `public : +`로 표현
	- `+ getName: String`
- `private : -`로 표현
	- `- name: String`
### 클래스 관계

| 일반화 (상속)         | ㅡ▶️         |
| ---------------- | ----------- |
| 실체화 (상속)         | - - ▶️      |
| 의존               | - - >       |
| 연관               | ㅡ           |
| 직접연관             | ㅡ>          |
| 집합 (Aggregation) | 🔹(empty)ㅡ> |
| 합성 (Composite)   | 🔹ㅡ>        |
## 알아 두면 좋을 동적 바인딩
### 알아 두면 좋을 동적 바인딩
- 함수와 함수가 서로 호출 피호출 관계가 되는 것이 **바인딩**
- 바인딩 시점이 Compile-time이면 Static binding
- 바인딩 시점이 Run-time이면 Dynamic binding(Lately binding)
### C++ 가상 함수 테이블 (vtable)
- vtable은 클래스 멤버 함수 중 가상화 된 함수들에 대한 포인터의 배열
- 가상 함수는 함수 포인트 배열을 참조해 호출할 함수를 결정(Dynamic binding)
- 상속관계일 때 vtable의 값은 파생 클래스 생성자가 호출되는 시점에 업데이트 되는 것이 특징
****
# 다형성
## 다형성과 형변환 그리고 추상성
### 다형성(Polymorphism)
- 사전적 정의는 같은 종의 생물이면서도 어떤 형태나 형질이 다양하게 나타나는 현상
- 객체지향 프로그래밍의 중요한 특징
	- 추상화(혹은 일반화), 구체화
	- 추상성이 높은 수준에서 구조를 단순화 할 수 있음
	- Framework가 구현될 수 있는 원리
### 부모 자식 클래스간 형식 변환
- 클래스 A의 모든 파생형식은 A로 캐스팅 가능(업 캐스팅)
- 클래스 A 참조하는 대상 인스턴스는 A 혹은 A의 파생형식
## [실습] Shape 클래스
## 다운 캐스팅과 instanceof 연산자
### 다운 캐스팅
- 부모 클래스 형식 참조자가 가리키는 대상 인스턴스를 특정 파생형식으로 캐스팅하는 것
- 적절치 못한 캐스팅 시 오류 발생
- 모든 파생클래스는 부모 클래스에 대해 존립 의존적이지만 부모 클래스에서 다운 캐스팅하는 코드가 존재할 경우 **의존성이 역전되는 좋지 못한 코드가 될 수 있음**
### instanceof 연산자 활용
	`boolean result = obj instanceof instance`;
- 다운 캐스팅이 적절한 것인지 확인할 수 있는 연산자
- RTTI(Run Time Type Information)
## 추상 클래스
### 추상 클래스
	`public abstract class class-name`
- **new 연산으로 인스턴스 생성 불가**
	- C++의 순수 가상 클래스 개념
- 오직 파생 클래스를 위해 존재하는 클래스
- 설계적인 관점에서 존재
- 추상 메서드를 가지는 것이 일반적
	- `abstarct void getA();`
	- 파생형식에서 반드시 재정의 해야 함
## 인터페이스 (클래스)
### 인터페이스 만들기
	`[public] interface iface-name`
- 필드를 가지지 않는 추상 클래스를 선언하는 것으로 이해할 수 있음 (단, 상수 필드는 가질 수 있음)
- 인터페이스 파생은 `extends` 대신 `implements`
- 인터페이스는 메소드 원형을 기술하기 위한 것으로 구체적 정의가 없는 순수한 '선언'에 해당
	- 각종 심볼릭 상수 정의
	- C언어의 헤더 파일과 유사한 의미를 가짐
	- 다중상속 가능
## 열거형
### 열거형
	`public enum enum-name{value#0, value#n...}`
- 심볼릭 상수를 정의할 수 있는 문법으로 형안전성을 제공하고 가독성이 좋은 코드를 만들 수 있음
- `java.lang.Enum`의 파생 클래스
- 주요 멤버
	- `values(), valueOf(String name)`
	- `name()`
	- `ordinal()`
	- `toString()`
## 생각해볼 문제 (어쩌면 농담)
### 생각해볼 문제
#### OOP에 관한 논쟁은 늘 어디서든 있는 편
- 잔소리는 충고의 파생형식인가?
- 잔소리, 충고 모두 조언의 파생형식인가?
- 잔소리, 충고, 조언 모두 말하기의 파생형식인가?
****
# JVM(Java Virtual Machine) 기본 이론
## Java와 C++ 메모리 관리 차이
## JVM 구성요소 정리
## .class 파일과 바이트 코드 소개
## 클래스 로더 및 로딩 과정
### 클래스 로더
- 이름을 알고 있는 특정 클래스에 대한 정의(Byte stream)를 가져오는 역할을 수행
#### 부트스트랩 클래스 로더
- JVM에서 라이브러리로 취급(rt.jar, tools.jar)되는 것들을 로드 (핫스팟에서는 C++로 구현)
#### 플랫폼 클래스 로더 (기존 확장 클래스 로더)
- 클래스 라이브러리 로드
- 개념상 하드웨어와 애플리케이션 중간의 역할을 해줄 그런 코드들이 로드 된다 생각하면 된다.
#### 애플리케이션 클래스 로더
- `sun.misc.Launcher$AppClassLoader`를 의미
### Java 클래스 로딩
- 클래스 로딩 및 링킹 과정이 모두 런타임에 이루어짐
- 실행 성능이 일부 저하될 수 있으나 높은 확장성과 유연성을 제공하는 근간
	- 인터페이스만 맞으면 Runtime에 구현 클래스를 결정하지 않을 수 있음
	- 클래스 로더는 실행할 프로그램 코드를 네트워크로 수신하는 것도 가능
- 해석(Resolution) 단계는 동적 바인딩(혹은 늦은 바인딩)을 지원할 목적으로 초기화 후로 지연될 수 있음
#### 클래스 검증
- JVM 명세가 정하는 규칙과 제약을 만족하는지 확인
	- 파일 형식(.class)
	- 메타데이터
	- 바이트코드
	- 심벌 참조
- 보안위협에 대한 검증 포함
	- 바이트코드 검증 시 함께 확인
#### 준비 및 해석
- `java.lang.Class`인스턴스(메타 데이터)가 힙 영역에 생성되고 클래스 변수(정적 멤버) 메모리를 0으로 초기화
	- 로드되고 클래스의 인스턴스는 Using 단계에서 힙 사용
	- final 선언된 변수는 코드에서 정의한 초깃값으로 정의(0이 아닐 수 있음)
- 생성자 호출전 상태 (new 연산전)
	- 필드(인스턴스 변수) 초깃값은 생성자 호출 시 정의
	- 정적 필드에 초깃값 할당
- 해석은 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정
#### Heap 영역에 객체 생성
- JVM은 객체 저장을 위한 메모리 공간을 확보 후 0으로 초기화 (단, 객체 헤더 제외)
- 객체 초기화를 위한 구성설정 실시
	- 클래스 이름 및 메타 정보 확인 방법
	- 객체에 대한 해시코드
	- GC 세대 나이
- 생성자 호출
## 런타임 데이터 영역
### JVM runtime data area
#### Method area
- JVM이 읽어 들인 각종 타입 정보, 상수, 정적 변수 정보가 저장되는 영역
- JIT(Just In Time) 컴파일러가 번역한 기계어 코드를 캐싱하기 위한 메모리 공간으로 활용
- Java 8부터는 PermGen이 아니라 Metaspace에 속함
##### Metaspace
- JVM 힙이 아니라 네이티브 메모리에서 관리하며 크기가 동적으로 달라질 수 있음
##### Runtime constant pool
- 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 정보 및 각종 리터럴, 심볼 참조가 저장되는 영역
- 클래스 로더가 클래스를 로드할 때 상기 정보들을 저장
- 동적으로 운영되며 런타임에 새로운 상수가 추가될 수 있음
## JVM 스택 구조

수강평

학습 알림

공유

0sfast_forward

0sfast_rewind

우리가 또 신경써서 봐야 될 그런 요소가 바로 스택이죠

# JVM 스택 구조
### Stack area
- 지역변수 테이블, 피연산자 스택, 메서드 반환값 등을 저장
	- C/C++의 Stack보다 더 복잡한 구조를 가짐
- 보통 지역변수 테이블을 스택으로 지칭
- 지역변수 테이블은 슬롯으로 이루어지며 기본형 변수 하나가 슬롯 한 개(혹은 2개)를 사용
- Java 스택의 크기는 메모리 용량이 아니라 슬롯의 개수
- JVM이 허용하는 스택의 크기를 초과할 경우 StackOverflowError 에러 발생
### Stack frame 구조
- 지역변수 테이블은 인덱스 방식으로 운영됨
- 한 요소를 슬롯으로 지칭하며 기본형식 자료나 참조 하나를 저장
- 0번은 this (포인터)
### Native method stack
- C++로 개발된 Native 코드(함수 단위)가 실행 될 때 지역변수 및 자동변수가 사용하는 스택 메모리
- 구현하기에 따라 JVM stack과 합쳐서 사용하기도 한다.
## JVM 힙 영역과 GC
### JVM Heap 영역
- **GC(Garbage collector)** 가 관리하는 메모리 영역으로 Java에서 사용되는 객체의 인스턴스 및 배열이 저장되는 공간
- 설정에 따라 크기를 변경하거나 고정할 수 있음
	- 부족시 OutOfMemoryError 오류 발생
- 세대별 컬렉션 이론(Generational collection theory)을 기반으로 설계 및 운영
	- Eden, Survivor
	- New/Old generation
	- 영구 세대(Metaspace)
### JVM Garbage collector
- Heap 영역에서 참조되지 않는 개체를 수집 및 제거해 메모리 회수
- Minor/Major(Full) GC
	- GC수행 시 프로그램 일시 정지
	- stop-the-world
- GC 속도
	- Minor GC가 보통 1초 이내 완료
	- Full GC는 수 초 이상 진행되기도 하며 이 지연 때문에 DB연결이 끊기는 등 운영 문제가 발생할 수 있음
### GC기술의 시작
- Java에서 (거의) 모든 인스턴스는 힙 영역에 저장
- Garbage collection 기술은 1960년대에 만들어진 리스프
- GC가 처리해야 할 문제의 핵심 3요소 (리스프 창시자 존 맥카시(John McCarthy))
	- 회수 대상 메모리를 판단하는 것
	- 메모리 회수 시점
	- (구체적인) 메모리 회수 방법
****
# JVM과 GC 그리고 객체
## 세대별 컬렉션 이론
### 세대 단위 컬렉션 이론
- 핫 스팟 VM에서 에덴과 생존자 공간 비율은 보통 8:1
	- IBM 연구에 따름 (보통 첫 GC에 대략 98% 객체가 소멸)
	- 10%는 메모리 파편화 방지를 위해 활용 (Overhead)
#### 약한 세대 가설
- 대다수 객체는 일찍 사라짐
#### 강한 세대 가설
- GC과정에서 살아남은 횟수가 늘어날 수록(앞으로도) 생존 가능성이 높아짐
#### 세대 간 참조 가설
- 다른 세대에 속한 객체간 참조는 같은 세대에 속한 객체간 참조보다 훨씬 적음
### Young generation
#### Eden
- **객체 생성 직후 저장되는 영역**
- Minor GC 발생 시 Survivor 영역으로 이동
- Copy & Scavenge 알고리즘
#### Survivor 0, 1
- Minor GC 발생 시 Eden, S0에서 살아남은 객체는 S1로 이동
- S1에서 살아남은 객체는 Old 영역으로 이동
- age bit 사용 (참조계수)
### Old generation
#### Old (Old generation)
- Young generation 영역에서 소멸하지 않고 남은 개체들이 사용하는 영역
- Full GC 발생 시 개체 회수
- Mark & Compact 알고리즘
### Permanent
#### Metaspace (Java 8)
- 로드되는 클래스, 메소드 등에 관한 메타 정보 저장 (자동확장 기능)
- Java heap이 아닌 Native 메모리 영역 사용
- **리플렉션 클래스 로드 시 사용 (Spring)**
## 대표적 GC 알고리즘(Mark, Sweep, Compact)
### 대표적인 GC 알고리즘
#### Mark and sweep
- 1960년대에 제안된 가장 기본적 GC 알고리즘으로 후속알고리즘의 기본 토대
- 1단계 표시(Mark, 회수대상 판단), 2단계 회수(Sweep) 방식
##### 단점
- 효율이 일정하지 않음
	- 특히 힙이 많이 채워져 있을 경우 작업효율이 매우 떨어짐
- 메모리 파편화에 따른 비효율 문제
#### Mark and copy
- 1969년 Mark and sweep을 보완하기 위해 로버트 페니첼(Robert Fenichel)이 제안
- 가용 메모리 공간을 둘로 나눈 후 한쪽만 사용
	- 한 공간에서 Mark and sweep 실시 후 파편화된 조각(살아남은 소수 인스턴스들)을 다른 공간으로 복사
	- 사용했던 공간을 모두 비우는 방식으로 Sweep
##### 단점
- 가용 메모리 공간이 절반으로 줄어 듦 (8:1:1)
- 1989년 엔드류 아펠(Andrew Appel)의 제안으로 개선
#### Mark and compact
- 생존한 객체가 많을 수록 복사해야 할 인스턴스가 늘어나는 Mark and sweep의 단점을 극복하기 위해 1974년 에드워드 루더스(Edward Lueders)가 제안
- 1단계 Mark후 2단계에서 생존 객체를 한쪽 구석으로 모으고(이동) 나머지만 Sweep
##### 단점
- 살아남는 객체가 많을 수록 부담이 크게 증가
- 인스턴스 이동 과정에서 응용 프로그램의 연산이 일시정지 (Stop the world 발생!)
## 도달 가능성 분석
### 도달 가능성 분석
- 도달 가능성 분석(Reachability analysis) 알고리즘에 기초해 회수 대상 인스턴스를 판단
- **GC 루트 객체들을 기점으로 참조하는 다른 객체들을 탐색하는 방식**
### GC 루트 객체가 될 수 있는 것들
- JVM stack frame 지역변수 테이블에서 참조하는 객체 (현재 실행 중인 메서드)
- Synchronized 키워드로 잠겨 있는 객체
- JNI가 참조하는 객체
- 메서드 영역에서 클래스 정적 필드로 참조하는 객체
- 메서드 영역에서 상수로 참조되는 객체
- JVM 내부에서 사용되는 참조
## G1(Garbage First) GC
### 클래식 GC 종류 일부
#### Serial
- 단일 스레드로 작동. 회수가 끝날 때까지 모두 멈춤
- 간단하고 효율적이며 알고리즘 수준에서 리소스 사용량 적음
#### ParNew
- 시리얼 컬렉터를 병렬처리
#### Parallel scavenge
- 사용자 코드 처리 실행 효율 극대화를 목표로 설계
#### CMS(Concurrent Mark Sweep) GC
- Java9부터 사용하지 않다가 Java 14에서 G1GC를 지원하고자 완전히 제거
#### G1(Garbage First) GC
- **4GB 이상 대용량 Heap** 메모리를 사용하는 멀티스레드 기반 응용 프로그램에 특화된 GC
- Heap을 영역(1~32MB)단위로 분할한 후 멀티스레드로 스캔
### G1(Garbage First) GC
- 서버용 응용프로그램에 집중한 GC
	- JDK 9부터 기본 GC가 사용
- JVM 힙을 세대단위가 아닌 독립 영역으로 구분해 관리하는 것이 특징
	- Heap을 영역(1~32MB)단위로 분할한 후 멀티스레드로 스캔
- 힙의 모든 영역을 회수 집합(CSet, Collection Set)에 포함시켜 영역단위 처리
	- 가장 쓰레기가 많은 영역을 파악
	- 회수 시 가장 득이 되는 영역 파악
### 가비지 컬렉터 관련된 내용 확인방법
`java -verbose:gc (Class)`
`-Xlog:gc*`
## 객체 메모리 레이아웃과 해시코드
### 객체 메모리 레이아웃과 해시코드
- Hash code는 Object.hashCOde() 함수가 호출되는 시점에 계산
- 나이는 GC에서 살아남은 횟수
- Lock flag를 객체를 중심으로 멀티스레드 환경에서 경쟁조건이 발생하는 문제를 해결하기 위한 것
### Hash (함수)의 특징
`f(x) -> y만 가능한 단방향 함수`
- 단방향성
- 입력 값의 크기와 상관 없이 결과 값의 길이(혹은 크기)가 일정
- 데이터 무결성 확보와 관련해 IT기술 전반에서 사용된다
#### 대표적인 해시 알고리즘
- MD-5, SHA-1
- SHA-128, 256, 384, 512
#### Hash 결과
- Unique
- 중복 불가능
### 핫스팟 VM 객체 Lock flag
- 동기화 방법론
	- Spin lock
	- Mutex (OS level)

| Lock flag | 상태                  | Mark word 저장 정보      |
| --------- | ------------------- | -------------------- |
| 00        | Lightweight locking | Lock 레코드 (스핀락 동기화)   |
| 01        | Unlock              | 객체의 Hash code 및 나이   |
| 01        | Biased locking      | 스레드 ID, 타임스탬프, 객체 나이 |
| 10        | Heavyweight locking | - (뮤텍스로 동기화)         |
| 11        | GC mark             | - (GC가 객체 이동 중)      |
## Object 클래스와 동등성, 동일성
### Object 클래스
- Java의 모든 클래스는 Object의 파생형식
#### equals()
- 매개변수로 전달된 참조자와 this가 가리키는 대상이 같은 값인지 값만 비교(Shallow copy 문제)
#### hashCode()
- 객체 식별을 위한 고유 해시결과 값(Unique)
#### toString()
- 클래스명@해시코드
#### getClass()
### '같다'라는 의미
- **해시코드가 같은 인스턴스는 존재하지 않음**
- 가리키는(참조하는) 대상이 같은 경우
	- 인스턴스가 가진 값과 관련이 없음
- 인스턴스 a, b, c는 모두 같은 클래스의 인스턴스
	- 같은 클래스 인스턴스라 하더라도 각각은 독립적
	- (모든) 필드의 값이 같으면 논리적으로 같음
- 클래스가 같고 인스턴스 값(메모리에 저장된 내용)까지 같은 경우
### 동등성(Equality)과 동일성(Identity)
- 두 인스턴스를 비교해 같은 클래스 인스턴스이며 내용도 일치하는지 비교하는 것이 동등성
	- Deep copy처럼 두 인스턴스에 대해 내용을 비교
- 동일성은 같은 한 인스턴스에 대한 참조자인지 값을 비교
	- Shallow copy처럼 참조자 값만 비교
	- 한 인스턴스를 가리키는 것인지 확인
## [실습] MyString 클래스에서 equals() 재정의
****
# 불변 객체와 String 클래스
## 불변 객체의 논리적 개념
### 사이드 이펙트와 참조자
- 특정 인스턴스에 대한 참조는 여러 개가 될 수 있으며 이를 막을 수도 없음
	- 매개변수, 멀티스레딩 환경
- 모든 참조는 대상 인스턴스에 대한 읽기, 쓰기 접근(Mutable)이 모두 허용
	- 참조자 및 메서드를 통한 필드 값 변경을 제어할 수 있는 문법이 없음
- **인스턴스에 대한 무결성을 보장해야 하는 구조에서 (논리적)문제가 발생할 수 있음**
## 불변 객체의 특성 정의
### 불면(Immutable) 객체의 정의
- 모든 필드를 final 선언함으로써 상수화한 클래스 (무결성)
	- 필드 초깃값을 기술할 수 있는 부분 제외 (생성자 혹은 초깃값 정의)
- 필드 값을 변경해야 한다면 새로운 사본 인스턴스를 생성하면서 원하는 수정된 초깃값을 기술해 반환하는 구조로 개발 (원자성 보장)
	- 비효율적일 수 있으나 멀티스레딩 환경에서 장점이 있음
- 대표적 불변객체
	- String, Wrapper class
## 문자열 상수와 String
### 문자열 상수와 String
- 문자열의 본질은 문자 배열이며 문자열은 인코딩 규칙에 영향을 받음
	- char[], String
	- 문자 배열은 겹따옴표를 이용한 리터럴 표기 가능
	- Java 9이후 char[]에서 byte[]로 변경
- String 클래스는 불변 클래스이며 논리적 의미로 기본 형식에 속하는 특성을 보임
	- 덧셈 연산의 결과로 임시 객체가 생기는 문제가 있음
	- 큰 문자열을 다룰 경우 효율이 더 떨어짐
## 문자열 비교
### 문자열 비교
- 상등 연산으로 두 String 클래스 인스턴스를 비교할 경우 심각한 논리적 문제가 있을 수 있음
	- 문자열 상수 풀
	- JVM이 클래스 로딩 시 미리 인스턴스 생성
- `equals()`메서드를 활용하거나 `compareTo()` 메서드로 문자열 비교하는 것이 적절
## String 클래스 주요 메서드 소개
## JVM이 문자열 상수를 관리하는 구조
### Java가 문자열을 관리하는 구조
#### 모든 문자열은 상수 풀로 관리
- C/C++로 개발된 PE 파일과 유사한 구조
	- .exe 파일의 내부에 문자열이 포함
	- 실행 코드가 저장되는 정적 메모리 영역에 문자열 상수 저장
	- 같은 문자열 상수에 대한 포인터의 주소는 모두 동일
- 코드상 존재하는 모든 문자열 상수(리터럴)는 Class가 로딩될 때 Runtime constant pool에 등록된 후 힙 영역에 존재하는 String constant pool에도 추가(String 객체)
### `String.intern()`
`public native String intern();`
- native는 C/C++로 구현된 메소드에 붙이는 예약어
	- 문자열 상수 선언 시 내부적으로 intern() 함수 호출
	- `String s1 = "Hello"`
- 문자열 상수 풀에서 문자열을 조회하고 '무조건' 반환
	- 문자열 상수와 일치하는 문자열을 상수 풀에서 검색
	- 찾으면 이미 생성되어 있는 String 인스턴스 반환
	- 없으면 새로 String 객체 생성 후 풀에 추가하고 반환
	- 문자열 상수 풀은 힙 영역(Java 7이후)에 속하며 GC대상
### 두개의 상수 풀
#### A string literal is always of type String
- .class 파일 Constant pool에 저장 (컴파일)
- Runtime constant pool로 이동 (로딩)
- String constant pool로 이동 (실행)
## StringBuilder 클래스 소개 및 성능비교
### 내용을 변경하는 StringBuilder
- 불변 객체인 String의 단점을 해결하기 위해 만들어진 클래스로 가변 String
- 문자열 값 변경 시 임시 객체를 만들지 않고 인스턴스 데이터 직접 수정
## 래퍼 클래스, 박싱과 언박싱
### 래퍼 클래스
- 기본 데이터 형식은 클래스가 아니므로 메소드를 가지지 못함
- 이 문제를 해결하기 위해 기본 데이터 형식을 클래스로 만든 것이 Wrapper class
### 박싱과 언박싱
- 기본 형식을 래퍼 클래스로 만드는 경우가 박싱
- 래퍼 클래스에서 기본 데이터 값을 얻는 것이 언박싱
****
# 내부 클래스, 익명 객체, 패키지
## 중첩 클래스 개요
### 중첩(Nested) 클래스
- 클래스 내부에 또 다른 클래스를 선언하는 경우
- 설계 관점에서 다른 객체가 필요하지만 이를 캡슐화(혹은 그룹화) 할 목적으로 사용 (존재를 알리지 않는 수준)
#### Static nested class
- 외부 클래스에 속했을 뿐 사실 상 독립적인 다른 클래스
#### Non-static(Inner class)
- Inner class
- local class
- anonymous class
## 정적 중첩 클래스
### 정적 중첩 클래스
- 외부 클래스 private 정적 멤버(클래스 멤버)는 접근 가능
- 외부 클래스 private 인스턴스 멤버는 접근 불가
## 내부 클래스
### 내부(Inner) 클래스
- 외부(Outer) 클래스의 **일부요소로 속하는 클래스**
	- 외부 클래스 내부에 정의
- 내부 클래스는 외부 클래스의 private 멤버에 대해 접근이 허용됨
## 지역 클래스
### 지역 클래스
- 메서드 바디 스코프 내부에 정의하는 클래스
	- 익명 객체를 이해하기 위한 필수 이론
- 메서드 바디 지역변수에 접근 가능
	- final 혹은 유사 final 변수
	- 스택은 객체 인스턴스보다 수명이 길 수 있음
## 내부 인터페이스와 GUI
### 내부 인터페이스
- 클래스 내부에서 interface를 선언하는 경우
- 주로 정적 멤버 인터페이스로 선언하고 활용
	- 이벤트 드라이븐 구조를 갖는 GUI 개발에 자주 등장
	- 마우스 클릭 이벤트 발생 시 이를 처리해야 하기 위한 이벤트 감지(Listener) 코드와 대응(Handler) 코드를 일정형식으로 제한하기 용이 (GUI framework의 보편적 형태)
## 익명 객체를 이용한 GUI 개발
### 익명 객체
	`parent obj = new parent() {}`
- 익명(Anonymous) 객체는 이름이 없는 (지역) 클래스를 의미하며 특정 클래스나 인터페이스의 파생 형식으로 존재
- 클래스로 정의해야 할 필요가 있는 대상이지만 특정 구간에서만 필요할 뿐 재사용 가능성이 없을 때 유욜
- 생성자 없음
- 하나의 구문(;)에 클래스가 포함되는 구조
	- GUI framework에서 이벤트 수신 및 처리 코드르 효율적으로 간소화
## 패키지 선언 및 활용
### 패키지의 선언 및 활용
	`(패키지 선언) package 패키지명.패키지명;`
- 파일 시스템 상의 폴더 형태로 존재
	- 클래스는 파일명
	- 보통 소문자로 명명
- 폴더명이 클래스 이름처럼 식별자이자 소속으로 역할
	- 클래스 소속 필드, 메서드
	- 패키지 소속 클래스
### import
	`import 패키지명.패키지명.클래스명 or *`
- 클래스 혹은 인터페이스가 속한 패키지를 사용하고 싶을 때 이를 **컴파일러에 알릴 목적**으로 기술
- 특정 패키지를 import하더라도 하위에 속한 것까지 모두 자동으로 import되지는 않음
- 각 패키지에 속한 클래스는 이름이 중복될 수 있음
- Intellij 사용 시 대부분 자동으로 추가

****
# 연결 리스트 기반 주소록과 OOP 실습

****
# 예외 처리

****