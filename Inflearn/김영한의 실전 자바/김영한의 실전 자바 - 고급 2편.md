# 강의 소개와 자료

****
# 문자 인코딩
## 프로젝트 환경 구성
## 컴퓨터와 데이터
## 컴퓨터와 문자 인코딩1
### ASCII 문자 집합
- 각 컴퓨터 회사가 독자적인 문자 집합을 사용한다면, 서로 다른 컴퓨터 간에 문자가 올바르게 표시되지 않는 문제가 발생할 수 있다. 이러한 호환성 문제를 해결하기 위해 ASCII(American Standard Code for Information Interchange)라는 표준 문자 집합이 1960년도에 개발되었다.
### ISO_8859_1
- 1980년도
- 기존 ASCII에 서유럽 문자의 추가 필요
- 국제 표준화 기구에서 서유럽 문자를 추가한 새로운 문자 규격을 만듬
- `ISO_8859_1`, `LATIN1`, `ISO-LATIN-1`등으로 불린다.
- 기존 ASCII 문자 집합과 호환 가능
### EUC-KR
- 1980년도
- 초창기 등장한 한글 문자 집합
- 모든 한글을 담는 것 보다는 자주 사용하는 한글 2350개만 포함해서 만들었따.
- 한글의 글자는 아주 많기 때문에 256가지만 표현할 수 있는 1byte로 표현하는 것은 불가능하다.
- 2byte(16bit)를 사용하면 총 65536가지 표현 가능
- ASCII는 1byte, 한글은 2byte를 사용한다
	- 영어를 사용하면 1byte를, 한글을 사용하면 2byte를 메모리에 저장한다.
- 기존 ASCII 문자 집합과 호환 가능
### MS949
- 1990년도
- 마이크로소프트가 EUC-KR을 확장하여 만든 인코딩
- 한글 초성, 중성, 종성 모두 조합하면 가능한 한글의 수는 총 11,172자
- EUC-KR은 '쀍', '삡'과 같이 드물게 사용하는 음절을 표현하지 못함
- 기존 EUC-KR과 호환을 이루면서 한글 11,172자를 모두 수용하도록 만든 것이 MS949
- 윈도우 시스템에서 계속 사용됨
## 컴퓨터와 문자 인코딩2
### 유니코드의 등장
- 전 세계의 모든 문자들을 단일 문자 세트로 표현할 수 있는 유니코드(Unicode) 표준이 1990년대에 도입되었다.
- 하나의 문자 세트에 전 세계 대부분의 언어를 넣어보자! 이름하여 유니코드 -> Uni(Universal) -> 전 세계적인 코드!
- 전 세계의 모든 문자와 기호를 하나의 표준으로 통합하여 표현할 수 있는 문자 집합을 만드는 것
- UTF-16, UTF-8의 시작
- 두 표준이 비슷하게 등장, 초반에는 UTF-16이 인기
#### UTF-16
- 1990년도
- 16bit(2byte) 기반
- 자주 사용하는 기본 다국어들은 2byte로 표현
- 그 외는 4byte로 표현
- 초반에는 UTF-16이 인기, 이 시기에 등장한 자바도 언어 내부적으로 문자를 표현할 때 UTF-16을 사용한다. 그래서 자바의 `char`타입이 2byte를 사용함
##### 단점
- ASCII 영문도 2byte를 사용한다. **ASCII와 호환되지 않음**
- UTF-16을 사용한다면 영문의 경우 다른 문자 집합 보다 2배의 메모리를 더 사용한다.
#### UTF-8
- 1990년도
- 8bit(1byte) 기반, 가변길이 인코딩
- 1byte ~ 4byte를 사용해서 문자를 인코딩
	- 1byte: ASCII, 영문, 기본 라틴 문자
	- 2byte: 그리스어, 히브리어 라틴 확장 문자
	- 3byte: 한글, 한자, 일본어
	- 4byte: 이모지, 고대문자등
- **ASCII 문자는 1바이트로 표현, ASCII 호환**
##### 단점
- 상대적으로 사용이 복잡함
- UTF-16은 대부분의 기본 문자들이 2바이트로 표현되기 때문에, 문자열의 특정 문자에 접근하거나 문자 수르 세는 작업이 상대적으로 간단하다. 반 면 UTF-8은에서는 각 문자가 가변 길이로 인코딩되므로 이런 작업이 더 복잡함.
- ASCII를 제외한 일부 언어에서 더 많은 용량 사용
##### 현대의 사실상 표준 인코딩 기술
- 1990년도 후반 ~ 2000년도 초반에 인터넷과 웹이 빠르게 성장하면서 저변 확대
- 2008년 W3C 웹 표준에 UTF-8 채택
- 현재 대부분의 웹사이트와 애플리케이션에서 기본 인코딩으로 사용
### 정리
**UTF-8이 현대의 사실상 표준 인코딩 기술이 된 이유**
#### 저장 공간 절약과 네트워크 효율성
- 서양 문자에 대해 1바이트를 사용하기 때문에 영문 텍스트에서 효율적
- 데이터를 네트워크로 전달할 때는 매우 큰 효율의 차이르 보인다.
- 웹에 있는 문서의 80% 이상은 영문 문서이다.
#### ASCII와의 호환성
- ASCII와 호환 되면서 전 세계의 모든 문자를 표현할 수 있다.
## 문자 집합 조회
## 문자 인코딩 예제1
### 자바에서의 byte 표현
- 자바의 byte 타입은 양수와 음수를 모두 표현할 수 있다.
- 자바의 byte는 첫 번째 비트(bit)가 0이면 양수, 1이면 음수로 간주된다.
- 결국 자바의 byte는 256가지 값을 표현하지만, 표현 가능한 숫자의 범위는 `-128 ~ 127`이다.
## 문자 인코딩 예제2
### 한글이 깨지는 가장 큰 2가지 이유
#### EUC-KR(MS949), UTF-8이 서로 호환되지 않음
- 한글이 깨지는 대부분의 문제는 UTF-8로 인코딩한 한글을 EUC_KR(MS949)로 디코딩하거나 또는 EUC-KR(MS949)로 인코딩한 한글을 UTF-8로 디코딩할 때 발생한다.
#### EUC-KR(MS949) 또는 UTF-8로 인코딩한 한글을 `ISO-8859-1`로 디코딩 할 때
- EUC-KR(MS949) 또는 UTF-8로 인코딩한 한글을 한글을 지원하지 않는 `ISO-8859-1`로 디코딩 할 때 발생한다.
## 정리

****
# I/O 기본1
## 스트림 시작1
### `read()`가 int를 반환하는 이유
- 참고로 `write()`의 경우도 비슷한 이유로 `int`타입을 입력 받는다.
#### 부호 없는 바이트 표현
- 자바에서 `byte`는 부호 있는 8비트 값(-128 ~ 127)이다.
- `int`로 반환함으로써 0에서 255까지의 모든 가능한 바이트 값을 부호 없이 표현할 수 있다.
#### EOF(End of File) 표시
- byte를 표현하려면 256 종류의 값을 모두 사용해야 한다.
- 자바의 `byte`는 -128에서 127까지 256종류의 값만 가질 수 있어, EOF를 위한 특별한 값을 할당하기 어렵다.
- `int`는 0~255까지 모든 가능한 바이트 값을 표현하고,여기에 추가로 -1을 반환하여 스트림의 끝(EOF)을 나타낼 수 있다.
## 스트림 시작2
### 부분으로 나누어 읽기 vs 전체 읽기
#### `read(byte[], offset, length)`
- 스트림의 내용을 부분적으로 읽거나, 읽은 내용을 처리하면서 스트림을 계속해서 읽어야 할 경우에 적합하다.
- 메모리 사용량을 제어할 수 있다.
- 예시) 파일이나 스트림에서 일정한 크기의 데이터를 반복적으로 읽어야 할 때 유용하다. 예를 들어 대용량 파일을 처리할 때, 한번에 메모리에 로드하기보다는 이 메서드를 사용하여 파일을 조각조각 읽어들일 수 있다.
- 100M의 파일을 1M 단위로 나누어 읽고 처리하는 방식을 사용하면 한 번에 최대 1M의 메모리만 사용한다.
#### `readAllBytes()`
- 한번의 호출로 모든 데이터를 읽을 수 있어 편리하다.
- 작은 파일이나 메모리에 모든 내용을 올려서 처리해야 하는 경우에 적합하다.
- 메모리 사용량을 제어할 수 없다.
- 큰 파일의 경우 OutOfMemoryError가 발생할 수 있다.
## InputStream, OutputStream
### `InputStream`, `OutputStream`의 추상화의 장점
#### 일관성
- 모든 종류의 입출력 작업에 대해 동일한 인터페이스(여기서는 부모의 메서드)를 사용할 수 있어, 코드의 일관성이 유지된다.
#### 유연성
- 실제 데이터 소스나 목적지가 무엇인지에 관계없이 동일한 방식으로 코드를 작성할 수 있다. 예를 들어, 파일, 네트워크, 메모리 등 다양한 소스에 대해 동일한 메서드를 사용할 수 있다.
#### 확장성
- 새로운 유형의 입출력 스트림을 쉽게 추가할 수 있다.
#### 재사용성
- 다양한 스트림 클래스들을 조합하여 복잡한 입출력 작업을 수행할 수 있다. 예를 들어 `BufferedInputStream`을 사용하여 성능을 향상시키거나, `DataInputStream`을 사용하여 기본 데이터 타입을 쉽게 읽을 수 있다.이 부분은 뒤에서 설명한다.
#### 에러 처리
- 표준화된 예외 처리 메커니즘을 통해 일관된 방식으로 오류를 처리할 수 있다.
## 파일 입출력과 성능 최적화1 - 하나씩 쓰기
## 파일 입출력과 성능 최적화2 - 버퍼 활용
### 버퍼의 크기에 따른 쓰기 성능
- 버퍼의 크기가 커진다고 해서 속도가 계속 줄어들지는 않는다. 왜냐하면 디스크나 파일 시스템에서 데이터를 읽고 쓰는 기본 단위가 보통 4KB 또는 8KB이기 때문이다.
- 버퍼의 크기는 보통 4KB, 8KB 정도로 잡는 것이 효율적이다.
## 파일 입출력과 성능 최적화3 - Buffered 스트림 쓰기
### 기본 스트림, 보조 스트림
- `FileOutputStream`과 같이 단독으로 사용할 수 있는 스트림을 기본 스트림이라 한다.
- `BufferedOutputStream`과 같이 단독으로 사용할 수 없고, 보조 기능을 제공하는 스트림을 보조 스트림이라 한다.
## 파일 입출력과 성능 최적화4 - Buffered 스트림 읽기
## 파일 입출력과 성능 최적화5 - 한 번에 쓰기
## 정리
### 정리
- 파일의 크기가 크지 않아서, 메모리 사용에 큰 영향을 주지 않는다면 쉽고 빠르게 한 번에 처리하자.
- 성능이 중요하고 큰 파일을 나누어 처리해야 한다면, 버퍼를 직접 다루자
- 성능이 크게 중요하지 않고, 버퍼 기능이 필요하면 `BufferedXxx`를 사용하자
	- `BufferedXxx`는 동기화 코드가 들어있어서 스레드 안전하지만, 약간의 성능 저하가 있다.

****
# I/O 기본2
## 문자 다루기1 - 시작
## 문자 다루기2 - 스트림을 문자로
### OutputStreamWriter
- 스트림에 byte 대신에 문자를 저장할 수 있게 지원한다.
### InputStreamReader
- 스트림에 byte 대신에 문자를 읽을 수 있게 지원한다.
## 문자 다루기3 - Reader, Writer

자바는 byte를 다루는 I/O 클래스와 문자를 다루는 I/O 클래스를 둘로 나누어 두었다.
**모든 데이터는 byte 단위(숫자)로 저장된다.**
## 문자 다루기4 - BufferedReader
## 기타 스트림
## 정리
### 정리
#### 기본(기반, 메인) 스트림
- File, 메모리, 콘솔등에 직접 접근하는 스트림
- 단독으로 사용할 수 있다.
- 예) `FileInputStream`, `FileOutputStream`, `FileReader`, `FileWriter`, `ByteArrayInputStream`, `ByteArrayOutputStream`
#### 보조 스트림
- 기본 스트림을 도와주는 스트림
- 단독으로 사용할 수 없음,반드시 대상 스트림이 있어야 한다.
- 예) `BufferedInputStream`, `BufferedOutputStream`, `InputStreamReader`, `OutputSTreamWriter`, `DataOutputStream`, `DataInputStream`, `PrintStream`

****
# I/O 활용
## 회원 관리 예제1 - 메모리
## 회원 관리 예제2 - 파일에 보관
## 회원 관리 예제3 - DataStream
### DataStream 원리
- `readUTF()`로 문자를 읽어올 때 어떻게 값을 정확하게 읽어올 수 있는것 일까?
- `writeUTF()`는 UTF-8 형식으로 문자를 저장하는데, 저장할 때 2byte를 추가로 사용해서 앞에 글자의 길이를 저장해둔다. (65535) 길이까지만 사용 가능
- 자바의 `Int(Integer)`는 4byte를 사용하기 때문에 4byte를 사용해서 파일을 저장하고, 읽을 때도 4byte를 읽어서 복원한다.
## 회원 관리 예제4 - ObjectStream
### 객체 직렬화
- 자바 객체 직렬화(Serialization)는 메모리에 있는 객체 인스턴스를 바이트 스트림으로 변환하여 파일에 저장하거나 네트워크를 통해 전송할 수 있도록 하는 기능이다. 이 과정에서 객체의 상태를 유지하여 나중에 역직렬화(Deserialization)를 통해 원래의 객체로 복원할 수 있다.
#### Serializable 인터페이스
- 객체 직렬화를 사용하려면 직렬화하려는 클래스는 반드시 `Serializable`인터페이스를 구현해야 한다.
- 이 인터페이스는 아무런 기능이 없다. 단지 직렬화 가능한 클래스라는 것을 표시하기 위한 인터페이스일 뿐이다.
- 메서드 없이 단지 표시가 목적인 인터페이스를 마커 인터페이스라 한다.
##### `serialVersionUID`
- 객체 직렬화 버전을 관리한다.
##### `transient` 키워드
- `transient`가 붙어있는 필드는 직렬화 하지 않고 무시한다.
## XML, JSON, 데이터베이스
### 객체 직렬화의 한계
#### 객체 직렬화를 사용하지 않는 이유
##### 버전관리의 어려움
- 클래스 구조가 변경되면 이전에 직렬화된 객체와의 호환성 문제가 발생한다.
- serialVersionUID 관리가 복잡하다.
##### 플랫폼 종속성
- 자바 직렬화는 자바 플랫폼에 종속적이어서 다른 언어나 시스템과의 상호 운용성이 떨어진다.
##### 성능 이슈
- 직렬화/역직렬화 과정이 상대적으로 느리고 리소스를 많이 사용한다.
##### 유연성 부족
- 직렬화된 형식을 커스터마이즈하기 어렵다.
##### 크기 효율성
- 직렬화된 데이터의 크기가 상대적으로 크다.
### 직렬화 대안
#### 대안 1 - XML
#### 대안2 - JSON
#### 대안 3 - Protobuf, Avro - 더 적은 용량, 더 빠른 성능
- JSON은 거의 모든곳에서 호환이 가능하고, 사람이 읽고 쓰기 쉬운 텍스트 기반 포맷이어서 디버깅과 개발이 쉽다.
- 만약 매우 작은 용량으로 더 빠른 속도가 필요하다면 Protobuf, Avro 같은 대안 기술이 있다.
- 이런 기술은 호환성은 떨어지지만 byte 기반에, 용량과 성능 최적화가 되어 있으므로 매우 빠르다.
- 다만 byte 기반이므로 JSON처럼 사람이 직접 읽기는 어렵다.
### 정리
- 자바 객체 직렬화는 대부분 사용하지 않는다.
- JSON이 사실상 표준이다. JSON을 먼저 고려하자.
- 성능 최적화가 매우 중요하다면 Protobuf, Avro 같은 기술을 고려하자. (대부분 JSON만 사용해도 충분하다.)
## 정리


****
# File, Files
## File


🍒🍒🍒
🍅🍅
****
# 네트워크 - 기본 이론

****
# 네트워크 - 프로그램1

****
# 네트워크 - 프로그램2

****
# 채팅 프로그램

****
# HTTP - 기본 이론

****
# HTTP 서버 만들기

****
# 리플렉션

****
# 애노테이션

****
# HTTP 서버 활용

****
# 다음으로

****