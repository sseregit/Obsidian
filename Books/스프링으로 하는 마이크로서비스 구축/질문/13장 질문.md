# 1. 서킷 브레이커에는 어떤 상태가 있는가? 각 상태의 용도는 무엇인가?
- Close(닫힘)
	- 정상 작동 상태이다.
	- 모든 요청이 회로 차단기를 통해 전달된다.
- Open(열림)
	- 실패가 너무 많이 감지된 상태이다.
	- 더 이상의 요청은 허용되지 않으며, 회로 차단기는 빠른 실패(fail-fast)로직을 수행한다.
	- 즉, 추가적인 실패(예: 타임 아웃)가 발생하기를 기다리지 않고, 바로 폴백(fallback) 메서드로 요청을 전달한다.
- Half-open(반열림)
	- 회로 차단기가 일부 요청을 허용하여, 문제가 해결되었는지 확인하는 상태이다.
# 2. 서킷 브레이커의 시간 초과 오류는 어떻게 처리해야 하는가?
- Resilience4j의 회로 차단기는 예외(Exception)에 의해 트리거 된다.
- 타임아웃(timeout) 자체는 예외가 아니므로, 별도로 타임아웃이 발생했을 때 예외를 발생시키는 코드가 필요하다.
- 예를 들어, WebClient를 사용할 경우 timeout(Duration) 메서드를 이용해 타임아웃 설정 후, 타임아웃이 발생하면 예외를 던지게 할 수 있다.
# 3. 서킷 브레이커에서 빠른 실패 로직이 실행될 때 폴백 로직을 적용하면 어떻게 해야 하는가?
- 회로 차단기가 열려(Open)있을 때, CircuitBreakerOpenException이 발생한다. 이 예외를 catch해서, 폴백(fallback) 메서드를 호출하면 된다.
# 4. 재시도 메커니즘과 서킷 브레이커는 어떤 경우에 서로 간섭하는가?
- 회로 차단기가 너무 일찍 열리도록 설정되어 있으며, 재시도(Retry) 메커니즘이 모든 재시도 횟수를 소화하기 전에 회로가 열려버릴 수 있다. 이로 인해 재시도 로직이 정상적으로 작동하지 못할 수 있다.
# 5. 재시도 메커니즘을 적용할 수 없는 서비스의 예를 하나 들어라.
- 멱등성이 없는 서비스에는 재시도 메커니즘을 적용할 수 없다.
- 예를 들어 주문 생성 서비스 이 서비스가 재시도 감지를 위한 특별한 로직을 가지고 있지 않다면, 재시도 발생할 때 중복 주문이 생성될 위험이 있다.