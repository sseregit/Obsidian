# 강의 소개와 자료
****
# 제네릭 - Generic1
## 제네릭이 필요한 이유
## 다형성을 통한 중복 해결 시도
## 제네릭 적용
## 제네릭 용어와 관례

### 제네릭의 핵심
- **사용할 타입을 미리 결정하지 않는다는점 이다.**
- 클래스 내부에서 사용하는 타입을 클래스를 정의하는 시점에 결정하는 것이 아니라 실제 사용하는 생성 시점에 타입을 결정하는 것이다.
- 메서드는 **매개변수**에 **인자**를 전달해서 사용할 값을 결정한다.
- 제네릭 클래스는 **타입 매개 변수**에 **타입 인자**를 전달해서 사용할 타입을 결정한다.
### 용어 정리
#### 제네릭(Generic)
#### 제네릭 타입(Generic Type)
#### 타입 매개 변수(Type Parameter)
- `GenericBox<T>`
- `T`를 뜻한다.
#### 타입 인자(Type Argument)
- `GenericBox<Integer>`
- `Integer`를 뜻한다.
### 제네릭 명명 관례
- 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례
#### 주로 사용하는 키워드
- E - Element
- K - Key
- N - Number
- T - Type
- V - Value
- S,U,V etc. - 2nd, 3rd, 4th types

### Row Type
`GenericBox a = new GenericBox()`
- 타입 인자를 지정하지 않은 경우 로 타입 또는 원시 타입이라 한다.
## 제네릭 활용 예제
## 문제와 풀이1
****
# 제네릭 - Generic2
## 타입 매개변수 제한1 - 시작
## 타입 매개변수 제한2 - 다형성 시도
## 타입 매개변수 제한3 - 제네릭 도입과 실패
## 타입 매개변수 제한4 - 타입 매개변수 제한
## 제네릭 메서드
## 제네릭 메서드 활용
## 와일드카드1
### 참고
와일드 카드는 제네릭 타입이나, 제네릭 메서드를 선언하는 것이 아니다. 와일드 카드는 이미 만들어진 제네릭 타입을 활용할 때 사용한다.
### 비제한 와일드 카드
- 와일드 카드는 제네릭 타입이나 제네릭 메서드를 정의할 때 사용하는 것이 아니다.`Box<Dog>`, `Box<Cat>`처럼 타입 인자가 정해진 제네릭 타입을 전달 받아서 활용할 때 사용한다.
- 와일드카드인 `?`는 모든 타입을 다 받을 수 있다는 뜻이다.
	- `? == <? extends Object>`
- `?`만 사용해서 제한 없이 모든 타입을 다 받을 수 있는 와일드카드를 **비제한 와일드카드**라 한다.
### 제네릭 메서드 vs 와일드카드
- 제네릭 타입이나 제네릭 메서드를 정의하는게 꼭 필요한 상황이 아니라면, 더 단순한 와일드카드 사용을 권장한다.
## 와일드카드2
### 상한 와일드카드
- `? extends Animal`
	- Animal 이하
### 하한 와일드카드
- `? super Animal`
	- Animal 이상
- 제네릭 타입, 제네릭 메서드에서는 사용할 수 없다.
### 타입 매개변수가 꼭 필요한 경우
- 와일드카드는 제네릭을 정의할 때 사용하는 것이 아니다. 타입 인자가 전달된 제네릭 타입을 활용할 때 사용한다.
- 제네릭 타입이나 제네릭 메서드가 꼭 필요한 상황이면 `<T>`를 사용하고, 그렇지 않은 상황이면 와일드 카드를 사용하는 것을 권장한다.
```java
Box<T extends Animal> box //로 지정하면 타입 추론에 따라 Animal의 자식들로 사용가능
Box<? extends Animal> box //로 지정하면 무조건 Animal타입으로 사용
```
## 타입 이레이저
### 타입 이레이저
- 제네릭은 자바 컴파일 단계에서만 사용되고, 컴파일 이후에는 제네릭 정보가 삭제된다. 제네릭에 사용한 타입 매개변수가 모두 사라지는 것이다.
#### 한계
- `param instanceof T` and `return new T()` 불가능
## 문제와 풀이2
## 정리
****
# 컬렉션 프레임워크 - ArrayList
## 배열의 특징1 - 배열과 인덱스
### 배열 인덱스 찾기 공식
- `배열의 시작 참조 + (자료의 크기 * 인덱스 위치)`
## 빅오(O) 표기법
### 빅오(Big O) 표기법
- 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식이다.
- 알고리즘이 처리해야 할 데이터의 양이 증가할 때, 그 알고리즘이 얼마나 빠르게 실행되는지 나타낸다.
#### O(1)
- 상수 시간
	- 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정한다.
- 예) 배열의 인덱스를 사용하는 경우
#### O(n)
- 선형 시간
	- 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가한다.
- 예) 배열의 검색, 배열의 모든 요소를 순회하는 경우
#### O(n^2)
- 제곱 시간
	- 알고리즘의 실행 시간이 입력 데이터의 크기의 제곱에 비례하여 증가한다.
- 예) 보통 이중 루프를 사용하는 알고리즘에서 나타난다.
#### O(log n)
- 로그 시간
	- 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
- 예) 이진 탐색
#### O(n log n)
- 선형 로그 시간
- 예) 많은 효율적인 정렬 알고리즘들
## 배열의 특징2 - 데이터 추가
## 직접 구현하는 배열 리스트1 - 시작
## 직접 구현하는 배열 리스트2 - 동적 배열
## 직접 구현하는 배열 리스트3 - 기능 추가
## 직접 구현하는 배열 리스트4 - 제네릭1
## 직접 구현하는 배열 리스트4 - 제네릭2
****
# 컬렉션 프레임워크 - LinkedList
## 노드와 연결1
## 노드와 연결2
## 노드와 연결3
## 직접 구현하는 연결 리스트1 - 시작
## 직접 구현하는 연결 리스트2 - 추가와 삭제1
## 직접 구현하는 연결 리스트3 - 추가와 삭제2

### 배열리스트 vs 연결 리스트 사용
- 데이터를 조회할 일이 많고, 뒷 부분에 데이터를 추가한다면 배열리스트가 보통 더 좋은 성능을 제공한다.
- 앞쪽의 데이터를 추가하거나 삭제할 일이 많다면 연결 리스트를 사용하는 것이 보통 더 좋은 성능을 제공한다.
## 직접 구현하는 연결 리스트4 - 제네릭 도입
****
# 컬렉션 프레임워크 - List
## 리스트 추상화1 - 인터페이스 도입
### List 자료 구조
- 순서가 있고, 중복을 허용하는 자료 구조
## 리스트 추상화2 - 의존관계 주입
## 리스트 추상화3 - 컴파일 타임, 런타임 의존관계
### 컴파일 타임 의존관계
#### 컴파일 타임(compile time)
- 코드 컴파일 시점을 뜻한다.
#### 의존관계
- 자바 컴파일러가 보는 의존관계이다. 클래스에 모든 의존관계가 다 나타난다.
### 런타임 의존관계
#### 런타임(runtime)
- 프로그램 실행 시점을 뜻한다.
#### 의존관계
- 실제 프로그램이 작동할 때 보이는 의존관계다. 주로 생성된 인스턴스와 그것을 참조하는 의존관계이다.
## 직접 구현한 리스트의 성능 비교
### 시간 복잡도와 실제 성능
- 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받는다.
- 배열은 메모리상 에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.
- LinkedList는 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느릴 수 있다.
### 배열 리스트 vs 연결 리스트
- 대부분의 경우 배열 리스트가 성능상 유리하다. 이런 이유로 실무에서는 주로 배열 리스트를 기본으로 사용한다.
- 만약 데이터를 앞쪽에서 자주 추가하거나 삭제할 일이 있다면 연결 리스트를 고려하자.
## 자바 리스트
### 자바 ArrayList
#### 특징
- 배열을 사용해서 데이터를 관리한다.
- 기본 `CAPACITY`는 10이다.
	- `CAPACITY`를 넘어가면 배열을 50% 증가한다.
- 메모리 고속 복사 연산을 사용한다.
	- 배열의 요소 이동은 시스템 레벨에서 최적화된 메모리 고속 복사 연산을 사용해서 비교적 빠르게 수행된다. `System.arraycopy()`사용
### 자바 LinkedList
#### 특징
- 이중 연결 리스트 구조
- 첫 번째 노드와 마지막 노드 둘다 참조
## 자바 리스트의 성능 비교
## 문제와 풀이1
## 문제와 풀이2
****
# 컬렉션 프레임워크 - 해시(Hash)
## 리스트(List) vs 세트(Set)
### 리스트(List)
#### 정의
- 리스트는 요소들의 순차적인 컬렉션이다. 요소들은 특정 순서를 가지며, 같은 요소가 여러 번 나타날 수 있다.
#### 특징
##### 순서 유지
- 리스트에 추가된 요소는 특정한 순서를 유지한다. 이 순서는 요소가 추가된 순서를 반영할 수 있다.
##### 중복 허용
- 리스트는 동일한 값이나 객체의 중복을 허용한다. 예를 들어, 같은 숫자나 문자열을 리스트 안에 여러 번 저장할 수 있다.
##### 인덱스 접근
- 리스트의 각 요소는 인덱스를 통해 접근할 수 있다. 이 인덱스는 보통 0부터 시작한다.
#### 용도
- 순서가 중요하거나 중복된 요소를 허용해야 하는 경우에 주로 사용된다.
### Set(세트, 셋)
#### 정의
- 세트(셋)는 유일한 요소들의 컬렉션이다. 참고로 세트보다는 셋으로 많이 불린다.
#### 특징
##### 유일성
- 셋에는 중복된 요소가 존재하지 않는다. 셋에 요소를 추가할 때, 이미 존재하는 요소면 무시된다.
##### 순서 미보장
- 대부분의 셋 구현에서는 요소들의 순서를 보장하지 않는다. 즉 요소를 출력할 때 입력 순서와 다를 수 있다.
##### 빠른 검색
- 셋은 요소의 유무를 빠르게 확인할 수 있또록 최적화되어 있다.이는 데이터의 중복을 방지하고 빠른 조회를 가능하게 한다.
#### 용도
- 중복을 허용하지 않고, 요소의 유무만 중요한 경우에 사용된다.
## 직접 구현하는 Set0 - 시작
## 해시 알고리즘1 - 시작
## 해시 알고리즘2 - index 사용
## 해시 알고리즘3 - 메모리 낭비
## 해시 알고리즘4 - 나머지 연산
### 해시 인덱스
- 배열의 인덱스로 사용할 수 있도록 원래의 값을 계산한 인덱스를 해시 인덱스(hashIndexl)라 한다.
## 해시 알고리즘5 - 해시 충돌 설명
## 해시 알고리즘6 - 해시 충돌 구현
****
# 컬렉션 프레임워크 - HashSet
## 직접 구현하는 Set1 - MyHashSetV1
## 문자열 해시 코드
### 용어 정리
#### 해시 함수(Hash Function)
- 임의의 길이의 데이터를 입력으로 받아,고정된 길이의 해시값(해시 코드)을 출력하는 함수이다.
	- 여기서 의미하는 고정된 길이는 저장 공간의 크기를 뜻한다.
		- 예를 들어 `int`형 `1`,`100`은 둘다 4byte를 차지하는 고정된 길이는 뜻한다.
- 같은 데이터를 입력하면 항상 같은 해시코드가 출력된다.
- 다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다. 이것을 해시 충돌이라 한다.
#### 해시 코드(Hash Code)
- 데이터를 대표하는 값을 뜻한다. 보통 해시 함수를 통해 만들어진다.
#### 해시 인덱스(Hash Index)
- 데이터의 저장 위치를 결정하는데, 주로 해시 코드를 사용해서 만든다.
- 보통 해시 코드의 결과에 배열의 크기를 나누어 구한다.
## 자바의 hashCode()
****
# 컬렉션 프레임워크 - Set

****
# 컬렉션 프레임워크 - Map, Stack, Queue

****
# 컬렉션 프레임워크 - 순회, 정렬, 전체 정리

****
# 다음으로

****