# 강의 소개와 자료

****
# 프로세스와 스레드 소개
## 멀티태스킹과 멀티프로세싱
### 시분할(Time Sharing, 시간 공유) 기법
- 각 프로그램의 실행 시간을 분할해서 마치 동시에 실행되는 것 처럼하는 기법
### 멀티태스킹(Multitasking)
- 하나의 컴퓨터 시스템이 동시에 여러 작업을 수행하는 능력
### 스케줄링(Scheduling)
- CPU에 어떤 프로그램이 얼마만큼 실행될지는 운영체제가 결정한다.
### 멀티프로세싱(Multiprocessing)
- 컴퓨터 시스템에서 둘 이상의 프로세서(CPU 코어)를 사용하여 여러 작업을 동시에 처리하는 기술
### 멀티프로세싱 vs 멀티태스킹
- 멀티프로세싱은 하드웨어 장비의 관점
- 멀티태스킹은 운영체제 소프트웨어의 관점
#### 멀티프로세싱
- 여러 CPU(여러 CPU 코어)를 사용하여 동시에 여러 작업을 수행하는 것을 의미한다.
- 하드웨어 기반으로 성능을 향상시킨다.
#### 멀티태스킹
- 단일 CPU(단일 CPU 코어)가 여러 작업을 동시에 수행하는 것처럼 보이게 하는 것을 의미한다.
- 소프트웨어 기반으로 CPU 시간을 분할하여 각 작업에 할당한다.
## 프로세스와 스레드
### 프로세스
- 프로그램은 실제 실행하기 전까지는 단순한 파일에 불과하다.
- 프로그램을 실행하면 프로세스가 만들어지고 프로그램이 실행된다.
- 이렇게 운영체제 안에서 **실행중인 프로그램을 프로세스**라 한다.
- 프로세스는 실행 중인 프로그램의 **인스턴스**이다.
#### 프로세스의 메모리 구성
##### 코드 섹션
- 실행할 프로그램의 코드가 저장되는 부분
##### 데이터 섹션
- 전역 변수 및 정적 변수가 저장되는 부분
##### 힙 (Heap)
- 동적으로 할당되는 메모리 영역
##### 스택 (Stack)
- 메서드(함수) 호출 시 생성되는 지역 변수와 반환 주소가 저장되는 영역(스레드에 포함)
### 스레드 (Thread)
- **프로세스는 하나 이상의 스레드를 반드시 포함한다.**
#### 스레드의 메모리 구성
##### 공유 메모리
- 같은 프로세스의 코드 섹션, 데이터 섹션, 힙(메모리)은 프로세스 안의 모든 스레드가 공유한다.
##### 개별 스택
- 각 스레드는 자신의 스택을 갖고 있다.
### 멀티스레드
- 한 프로세스 내에 여러 스레드가 존재
#### 필요한 이유
- 하나의 프로그램도 그 안에서 동시에 여러 작업이 필요하다.
## 스레드와 스케줄링
## 컨텍스트 스위칭
### 스레드가 하는 작업 2가지
#### CPU-바운드 작업(CPU-bound tasks)
- CPU의 연산 능력을 많이 요구하는 작업을 의미한다.
- 이러한 작업은 주로 계산, 데이터처리, 알고리즘 실행 등 CPU의 처리 속도가 작업 완료 시간을 결정하는 경우다.
##### 설정
- CPU 코어 수 + 1개
- CPU를 거의 100% 사용하는 작업이므로 스레드를 CPU 숫자에 최적화
#### I/O-바운드 작업(I/O-bound tasks)
- 디스크, 네트워크, 파일 시스템 등과 같은 입출력(I/O) 작업을 많이 요구하는 작업을 의미한다.
- 이러한 작업은 I/O 작업이 완료될 때까지 대기 시간이 많이 발생하며, CPU는 상대적으로 유휴(대기) 상태에 있는 경우가 많다, 쉽게 이야기해서 스레드가 CPU를 사용하지 않고 I/O 작업이 완료될 때 까지 대기한다.
##### 설정
- CPU 코어 수 보다 많은 스레드를 생성, CPU를 최대한 사용할 수 있는 숫자까지 스레드 생성
- CPU를 많이 사용하지 않으므로 성능 테스트를 통해 CPU를 최대한 활용하는 숫자까지 스레드 생성
- 단 너무 많은 스레드를 생성하면 컨텍스트 스위칭 비용도 함께 증가 - 적절한 성능 테스트 필요

****
# 스레드 생성과 실행
## 프로젝트 환경 구성
## 스레드 시작1
### 자바 메모리 구조
#### 메서드 영역(Method Area)
- 프로그램을 실행하는데 필요한 공통 데이터를 관리한다. 이 영역은 프로그램의 모든 영역에서 공유한다.
##### 클래스 정보
- 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드등 모든 실행 코드가 존재한다.
##### static 영역
- `static` 변수들을 보관한다.
##### 런타임 상수 풀
- 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관한다.
#### 스택 영역(Stack Area)
- 잡 실행 시, 하나의 실행 스택이 생성된다. 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보등을 포함한다.
##### 스택 프레임
- 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임이다. 메서드를 호출할 때 마다 한의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거된다.
#### 힙 영역(Heap Area)
- 객체(인스턴스)와 배열이 생성되는 영역이다. 가비지 컬렉션(GC)이 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.
## 스레드 시작2
## 데몬 스레드
### 사용자 스레드(non-daemon 스레드)
- 프로그램의 주요 작업을 수행한다.
- 작업이 완료될 때까지 실행된다.
- 모든 user 스레드가 종료되면 JVM도 종료된다.
### 데몬 스레드
- 백그라운에서 보조적인 작업을 수행한다.
- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.
## 스레드 생성 - Runnable
### Thread 상속 vs Runnable 구현
- 스레드 사용할 때는 `Thread`를 상속 받는 방법보다 `Runnable` 인터페이스를 구현하는 방식을 사용하자
#### Thread 클래스 상속 방식
##### 장점
- 간단한 구현
	- `Thread` 클래스를 상속받아 `run()` 메서드만 재정의하면 된다.
##### 단점
- 상속의 제한
	- 자바는 단일 상속만을 허용하므로 이미 다른 클래스를 상속받고 있는 경우 `Thread` 클래스를 상속받을 수 없다.
- 유연성 부족
	- 인터페이스를 사용하는 방법에 비해 유연성이 떨어진다.
#### Runnable 인터페이스를 구현 방식
##### 장점
- 상속의 자유로움
	- `Runnable` 인터페이스 방식은 다른 클래스를 상속받아도 문제없이 구현할 수 있다.
- 코드의 분리
	- 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
- 여러 스레드가 동일한 `Runnable` 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.
##### 단점
- 코드가 약간 복잡해질 수 있다. `Runnable` 객체를 생성하고 이를 `Thread`에 전달하는 과정이 추가된다.
## 로거 만들기
## 여러 스레드 만들기
## Runnable을 만드는 다양한 방법
## 문제와 풀이
## 정리

****
# 스레드 제어와 생명 주기1
## 스레드 기본 정보
### `log("myThread.getState() = " + myThread.getState());`
#### getState()
- 스레드의 현재 상태를 반환하는 메서드이다. 반환되는 값은 `Thread.State` 열거형에 정의된 상수 중 하나이다.
##### NEW
- 스레드가 아직 시작되지 않은 상태이다.
##### RUNNABLE
- 스레드가 실행 중이거나 실행될 준비가 된 상태이다.
##### BLOCKED
- 스레드가 동기화 락을 기다리는 상태이다.
##### WAITING
- 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태이다.
##### TIMED_WAITING
- 일정 시간 동안 기다리는 상태이다.
##### TERMINATED
- 스레드가 실행을 마친 상태이다.
## 스레드의 생명 주기 - 설명
### 스레드 상태
#### New (새로운 상태)
- 스레드가 생성되었으나 아직 시작되지 않은 상태.
- `start()`메서드가 호출되지 않은 상태
#### Runnable (실행 가능 상태)
- 스레드가 실행 중이거나 실행될 준비가 된 상태.
- `start()`메서드가 호출되면 스레드는 이 상태로 들어간다.
#### Blocked (차단 상태)
- 스레드가 동기화 락을 기다리는 상태.
#### Waiting (대기 상태)
- 스레드가 무기한으로 다른 스레드의 작업을 기다리는 상태.
#### Timed Waiting (시간 제한 대기 상태)
- 스레드가 일정 시간 동안 다른 스레드의 작업을 기다리는 상태
- `sleep(long millis)`, `wait(long timeout)`, `join(long millis)` 메서드가 호출될 때 이 상태가 된다.
#### Terminated (종료 상태)
- 스레드의 실행이 완료된 상태.
## 스레드의 생명 주기 - 코드
## 체크 예외 재정의
### 체크 예외
- 부모 메서드가 체크 예외를 건지지 않는 경우, 재정의된 자식 메서드도 체크 예외를 던질 수 없다.
- 자식 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.
#### 체크 예외 재정의 규칙
- 자식 클래스에 재정의된 메서드는 원래 메서드가 던질 수 있는 체크 예외의 하위 타입만을 던질 수 있다.
- 원래 메서드가 체크 예외를 던지지 않는 경우, 재정의된 메서드도 체크 예외를 던질 수 없다.
### 언체크(런타임) 예외
- 예외 처리를 강제하지 않으므로 상관없이 던질 수 있다.
## join - 시작
## join - 필요한 상황
## join - sleep 사용
## join - join 사용
## join - 특정 시간 만큼만 대기
## 문제와 풀이

****
# 스레드 제어와 생명 주기2
## 인터럽트 - 시작1
## 인터럽트 - 시작2
## 인터럽트 - 시작3
### 인터럽트 상태를 다시 정상으로 돌리는 이유
- 자바에서 인터럽트 예외가 한번 발생하면, 스레드의 인터럽트 상태를 다시 정상(`false`)로 돌리는 것은 이런 이유때문이다.스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다.
- **인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.**
## 인터럽트 - 시작4
### `Thread.interrupted()`
- 스레드의 인터럽트 상태를 단순히 확인만 하는 용도라면 `isInterrupted()`를 사용한다.
- 직접 체크해서 사용할 때는 `Thread.interrupted()`를 사용해야 한다.
- 스레드가 인터럽트 상태라면 `true`를 반환하고, 해당 스레드의 인터럽트 상태를 `false`로 변경한다.
- 스레드가 인터럽트 상태가 아니라면 `false`를 반환하고, 해당 스레드의 인터럽트 상태를 변경하지 않는다.
## 프린터 예제1 - 시작
## 프린터 예제2 - 인터럽트 도입
## 프린터 예제3 - 인터럽트 코드 개선
## yield - 양보하기
### `yield()의 작동`
- `Thread.yield()` 메서드는 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다.
- `yield()` 메서드를 호출한 스레드는 `RUNNABLE`상태를 유지하면서 CPU를 양보한다. 즉, 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘긴다.
## 프린터 예제4 - yield 도입
## 정리

****
# 메모리 가시성
## volatile, 메모리 가시성1
## volatile, 메모리 가시성2
### 메모리 가시성(memory visibility)
- 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제
## volatile, 메모리 가시성3
### `volatile`
- 여러 스레드에서 같은 값을 읽고 써야 한다면 `volatile`키워드를 사용하면 된다.
- 단 캐시 메모리를 사용할 때 보다 성능이 느려지는 단점이 있기 때문에 꼭! 필요한 곳에만 사용하는 것이 좋다.
## volatile, 메모리 가시성4
## 자바 메모리 모델(Java Memory Model)
### Java Memory Model
- 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며, 특히 멀티스레드 프로그래밍에서 스레드 간의 상호작용을 정의한다. JMM에 여러가지 내용이 있지만, 핵심은 여러 스레드들의 작업 순서를 보장하는 happens-before 관계에 대한 정의다.
### happens-before
- 자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념이다.
- 만약 A 작업이 B 작업보다 happens-before관계에 있다면, A 작업에서의 모든 메모리 변경 사항은 B 작업에서 볼 수 있다. 즉 A 작업에서 변경된 내용은 B 작업이 시작 되기 전에 모두 메모리에 반영 된다.
- 이름 그대로, 한 동작이 다른 동작보다 먼저 발생함을 보장한다.
- 스레드 간의 메모리 가시성을 보장하는 규칙이다.
- 관계가 성립하면, 한 스레드의 작업을 다른 스레드에서 볼 수 있게 된다.
- 한 스레드에서 수행한 작업을 다른 스레드가 참조할 때 최신 상태가 보장되는 것이다.
#### 발생하는 경우
##### 프로그램 순서 규칙
- 단일 스레드 내에서, 프로그램의 순서대로 작성된 모든 명령문은 happens-before 순서로 실행된다.
##### volatile 변수 규칙
- 한 스레드에서 `volatile` 변수에 대한 쓰기 작업은 해당 변수를 읽는 모든 스레드에 보이도록 한다.
- 즉, `volatile`변수에 대한 쓰기 작업은 그 변수를 읽는 작업보다 happens-before 관계를 형성한다.
##### 스레드 시작 규칙
- 한 스레드에서 `Thread.start()`를 호출하면, 해당 스레드 내의 모든 작업은 `start()`호출 이후에 실행된 작업보다 happens-before 관계까 성립한다.
##### 스레드 종료 규칙
- 한 스레드에서 `Thread.join()`을 호출하면 join 대상 스레드의 모든 작업은 `join()`이 반환된 후의 작업보다 happens-before 관계를 가진다.
##### 인터럽트 규칙
- 한 스레드에서 `Thread.interrupt()`를 호출하는 작업이, 인터럽트된 스레드가 인터럽트를 감지하는 시점의 작업보다 happens-before 관계가 성립한다.
- 즉, `interrupt()` 호출 후, 해당 스레드의 인터럽트 상태를 확인하는 작업이 happens-before 관계에 있다.
##### 객체 생성 규칙
- 객체가 완전히 생성된 후에만 다른 스레드에 의해 참조될 수 있도록 보장한다.
##### 모니터 락 규칙
- 한 스레드에서 `synchronized`블록을 종료한 후, 그 모니터 락을 얻는 모든 스레드는 해당 블록 내의 모든 작업을 볼 수 있다.
##### 전이 규칙(Transitivity Rule)
- 만약 A가 B보다 happens-before 관계에 있고, B가 C보다 happens-before 관계에 있다면, A는 C보다 happens-before 관계에 있다.
## 정리

****
# 동기화 - synchronized
## 출금 예제 - 시작
### 멀티스레드 사용시 가장 주의해야 할점
- 같은 자원(리소스)에 여러 스레드가 동시에 접근할 때 발생하는 동시성 문제
#### 공유 자원
- 여러 스레드가 접근하는 자원
- 대표적인 공유 자원은 인스턴스의 필드(멤버 변수)이다.
## 동시성 문제
## 임계 영역
### 임계 영역(critical section)
- 여러 스레드가 동시에 접근하면 데이터 불일치나 예상치 못한 동작이 발생할 수 있는 위험하고 또 중요한 코드 부분을 뜻한다.
- 여러 스레드가 동시에 접근해서는 안 되는 공유 자원을 접근하거나 수정하는 부분을 의미한다.
## synchronized 메서드
### synchronized
- 모든 객체(인스턴스)는 내부에 자신만의 락(lock)을 가지고 있다.
	- 모니터 락(monitor lock)이라고도 부른다.
	- 객체 내부에 있고 확인하기는 어렵다.
- 스레드가 `synchronized` 키워드가 있는 메서드에 진입하려면 반드시 해당 인스턴스 락이 있어야 한다.
- 스레드가 락을 획득을 시도하고 락이 없다면 `RUNNABLE` -> `BLOCKED`상태로 변하고, `BLOCKED`상태는 락을 다시 획득하기 전까지는 계속 대기하고, CPU 실행 스케줄러에 들어가지 않는다.

**락을 획득하는 순서는 보장되지 않는다.**
## synchronized 코드 블럭
- 하나의 스레드만 실행할 수 있는 안전한 임계영역은 가능한 최소한의 범위에 적용해야 한다는점이다. 그래야 동시에 여러 스레드가 실행할 수 있는 부분을 늘려서, 전체적인 처리 성능을 더 높일 수 있다.
## 문제와 풀이
## 정리
### synchronized
#### 장점
- 프로그래밍 언어에 문법으로 제공
- 아주 편리한 사용
- **자동 잠금 해제**
	- `synchronized` 메서드나 블록이 완료되면 자동으로 락을 대기중인 다른 스레드의 잠금이 해제된다. 개발자가 직접 특정 스레드를 깨우도록 관리해야 한다면, 매우 어렵고 번거로울 것이다.
#### 단점
- **무한 대기**
	- `BLOCKED`상태의 스레드는 락이 풀릴 때 까지 무한 대기한다.
	- 특정 시간까지만 대기하는 타임아웃 불가능
	- 중간에 인터럽트 불가능
- **공정성**
	- 락이 돌아왔을 때 `BLOCKED`상태의 여러 스레드 중에 어떤 스레드가 락을 획득할 지 알 수 없다. 최악의 경우 특정 스레드가 너무 오랜기간 락을 획득하지 못할 수 있다.

****
# 고급 동기화 - concurrent.Lock
## LockSupport1
## LockSupport2
### BLOCKED vs WAITING
- `BLOCKED`상태는 `synchronized`에서만 사용하는 특별한 대기 상태
- `WAITING`, `TIMED_WAITING`상태는 범용적으로 활용할 수 있는 대기 상태
#### 인터럽트
- `BLOCKED`상태는 인터럽트가 걸려도 대기 상태를 빠져나오지 못한다. 여전히 `BLOCKED` 상태이다.
- `WAITING`, `TIMED_WAITING`상태는 인터럽트가 걸리면 대기 상태를 빠져나온다. 그래서 `RUNNABLE` 상태로 변한다.
#### 용도
- `BLOCKED` 상태는 자바의 `synchronized`에서 락을 획득하기 위해 대기할 때 사용된다.
- `WAITING`, `TIMED_WAITING`상태는 스레드가 특정 조건이나 시간 동안 대기할 때 발생하는 상태이다.
- `WAITING`상태는 다양한 상황에서 사용된다. 예를 들어 `Thread.join()`, `LockSupport.park()`, `Object.wait()`
- `TIMED_WAITING`상태는 `Thread.sleep(ms)`, `Object.wait(long timeout)`, `Thread.join(long millis)`, `LockSupport.parkNanos(ns)`
#### 대기(`WAITING`)상태와 시간 대기 상태(`TIMED_WAITING`)는 서로 짝이 있다.
- `Thread.join()`, `Thread.join(long millis)`
- `LockSupport.park()`, `LockSupport.park(long millis)`
- `Object.wait()`, `Object.wait(long timeout)`
## ReentrantLock - 이론
### 비공정 모드(Non-fair mode)
- `ReentrantLock`의 기본 모드
- 이 모드에서는 락을 먼저 요청한 스레드가 락을 먼저 획득한다는 보장이 없다.
#### 특징
- 성능 우선
	- 락을 획득하는 속도가 빠르다
- 선점 기능
	- 새로운 스레드가 기존 대기 스레드보다 먼저 락을 획득할 수 있다
- 기아 현상 가능성
	- 특정 스레드가 계속해서 락을 획득하지 못할 수 있다.
### 공정 모드(Fair mode)
- `new ReentrantLock(true)`
- 이 모드는 락을 요청한 순서대로 스레드가 락을 획득할 수 있게 한다. 이는 먼저 대기한 스레드가 먼저 락을 획득하게 되어 스레드 간의 공정성을 보장한다. 그러나 이로 인해 성능이 저하될 수 있다.
#### 특징
- 공정성 보장
	- 대기 큐에서 먼저 대기한 스레드가 락을 먼저 획득한다.
- 기아 현상 방지
	- 모든 스레드가 언젠가 락을 획득할 수 있게 보장된다.
- 성능 저하
	- 락을 획득하는 속도가 느려질 수 있다.
## ReentrantLock - 활용
## ReentrantLock - 대기 중단
## 정리

****
# 생산자 소비자 문제1
## 생산자 소비자 문제 - 소개
### 기본 개념
#### 생산자(Producer)
- 데이터를 생성하는 역할을 한다.
#### 소비자(Consumer)
- 생성된 데이터를 사용하는 역할을 한다.
#### 버퍼(Buffer)
- 생산자가 생성한 데이터를 일시적으로 저장하는 공간이다
#### 생산자 소비자 문제 == 한정된 버퍼 문제
##### 생산자 소비자 문제(producer-consumer problem)
- 생산자 스레드와 소비자 스레드 특정 자원을 함께 생산하고, 소비하면서 발생하는 문제
##### 한정된 버퍼 문제(bounded-buffer problem)
- 결국 중간에 있는 버퍼의 크기가 한정되어 있기 때문에 발생한다.
## 생산자 소비자 문제 - 예제1 코드
## 생산자 소비자 문제 - 예제1 분석 - 생산자 우선
## 생산자 소비자 문제 - 예제1 분석 - 소비자 우선
## 생산자 소비자 문제 - 예제2 코드
## 생산자 소비자 문제 - 예제2 분석
## Object - wait, notify - 예제3 코드
### `Object.wait()`
- 현재 스레드가 가진 락을 반납하고 대기(`WAITING`)한다.
- 현재 스레드를 대기(`WAITING`)상태로 전환한다. 이 메서드는 현재 스레드가 `synchronized`블록이나 메서드에서 락을 소유하고 있을 때만 호출할 수 있다.
- 호출한 스레드는 락을 반납하고, 다른 스레드가 해당 락을 획득할 수 있도록 한다.
### `Object.notify()`
- 대기 중인 스레드 중 하나를 깨운다.
- 이 메서드는 `synchronized`블록이나 메서드에서 호출되어야 한다.
- 깨운 스레드는 락을 다시 획득할 기회를 얻는다. 만약 여러 개라면, 그 중 하나만이 깨워지게 된다.
### `Object.notifyAll()`
- 대기 중인 모든 스레드를 깨운다
- 이 메서드는 `synchronized`블록이나 메서드에서 호출되어야 한다.
- 모든 스레드를 깨워야 할 필요가 있는 경우에 유용하다.
## Object - wait, notify - 예제3 분석 - 생산자 우선
### 스레드 대기 집합(wait set)
- `synchronized`임계 영역 안에서 `Object.wait()`를 호출하면 스레드는 대기(`WAITING`) 상태에 들어간다. 이렇게 대기 상태에 들어간 스레드를 관리하는 것을 대기 집합(wait set)이라고 한다. 참고로 모든 객체는 각자의 대기 집합을 가지고 있다.
## Object - wait, notify - 예제3 분석 - 소비자 우선
## Object - wait, notify - 한계
### 스레드 기아(thread starvation)
- 어떤 스레드가 깨어날지 알 수 없기 때문에 발생할 수 있다.
- `notifyAll()`을 사용해서 스레드 기아 문제는 막을 수 있지만, 비효율은 막지는 못한다.
## 정리

****
# 생산자 소비자 문제2
## Lock Condition - 예제4
### `Condition`
- `ReentrantLock`을 사용하는 스레드가 대기하는 스레드 대기 공간
- `lock.newCondition()` 메서드를 호출하면 스레드 대기 공간이 만들어진다.
#### `condition.await()`
- `Object.wait()`와 유사한 기능이다.
- 지정한 `condition`에 현재 스레드를 대기(`WAITING`) 상태로 보관한다. 이때 `ReentrantLock`에서 획득한 락을 반납하고 대기 상태로 `condition`에 보관된다.
#### `condition.signal()`
- `Object.notify()`와 유사한 기능이다.
- 지정한 `condition`에서 대기중인 스레드를 하나 깨운다. 깨어난 스레드는 `condition`에서 빠져나온다.
## 생산자 소비자 대기 공간 분리 - 예제5 코드


🍅🍅
****
# CAS - 동기화와 원자적 연산

****
# 동시성 컬렉션

****
# 스레드 풀과 Executor 프레임워크1

****
# 스레드 풀과 Executor 프레임워크2

****
# 다음으로

****