# 섹션 1. 이펙티브 자바 완벽 공략 3
## 강의 소개

****
# 섹션 2. 아이템 34. int 상수 대신 열거 타입을 사용하라.
## 아이템 34. 핵심 정리 1: 정수 열거 패턴의 단점
### 핵심 정리 1: 정수 열거 패턴의 단점
#### 정수 열거 패턴
- 자바에서 열거 타입을 지원하기 이전에는 "정수 상수"를 선언하여 열거 타입을 표현했다.
##### 단점
- **타입 안전**을 보장할 수 없다.
- 표현력이 좋치 않다.
- 프로그램이 깨지기 쉽다.
- 문자열로 출력하기 까다롭다.
- 모든 상수를 순회하는 방법도 마땅치 않다.
## 아이템 34. 핵심 정리 2: 열거 타입의 장점 1   
### 핵심 정리 2: 열거 타입(enum)의 장점
- 열거 타입 선언으로 만들어진 인스턴스는 싱글턴이다.
- 컴파일타임 **타입 안정성**을 제공한다.
- 열거 타입에 이름 공간을 있으니 (공간이 다른) 이름이 같은 상수도 공존할 수 있다.
- 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일 하지 않아도 된다.
- `toString`메서드는 출력하기 적절한 문자열을 제공한다.
## 아이템 34. 핵심 정리 3: 열거 타입의 장점 2
### 핵심 정리 3: 열거 타입(enum)의 장점
- 메서드나 필드를 추가하고 인터페이스를 구현할 수도 있다.
- `values`메서드를 사용해 정의되어 있는 모든 상수 배열을 사용할 수 있다.
- 열거 타입에서 상수를 제거한다면?
- 상수마다 동적이 달라져야 한다면?
- `valueOf(String)`메서드를 사용해 문자열을 열거 타입 상수로 변환할 수 있다.
- `fromString(String)`구현하기
## 아이템 34. 핵심 정리 4: 예제 살펴보기
## 아이템 34. 핵심 정리 5: 열거 타입의 제약
### 핵심 정리 4: 열거 타입(enum)의 제약
- 생성자에서 접근할 수 있는 것은 상수 변수 뿐이다.
	- 다른 상수에도 접근할 수 없다.
	- enum에서는 생성자가 호출되는 시점에는 정적인 필드들이 초기화 되지 않은 상태이다.
- 열거 타입 상수끼리 코드를 공유하기 어렵다.
	- 예) `PayrollDay`
- 코드를 수정 할 수 없는 기존 열거 타입에 상수별 동작을 넣을 때는 `switch`문이 좋은 선택이 될 수 있다.
	- 예) `Inverse`

****
# 섹션 3. 아이템 35. ordinal 메서드 대신 인스턴스 필드를 사용하라.
## 아이템 35. 핵심 정리
### 핵심 정리
- `Enum`은 상수가 정의되어 있는 위치를 반환하는 `ordinal`이라는 메서드를 제공한다.
- 프로그래머가 직접 사용할 용도로 만들어진 메서드가 아니다.
- `Enum`에 정의하는 상수들의 순서가 바뀔 수 있고, 상수를 삭제하거나, 추가할 수도 있다는 것을 주의해야 한다.
- 필드와 메서드를 정의하는 것이 좋다.
- `ordinal`은 `EnumSet`과 `EnumMap`등 자바 내부에서 사용할 용도로 만들어진 것이다.

****
# 섹션 4. 아이템 36. 비트 필드 대신 EnumSet을 사용하라.
## 아이템 36. 핵심 정리

|               비트 필드               |             (권장) `EnumSet`             |
| :-------------------------------: | :------------------------------------: |
|     정수 열거 상수의 단점을 모두 가지고 있다.      |    비트를 직접 다룰 때 겪을 수 있는 오류들에서 해방된다.     |
| 비트 필드 값을 그대로 출력할 경우 해석하기가 훨씬 어렵다. | `Set`인터페이스의 구현체로 상수 값 집합을 효과적으로 표현해준다. |
|     최대 몇 비트가 필요한지 미리 정해야 한다.      |      비트 백터로 구현되어 있어 연산 작업이 효율적이다.      |
|            연산이 효율적이다.             |                                        |
## 아이템 36 완벽 공략48. bit array와 비트 연산자
### bit array와 비트 연산자
- **bit vector, bitmask, bitmap, bit set, bit string**
- 비트 (0 또는 1) 구성된 배열. 예) 01011011,
- 비트 연산을 활용해 복잡한 로직을 효율적으로 계산할 수 있음
#### 비트 연산
- `OR`
	- 둘 중에 하나라도 1인 경우에 1, 아니면 0 => 해당 비트를 1로 설정.
- `AND`
	- 둘 모두 1인 경우에만 1, 아니면 0 => 해당 비트를 0으로 설정
- `XOR`
	- 둘 중에 하나만 1인 경우에 1, 아니면 0 => 해당 비트를 반대값으로 설정.
- `NOT`
	- 모든 비트를 반대로 변경.
## 아이템 36 완벽 공략 49. EnumSet
### `EumSet`
- `Enum`만 담을 수 있는 `Set`
- `Enum`을 일반 `Set`구현체에 담아 사용하는 것 보다 `EnumSet`에 담아 사용하는 것이 효율적 이다.
#### 주요 기능
- `allOf(Enum.class)`
	- 해당 `Enum`타입의 모든 상수를 담은 `EnumSet`만들기.
- `nonOf(Enum.class)`
	- 비어 있는 `EnumSet`만들기
- `range(from, to)`
	- 개인적으로 사용을 권장하지 않는다.
- `contains`, `forEach`, `remove`
****
# 섹션 5. 아이템 37. ordinal 인덱싱 대신 EnumMap을 사용하라.
## 아이템 37. 핵심 정리 1
### 핵심 정리
- `ordinal`을 인덱스의 배열로 사용한 경우
	- 제네릭과 호환되지 않아 비검사 형변환을 수행해야 한다.
	- 배열 인덱스(`ordianl`)만으로는 의미를 알 수 없으니 출력할 때 레이블을 달아야 한다.
	- 정확한 정수값(`oridinal`)을 사용할 것을 개발자가 보장해야 한다.(타입 안정성이 보장되지 않음)
- 열거 타입(`enum`)을 키로 사용하도록 설계한 **아주 빠른**`Map`구현체, `EnumMap`을 사용하면 모든 문제를 해결할 수 있다.
****
# 섹션 6. 아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라.

****
# 섹션 7. 아이템 39. 명명 패턴보다 애너테이션을 사용하라.

****
# 섹션 8. 아이템 40. @Override 애너테이션을 일관되게 사용하라.

****
# 섹션 9. 아이템 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라.

****
# 섹션 10. 아이템 42. 익명 클래스보다는 람다를 사용하라.

****
# 섹션 11. 아이템 43. 람다보다는 메서드 참조를 사용하라.

****
# 섹션 12. 아이템 44. 표준 함수형 인터페이스를 사용하라.

****
# 섹션 13. 아이템 45. 스트림은 주의해서 사용하라.

****
# 섹션 14. 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라.

****
# 섹션 15. 아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다.

****
# 섹션 16. 아이템 48. 스트림 병렬화는 주의해서 적용하라.

****
# 섹션 17. 아이템 49. 매개변수가 유효한지 검사하라.

****
# 섹션 18. 아이템 50. 적시에 방어적 복사본을 만들라.

****
# 섹션 19. 아이템 51. 메서드 시그니처를 신중히 설계하라.

****
# 섹션 20. 아이템 52. 다중정의는 신중히 사용하라.

****
# 섹션 21. 아이템 53. 가변인수는 신중히 사용하라.

****
# 섹션 22. 아이템 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라.

****
# 섹션 23. 아이템 55. 옵셔널 반환은 신중히 하라.

****
# 섹션 24. 아이템 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라.

****