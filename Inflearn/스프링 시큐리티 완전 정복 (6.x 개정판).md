# 강좌 소개
## 인트로

## 커리큘럼 소개

## 강의 자료 및 소스 코드
****
# 초기화 과정 이해

## 프로젝트 생성 / 의존성 추가

## SecurityBuilder / SecurityConfigurer

Spring Security는 **filter**기반 보안 프레임워크이다.

스프링 시큐리티는 초기화 때 인증이나 또는 인가와 관련된 여러가지 작업들을 한다 여러 개의 객체, 설정들을 종합적으로 처리하는 두개의 클래스
### SecurityBuilder
- 웹 보안을 구성하는 빈 객체와 설정 클래스들을 생성하는 역할
- 대표적으로는 WebSecurity, **HttpSecurity**가 있다.

### SecurityConfigurer
- Http 요청과 관련된 보안처리르 담당하는 필터들을 생성하고 여러 초기화 설정에 관여한다.

SecurityBuilder는 SecurityConfigurer를 참조하고 있으며 인증 및 인가 초기화 작업은 SecurityConfigurer에 의해 진행된다.

## WebSecurity / HttpSecurity

### HttpSecurity
- HttpSecurityConfiguration에서 HttpSecurity를 생성하고 초기화를 진행한다.
- 보안에 필요한 각 설정 클래스와 필터들을 생성하고 최종적으로 **SecurityFilterChain**빈 생성하는것이 목적

### WebSecurity
- WebSecurityConfiguration에서 WebSecurity를 생성하고 초기화를 진행한다.
- HttpSecurity에서 생성한 SecurityFilterChain 빈을 SecurityBuilder에 저장한다.
- WebSecurity가 build()를 실행하면 SecurityBuilder에서 SecurityFilterChain을 꺼내어 **FilterChainProxy** 생성자에게 전달한다.

## DelegatingFilterProxy / FilterChainProxy

### Filter
- 웹 애플리케이션에서 클라이언트의 요청(ServletRequest)과 서버의 응답(ServletResponse)을 가공하거나 검사하는데 사용되는 구성요소이다.
- 클라이언트의 요청이 서블릿에 도달하기 전이나 서블릿이 응답을 클라이언트에게 보내기 전에 특정 작업을 수행할 수 있다.
- 서블릿 컨테이너(WAS)에서 생성되고 실행되고 종료된다.

### DelegatingFilterProxy
- 스프링에서 사용되는 특별한 서블릿 필터, 서블릿 컨테이너와 스프링 애플리케이션 컨텍스트 간의 연결고리 역할을 하는 필터
- 서블릿 필터의 기능을 수행하는 동시에 스프링의 의존성 주입 및 빈 관리 기능과 연동되도록 설계된 필터라 할 수 있다.
- "springSecurityFilterChain" 이름으로 생성된 빈을 ApplicationContext에서 찾아 요청을 위임한다.
- 실제 보안처리를 수행하지 않는다.

#### 이놈이 Servlet Filter에서 Spring DI를 사용하는게 가능한 이유를 설명해준다.

### FilterChainProxy
- "springSecurityFilterChain"의 이름으로 생성되는 필터 빈으로서 DelegatingFilterProxy 으로 부터 요청을 위임 받고 보안 처리 역할을 한다.
- 내부적으로 하나 이상의 SecurityFilterChain 객체들을 가지고 있으며 요청 URL 정보를 기준으로 적절한 SecurityFilterChain을 선택하여 필터들을 호출한다
- HttpSecurity를 통해 API 추가 시 관련 필터들을 추가 된다.
- 사용자의 요청을 필터 순서대로 호출함으로 보안 기능을 동작시키고 필요 시 직접 필터를 생성해서 기존의 필터전, 후로 추가 가능하다.

## 사용자 정의 보안 설정하기

### 사용자 정의 보안 기능 구현
- 한개 이상의 SecurityFilterChain 타입의 빈을 정의한 후 인증 API 및 인가 API를 설정한다.
****
# 인증 프로세스

## 폼 인증 - formLogin()

### 폼 인증
- HTTP 기반의 폼 로그인 인증 메커니즘을 활성화하는 API로서 사용자 인증을 위한 사용자 정의 로그인 페이지를 쉽게 구현할 수 있다.
- 기본적으로 스프링 시큐리티가 제공하는 기본 로그인 페이지를 사용하며 사용자 이름과 비밀번호 필드가 포함된 간단한 로그인 양식을 제공한다.
- 사용자는 웹 폼을 통해 자격증명(사용자 이름과 비밀번호)을 제공하고 Spring Security는 HttpServletRequest에서 이값을 읽어 온다.

## 폼 인증 필터 - UsernamePasswordAuthenticationFilter

### 개요
- 스프링 시큐리티는 AbstractAuthenticationProcessingFilter 클래스를 사용자의 자격 증명을 인증하는 기본 필터로 사용한다.
- UsernamePasswordAuthenticationFilter는 AbstractAuthenticationProcessingFilter를 확장한 클래스로서 HttpServletRequest에서 제출된 사용자 이름과 비밀번호로 부터 인증을 수행한다.
- 인증 프로세스가 초기화 될 때 페이지와 로그아웃 페이지 생성을 위한 DefaultLoginPageGeneratingFilter 및 DefaultLogoutPageGeneratingFilter가 초기화 된다.

## 기본 인증 – httpBasic()

### HTTP Basic 인증
- HTTP는 액세스 제어와 인증을 위한 프레임워크를 제공하며 가장 일반적인 인증 방식은 "Basic" 인증 방식이다.
- RFC 7235 표준이며 인증 프로토콜은 HTTP 인증 헤더에 기술되어 있다.

#### 주의사항
- base-64 인코딩된 값은 디코딩이 가능하기 때문에 인증정보가 노출된다.
- HTTP Basic 인증은 반드시 HTTPS 와 같이 TLS 기술과 함께 사용해야 한다.

## 기본 인증 필터 - BasicAuthenticationFilter

### BasicAuthenticationFilter
- 기본 인증 서비스를 제공하는 데 사용된다.
- BasicAuthenticationConverter를 사용해서 요청 헤더에 기술된 인증정보의 유효성을 체크하며 Base64 인코딩된 username과 password를 추출한다
- 인증 이후 세션을 사용하는 경우와 사용하지 않는 경우에 따라 처리되는 흐름에 차이가 있다. 기본적으로는 사용하지 않는다.
- 세션을 사용하는 경우 매 요청마다 인증과정을 거치지 않으나 세션을 사용하지 않는 경우 매 요청마다 인증과정을 거쳐야 한다.

## 기억하기 인증 – rememberMe()

### RememberMe 인증
- 사용자가 웹 사이트나 애플리케이션에 로그인할 때 자동으로 인증 정보를 기억하는 기능이다
- UsernamePasswordAuthenticationFilter 와 함께 사용되며, AbstractAuthenticationProcessingFilter 슈퍼 클래스에서 훅을 통해 구현된다.
	- 인증 성공시 RememberMeServices.loginSuccess()를 통해 RemeberMe 토큰을 생성하고 쿠키로 전달한다.
	- 인증 실패시 RememberMeServices.loginFail()를 통해 쿠키를 지운다.
	- LogoutFilter 와 연계해서 로그아웃 시 쿠키를 지운다.

#### 토큰 생성
- 기본적으로 암호화된 토큰으로 생성 되어지며 브라우저에 쿠키르 보내고, 향후 세션에서 이 쿠키를 감지하여 자동 로그인이 이루어지는 방식으로 달성된다.
- base64(username + ":" + expirationTime + ":" algorithmName + ":" + algorithmHex(username + ":" + expirationTime + ":" + password + ":" + key))
	- username: UserDetailsService로 식별 가능한 사용자 이름
	- password: 검색된 UserDetails 에 일치하는 비밀번호
	- expirationTime: remeber-me 토큰이 만료되는 날짜와 시간, 밀리초로 표현
	- key: remember-me 토큰의 수정을 방지하기 위한 개인키
	- algorithmName: remember-me 토큰 서명을 생성하고 검증하는 데 사용되는 알고리즘 (기본적으로 SHA-256 알고리즘을 사용)

### RememberMeServices 구현체

#### TokenBasedRememberMeServices
- 쿠키 기반 토큰의 보안을 위해 해싱을 사용한다

#### PersistentTokenBasedRememberMeServices
- 생성된 토큰을 저장하기 위해 데이터베이스나 다른 영구 저장 매체를 사용한다.

두 구현 모두 사용자의 정보를 검색하기 위한 UserDetailsService가 필요하다.

## 기억하기 인증 필터 - RememberMeAuthenticationFilter

### RememberMeAuthenticationFilter
- SecurityContextHolder에 Authentication이 포함되지 않은 경우 실행되는 필터이다.
- 세션이 만료되었거나 어플리케이션 종료로 인해 인증 상태가 소멸된 경우 토큰 기반 인증을 사용해 유효성을 검사하고 토큰이 검증되면 자동 로그인 처리를 수행한다.

## 익명 인증 사용자 – anonymous()

### 익명사용자
- 스프링 시큐리티에서 "익명으로 인증된" 사용자와 인증되지 않은 사용자 간에 실제 개념적 차이는 없으며 단지 액세스 제어 속성을 구성하는 더 편리한 방법을 제공한다고 볼 수 있다.
- SecurityContextHolder 가 항상 Authentication 객체를 포함하고 null을 포함하지 않는다는 것을 규칙을 세우게 되면 크래스를 더 견고하게 작성할 수 있다.
- 인증 사용자와 익명 인증 사용자를 구분해서 어떤 기능을 수행하고자 할 때 유용할 수 있으며 익명 인증 객체를 세션에 저장하지 않는다.
- 익명 인증 사용자의 권한을 별도로 운용할 수 있다. 즉 인증된 사용자가 접근할 수 없도록 구성이 가능하다.

### AnonymousAuthenticationFilter
- SecurityContextHolder에 Authentication 객체가 없을 경우 감지하고 필요한 경우 새로운 Authentication 객체로 채운다.

## 로그 아웃 – logout() -1

### 로그아웃
- 스프링 시큐리티는 기본적으로 DefaultLogoutPageGeneratingFilter 를 통해 로그아웃 페이지를 제공하며 "GET/logout" URL 로 접근이 가능하다
- 로그아웃 실행은 기본적으로 "POST/logout" 으로만 가능하나 CSRF 기능을 비활성화 할 경우 혹은 RequestMatcher를 사용할 경우 GET, PUT, DELETE 모두 가능하다.
- 로그 아웃 필터를 거치지 않고 스프링 MVC에서 커스텀 하게 구현할 수 있으며 로그인 페이지가 커스텀하게 생성될 경우 로그아웃 기능도 커스텀하게 구현해야 한다.

## 로그 아웃 – logout() -2

## 요청 캐시 RequestCache / SavedRequest

### RequestCache
- 인증 절차 문제로 리다이렉트 된 후에 이전에 했던 요청 정보를 담고 있는 'SaveRequest' 객체를 쿠키 혹은 세션에 저장하고 필요시 다시 가져와 실행하는 캐시 메커니즘이다.

### SaveRequest
- 로그인과 같은 인증 절차 후 사용자를 인증 이전의 원래 페이지로 안내하며 이전 요청과 관련된 여러 정보를 저장한다.

### RequestCacheAwareFilter
- 이전에 저장했던 웹 요청을 다시 불러오는 역할을 한다.
- SavedRequest가 현재 Request와 일치하면 이 요청을 필터 체인의 doFilter 메소드에 전달하고 SavedRequest 가 없으면 필터는 원래 Request 을 그대로 진행시킨다.
****
# 인증 아키텍처

## 인증 – Authentication

****
# 인증 상태 영속성
****
# 세션 관리
****
# 예외 처리
****
# 악용 보호
****
# 인가 프로세스
****
# 인가 아키텍처
****
# 이벤트 처리
****
# 통합하기
****
# 고급설정
****
# 실전 프로젝트 - 회원 인증 시스템
****
# 실전 프로젝트 - 비동기 인증
****
# 실전 프로젝트 - 회원 관리 시스템
****
# 번외
****
# 마무리
****