# 1. 강의 소개와 자료
## 강의 소개
==람다, 스트림, 함수형 프로그래밍 등을 실무에서 사용할 수 있는 레벨의 강의가 될것이다. good==
## 수업 자료
## 강의 소스 코드
****
# 2. 람다가 필요한 이유
## 프로젝트 환경 구성
==intellij 세팅법==
## 람다가 필요한 이유1
**프로그래밍에서 중복을 제거하고, 좋은 코드를 유지하는 핵심은 변하는 부분과 변하지 않는 부분을 분리하는 것이다.**
### 값 매개변수화(Value Parameterization)
- 문자값(Value), 숫자값(Value)처럼 구체적인 값을 메서드(함수) 안에 두는 것이 아니라, 매개변수(파라미터)를 통해 외부에서 전달받도록 해서, 메서드의 동작을 달리하고, 재사용성을 높이는 방법.
- 값 매개변수화, 값 파라미터화 등으로 부른다.
## 람다가 필요한 이유2
### 동작 매개변수화(Behavior Parameterization)
- 코드 조각(코드의 동작 방법, 로직, Behavior)을 메서드(함수) 안에 두는 것이 아니라, 매개변수(파라미터)를 통해서 외부에서 전달 받도록  해서, 메서드의 동작을 달리하고, 재사용성을 높이는 방법을 동작 매개변수화라 한다.
- 동작 매개변수화, 동작 파라미터화, 행동 매개변수화(파라미터화), 행위 파라미터화등으로 부른다.
## 람다가 필요한 이유3
==기존의 익명클래스를 람다로 변환==
## 함수 vs 메서드
함수(Function)과 메서드(Method)는 둘 다 어떤 작업(로직)을 수행하는 코드의 묶음
### 객체(클래스)와의 관계
#### 함수(Function)
- 독립적으로 존재하며, 클래스(객체)와 직접적인 연관이 없다.
	- 사실 Java에서는 불가능한 이야기
- 객체지향 언어가 아닌 C 등의 절차적 언어에서는 모든 로직이 함수 단위로 구성된다.
- 객체지향 언어라 하더라도, 예를 들어 Python이나 JavaScript처럼 클래스 밖에서도 정의할 수 있는 “함수”개념을 지원하는 경우, 이를 그냥 함수라고 부른다.
#### 메서드(Method)
- 클래스(또는 객체)에 속해 있는 “함수”이다.
- 객체의 상태(필드, 프로퍼티 등)에 직접 접근하거나, 객체가 제공해야 할 기능을 구현할 수 있다.
- Java, C++, C#, Python등 대부분의 객체지향 언어에서 클래스 내부에 정의된 함수는 보통 “메서드”라고 부른다.
## 람다 시작
==매개변수가 없는 람다와 매개변수가 있는 람다 코드 작성==
****
# 3. 람다
## 람다 정의
### 람다
- 자바 8부터 도입된 람다는 자바서 함수형 프로그래밍을 지원기 위한 핵심 기능
- `람다 == 익명함수`
- 익명 함수를 지칭하는 일반적인 용어 == 개념
- 익명 클래스의 구현을 간단히 표현할 수 있는 **문법 설탕(Syntactic sugar, 코드를 간결하게 만드는 문법적 편의)**
### 람다식
- `(매개변수) -> {본문}`형태로 람다를 구현하는 구체적인 문법 표현
## 함수형 인터페이스 
### 함수형 인터페이스
- 정확히 하나의 추상 메서드를 가지는 인터페이스
- 람다는 추상 메서드가 하나인 함수형 인터페이스에만 할당할 수 있다.
- 단일 추상 메서드를 줄여서 SAM(Single Abstract Method)라 한다.
- 참고로 람다는 클래스, 추상 클래스에는 할당할 수 없다. 오직 단일 추상 메서드를 가지는 인터페이스에만 할당할 수 있다.
## 람다와 시그니처
==람다의 선언 방법 매개변수에 따른 사용방법==
## 람다와 생략
==람다의 문법에서 생략할 수 있는 방법들==
## 람다의 전달
==람다를 변수로, 람다를 매개변수로, 람다를 함수의 반환 타입으로, 전달하는법==
## 고차 함수
### 고차 함수(Higher-Order Function)
- 함수를 값처럼 다루는 함수
- 일반적으로 다음 두 가지 중 하나를 만족하면 고차 함수라 한다.
	- 함수를 인자로 받는 함수(메서드)
	- 함수를 반환하는 함수(메서드)
- **함수를 다루는 추상화 수준이 더 높다**는 데에서 유래
## 문제와 풀이1
==위에 코드들의 복습==
## 문제와 풀이2
==filter, map 문제 풀이==
## 문제와 풀이3
==고차함수 반환, reduce, compose 문제 풀이==
## 정리

****
# 4. 함수형 인터페이스
## 함수형 인터페이스와 제네릭1
==제네릭 사용전 Object까지 활용해서 함수형 인터페이스 사용하기==
## 함수형 인터페이스와 제네릭2
==제네릭을 활용한 함수형 인터페이스 활용==
## 람다와 타겟 타입
### 람다와 타겟 타입
- 람다는 그 자체만으로는 구체적인 타입이 정해져 있지 않고, **타겟 타입(target type)** 이라고 불리는 맥락(대입되는 참조형)에 의해 타입이 결정된다.
## 기본 함수형 인터페이스
==Funtion, Consumer, Supplier, Runnable==
## 특화 함수형 인터페이스
==Predicate, Operator에 대한 코드 가독성, 유지보수성 Function을 쓰지않고 사용하는 이유==
## 기타 함수형 인터페이스
==Primitive를 반환하고 입력하는 함수형 인터페이스와 3개이상의 매개변수를 사용하는 함수형 인터페이스는 없다 사용하려면 만들것. 람다를 사용할 때 왠만하면 제공해주는 함수형 인터페이스를 사용하고 아니라면 꼭 의미에 맞는 이름을 사용해서 만들것!==
## 문제와 풀이
## 정리

****
# 5. 람다 활용
## 필터 만들기1
==if문, Predicate를 활용해서 even, odd 구분하기==
## 필터 만들기2
==IntegerFilter, GenericFilter를 활용하기==
## 맵 만들기1
==변환, Function을 활용하기==
## 맵 만들기2
==StringToIntegerMapper, GenericMapper를 활용하기==
## 필터와 맵 활용1
### 명령형 프로그래밍 (Imperative Programming)
- 정의
	- 프로그램이 **어떻게(How)** 수행되어야 하는지, 즉 수행 절차를 명시하는 방식이다.
- 특징
	- 단계별 실행
		- 프로그램의 각 단계를 명확하게 지정하고 순서대로 실행한다.
	- 상태 변화
		- 프로그램의 상태(변수 값 등)가 각 단계별로 어떻게 변화하는지 명시한다.
	- 낮은 추상화
		- 내부 구현을 직접 제어해야 하므로 추상화 수준이 낮다.
	- 예시
		- 전통적인 `for`루프, `while`루프 등을 명시적으로 사용하는 방식
- 장점
	- 시스템의 상태와 흐름을 세밀하게 제어할 수 있다.
### 선언적 프로그래밍 (Declarative Programming)
- 정의
	- 프로그램이 **무엇(What)** 을 수행해야 하는지, 즉 원하는 결과를 명시하는 방식이다.
- 특징
	- 문제 해결에 집중
		- 어떻게(how)문제를 해결할지보다 무엇을 원하는지에 초점을 맞춘다.
	- 코드 간결성
		- 간결하고 읽기 쉬운 코드를 작성할 수 있다.
	- 높은 추상화
		- 내부 구현을 숨기고 원하는 결과에 집중할 수 있도록 추상화 수준을 높인다.
	- 예시
		- `filter`, `map`등 람다의 고차 함수를 활용한, HTML, SQL등
- 장점
	- 코드가 간결하고, 의도가 명확하며, 유지보수가 쉬운 경우가 많다.
## 필터와 맵 활용2
==한번더 명령형과 선언적 프로그래밍 코드 작성==
## 스트림 만들기1
==filter와 map을 내부적으로 가지고 있는 stream class 작성 및 메서드 체인 사용==
## 스트림 만들기2
### 정적 팩토리 메서드 (static factory method)
- 객체 생성을 담당하는 static 메서드로, 생성자(constructor) 대신 인스턴스를 생성하고 반환하는 역할을 한다.
- 일반적인 생성자(Constructor)대신에 클래스의 인스턴스를 생성하고 초기화하는 로직을 캡슐화 하여 제공하는 정적(static) 메서드이다.
#### 특징
- 정적 메서드
	- 클래스 레벨에서 호출되며, 인스턴스 생성 없이 접근할 수 있다.
- 객체 반환
	- 내부에서 생성한 객체(또는 이미 존재하는 객체)를 반환한다.
- 생성자 대체
	- 생성자와 달리 메서드 이름을 명시할 수 있어, 생성 과정의 목적이나 특징을 명확하게 표현할 수 있다.
- 유연한 구현
	- 객체 생성 과정에서 캐싱, 객체 재활용, 하위 타입 객체 반환 등 다양한 로직을 적용할 수 있다.
## 스트림 만들기3
==제네릭을 이용한 스트림 만들기==
## 스트림 만들기4
### 내부 반복 vs 외부 반복 선택
#### 내부 반복
- 많은 경우 내부 반복을 사용할 수 있다면 내부 반복이 선언형 프로그래밍 스타일로 직관적이기 때문에 더 나은 선택
#### 외부 반복 선택
- 단순히 한두 줄 수행만 필요한 경우
- 반복 제어에 대한 복잡하고 세밀한 조정이 필요할 경우
	- `break`, `continue`등을 사용해야 하는 경우
## 정리

****
# 6. 람다 vs 익명 클래스
## 람다 vs 익명 클래스1
### this 키워드의 의미
#### 익명 클래스
- 내부에서 `this`는 익명 클래스 자신을 가리킨다.
- 외부 클래스와 별도의 컨텍스트를 가진다.
#### 람다 표현식
- `this`는 람다를 선언한 클래스의 인스턴스를 가리킨다.
- 즉, 람다 표현식은 별도의 컨텍스트를 가지는 것이 아니라, 람다를 선언한 클래스의 컨텍스트를 유지한다.
## 람다 vs 익명 클래스2
### 익명 클래스와 람다의 용도 구분
#### 익명 클래스
- **상태를 유지**하거나 다중 메서드를 구현할 필요가 있는 경우
- 기존 클래스 또는 인터페이스를 상속하거나 구현할 때
- 복잡한 인터페이스 구현이 필요할 때
#### 람다
- **상태를 유지할 필요가 없고**, 간결함이 중요한 경우
- 단일 메서드만 필요한 간단한 함수형 인터페이스 구현 시
- 더 나은 성능(이 부분은 미미하다)과 간결한 코드가 필요한 경우
## 정리

****
# 7. 메서드 참조
## 메서드 참조가 필요한 이유
### 메서드 참조의 장점
- 코드가 더욱 간결해지고, 가독성이 향상된다.
- 더 이상 매개변수를 명시적으로 작성할 필요가 없다.
	- 컴파일러가 자동으로 매개변수를 매칭한다.
- 별도의 로직 분리와 함께 재사용성 역시 높아진다.
### 메서드 참조란?
- **”이미 정의된 메서드를 그대로 참조하여 람다 표현식을 더 간결하게 작성하는 방법”**
- 이미 정의된 메서드를 람다로 변환하여 더욱 간결하게 사용할 수 있도록 해주는 문법적 편의 기능
- 람다를 작성할 때, 이미 정의된 메서드를 **그대로 호출하는** 경우
## 메서드 참조1 - 시작
### 메서드 참조의 4가지 유형
1. 정적 메서드 참조
2. 특정 객체의 인스턴스 메서드 참조
3. 생성자 참조
4. 임의 객체의 인스턴스 메서드 참조
### 메서드 참조에서 `()`를 사용하지 않는 이유
- `()`는 메서드를 즉시 호출한다는 의미를 가진다. 여기서 `()`가 없는 것은 메서드 참조를 하는 시점에는 메서드를 호출하는게 아니라 단순히 메서드의 이름으로 해당 메서드를 참조만 한다는 뜻이다.
	- 해당 메서드의 실제 호출 시점은 함수형 인터페이스를 통해서 이후에 이루어진다.
## 메서드 참조2 - 매개변수1
### 메서드 참조에서 매개변수를 생략하는 이유
- 함수형 인터페이스의 시그니처(매개변수와 반환 타입)가 정해져 있고, 컴파일러가 그 시그니처를 바탕으로 메서드 참조와 연결해주기 때문에 명시적으로 매개변수를 작성하지 않아도 자동으로 추론되어 호출된다.
## 메서드 참조3 - 임의 객체의 인스턴스 메서드 참조
### 임의 객체의 인스턴스 메서드 참조
`Class::instanceMethod`
- `Class`는 Type (매개변수) `(Class clazz)`
- `instanceMethod`는 해당 Type이 가지는 메서드
## 메서드 참조4 - 활용1
==메서드를 활용해서 메서드 참조를 활용하는 예시==
## 메서드 참조5 - 활용2
### 메서드 참조의 장점
- 메서드 참조를 사용하면 람다 표현식을 더욱 직관적으로 표현할 수 있다.
- 각 처리 단계에서 호출되는 메서드가 무엇인지 쉽게 파악할 수 있다.
## 메서드 참조6 - 매개변수2
==매개변수의  수는 상관없다. 이미 메서드 정보로 매개변수의 정보를 알고 있다.==
## 정리


****
# 8. 스트림 API1 - 기본
## 스트림 API 시작
==스트림 맛보기==
## 스트림 API란?
### 스트림 API란?
#### 스트림(Stream)
- 자바 8부터 추가된 기능으로, 데이터의 흐름을 추상화해서 다루는 도구이다.
#### 컬렉션(Collection) 또는 배열등
- 연산 파이프라인을 통해 연속적인 형태로 처리할 수 있게 해준다.
##### 연산 파이프라인
- 여러 연산(중간 연산, 최종 연산)을 **체이닝**해서 데이터를 변환, 필터링 계산하는 구조
### 스트림의 특징
1. 데이터 소스를 변경하지 않는다(Immutable)
	- 스트림에서 제공하는 연산들은 원본 컬렉션을 변경하지 않고 결과만 새로 생성
2. 일회성(1회 소비)
	- 한번 사용(소비)된 스트림은 다시 사용할 수 없고 필요하다면 다시 생성해야한다.
3. 파이프라인(Pipeline) 구성
	- 중간 연산들이 이어지다가, 최종 연산을 만나면 연산이 수행되고 종료된다.
4. 지연 연산(Lazy Operation)
	- 중간 연간은 필요할 때까지 실제로 동작하지 않고, 최종 연산이 실행될 때 한번에 처리된다.
5. 병렬 처리(Parallel) 용이
	- 스트림으로 부터 병렬 스트림(Parallel Stream)을 쉽게 만들어서, 멀티코어 환경에서 병렬 연산을 비교적 단순한 코드로 작성할 수 있다.
## 파이프라인 구성
### 일괄 처리(Batch Processing)
- 공정(중간 연산)을 단계별로 쪼개서 데이터 전체를 한 번에 처리하고, 결과를 저장해두었다가 다음 공정을 또 한번에 수행한다.
### 파이프라인 처리(Pipeline Processing)
- 한 요소가 한 공정을 마치면, 즉시 다음 공정으로 넘어가는 구조
## 지연 연산
### 스트림 API의 지연 연산
- 파이프라인 설정을 해놓기만 하고, 실제 연산은 최종 연산이 호출되기 전까지 전혀 진행되지 않는다.
## 지연 연산과 최적화
### 지연 연산의 장점
1. 불필요한 연산의 생략(단축, Short-Circuiting)
2. 메모리 사용 효율
3. 파이프라인 최적화

****
# 9. 스트림 API2 - 기능
## 스트림 생성
==여러가지의 Stream 생성 방법==
## 중간 연산
==여러가지의 Stream 중간 연산 종류 연습==
## FlatMap
### FlatMap
- 중첩 구조(컬렉션 안의 컬렉션, 배열 안의 배열등)를 일차원으로 펼치는데 사용
## Optional 간단 설명
==Stream에 최종 연산에 있는 Optional을 위해 간단한 설명==
## 최종 연산
==여러가지의 Stream 최종 연산 종류 연습==
## 기본형 특화 스트림
### 성능 - 전통적인 for문 vs 스트림 vs 기본형 특화 스트림
- 전통적인 for문이 보통 가장 빠르다.
- 스트림보다 전통적인 for 문이 1.5배 ~ 2배정도 빠르다.
	- `Integer`같은 객체를 다루는 `Stream`을 의미한다.
	- 박싱/언박싱 오버헤드가 발생한다.
- 기본형 특화 스트림(`IntStream`등)은 전통적인 for문에 가까운 성능을 보여준다.
	- 전통적인 for문과 거의 비슷하거나 전통적인 for문이 10% ~ 30% 정도 더 빠르다.
	- 박싱/언박싱 오버헤드를 피할 수 있다.
	- 내부적으로 최적화된 연산을 수행할 수 있다.
### 실무 선택 기준
- 이런 성능 차이는 대부분의 일반적인 애플리케이션에서는 거의 차이가 없다.
	- 최소 수천만 건 이상의 루프여야 차이가 느껴짐
- 박싱/언박싱을 많이 유발하지 않는 상황이라면 일반 스트림과 기본형 특화 스트림 간 성능 차이는 그리 크지 않을 수 있다.
- **최적의 선택은 구현의 가독성, 유지보수성등을 함께 고려해서 결정해야 한다.**

****
# 10. 스트림 API3 - 컬렉터
## 컬렉터1
==Collectors의 List, Map에 관련 최종 연산 연습==
## 컬렉터2
==Collectors의 groupBy, partitionBy, min, max, count, summarizingInt, reducing과 관련 최종 연산 연습 ==
## 다운 스트림 컬렉터1
### 다운 스트림 컬렉터가 필요한 이유
- 그룹화된 이후 각 그룹 내부에서 추가적인 연산 또는 결과물(예: 평균,합계,최대값,최소값,통계,다른 타입으로 변환등)을 정의하는 역할
## 다운 스트림 컬렉터2
==`collectingAndThen()`의 후처리를 사용한 다운스트림 연습==
## 정리

****
# 11. Optional
## 옵셔널이 필요한 이유
### 옵셔널이 필요한 이유
1. `NullPointerException(NPE)`문제
2. 가독성 저하
3. 의도가 드러나지 않음
## Optional의 생성과 값 획득
==Optional 생성과 Optional의 값 획득 메서드 확인 `or`은 처음보는데?==
## Optional 값 처리
==값이 있는 Optional과 비어있는 Optional의 값처리==
## 즉시 평가와 지연 평가1
==자바 연산의 우선순위에 대한 정리 `+` 같은 연산은 일단 해당 라인에서 가장 먼저 이루어진다.==
## 즉시 평가와 지연 평가2
==연산을 정의하는 것과 연산을 실행하는 시점의 분리해야 한다.==
## 즉시 평가와 지연 평가3
==Supplier를 활용한 지연 평가==
## orElse() vs orElseGet()
### orElse() vs orElseGet()
- `orElse()`
	- 즉시 평가
	- 값이 이미 존재할 가능성이 높거나, 혹은 `orElse()`에 넘기는 객체(또는 메서드)가 생성 비용이 크지 않은 경우 사용해도 괜찮다.
	- 연산이 없는 상수나 변수의 경우 사용해도 괜찮다.
- `orElseGet()`
	- 지연 평가
	- 주로 `orElse()`에 넘길 값의 생성 비용이 큰 경우, 혹은 값이 들어있을 확률이 높아 굳이 매번 대체 값을 계싼할 필요가 없는 경우에 사용한다.
## 실전 활용1 - 주소 찾기
==Optional의 map을 활용 Optional은 Stream과 비슷한 연산처리가 있을뿐 중간연산과 최종연산과는 관련이 없다.==
## 실전 활용2 - 배송
==Optional을 활용하기 맛있네?==
## 옵셔널 - 베스트 프랙티스
### 옵셔널 - 베스트 프랙티스
- 메서드의 반환값에 대해 값이 없을 수도 있음을 표현하기 위해 도입되었다.
#### 1. 반환 타입으로만 사용하고, 필드에는 가급적 쓰지 말기
#### 2. 메서드 매개변수로 `Optional`을 사용하지 말기
#### 3. 컬렉션(`Collection`)이나 배열 타입을 `Optional`로 감싸지 말기
- 컬렉션도 null이 아닌 빈 컬렉션을 반환해야 한다.
#### 4. `isPresent()`와 `get()`조합을 직접 사용하지 않기
#### 5. `orElseGet()` vs `orElse()`차이를 분명히 이해하기
#### 6. 무조건 `Optional`이 좋은 것은 아니다.
- `Optional`사용이 불필요한 상황
	1. 항상 값이 있는 상황
	2. 값이 없으면 예외를 던지는 것이 더 자연스러운 상황
	3. 흔히 비는 경우가 아니라 흔히 채워져 있는 경우
	4. 성능이 극도로 중요한 로우레벨 코드
## 정리


****
# 12. 디폴트 메서드
## 디폴트 메서드가 등장한 이유
==디폴트 메서드의 등장이유와 사용방법==
## 디폴트 메서드 소개
### 디폴트 메서드의 도입 이유
#### 하휘 호환성(Backward Compatibility) 보장
#### 라이브러리 확장성
#### 람다와 스트림 API 연계
#### 설계 유연성 향상
## 디폴트 메서드의 올바른 사용법
### 디폴트 메서드의 올바른 사용법
#### 1. 하위 호환성을 위해 최소한으로 사용
#### 2. 인터페이스는 여전히 추상화의 역할
- 하위 호환을 기능이나, 공통으로 쓰기 쉬운 간단한 로직 제공하는정도가 이상적
#### 3. 다중 상속(충돌) 문제
#### 4. 디폴트 메서드에 상태(state)를 두지 않기
## 정리

****
# 13. 병렬 스트림
## 단일 스트림
==병렬 스트림 작업을 위한 세팅==
## 스레드 직접 사용
==new Thread(Runaable)를 활용해서 처리하기==
## 스레드 풀 사용
==Executors.newFixedThreadPool()를 활용해서 처리하기.==
## Fork/Join 패턴
### Fork/Join 패턴
1. 작업 분할(Fork)
2. 처리(Execute)
3. Join 모음, 결과 합치기
## Fork/Join 프레임워크1 - 소개
### 주요 개념
#### 분할 정복(Divide and Conquer) 전략
- 큰 작업(task)을 작은 단위로 재귀적으로 분할(fork)
- 각 작은 작업의 결과를 합쳐(join) 최종 결과를 생성
- 멀티코어 환경에서 작업을 효율적으로 분산 처리
#### 작업 훔치기(Work Stealing) 알고리즘
- 각 스레드는 자신의 작업 큐를 가짐
- 작업이 없는 스레드는 다른 바쁜 스레드의 큐에서 작업을 “훔쳐와서” 대신 처리
- 부하 균형을 자동으로 조절하여 효율성 향상
### 주요 클래스
#### `ForkJoinPool`
- Fork/Join 작업을 실행하는 특수한 `ExecutorService` 스레드 풀
- 작업 스케줄링 및 스레드 관리를 담당
- 기본적으로 사용 가능한 프로세서 수 만큼 스레드 생성
	- CPU코어가 10코어면 10개의 스레드 생성
- 쉽게 이야기해서 **분할 정복과 작업 훔치기에 특화된 스레드 풀**
#### `ForkJoinTask`
- `ForkJoinTask`는 Fork/Join 작업의 기본 추상 클래스이다.
- `Future`를 구현했다.
- 개발자는 주로 다음 두 하위 클래스를 구현해서 사용한다.
	- `RecursiveTask<V>`: 결과를 반환하는 작업
	- `RecursiveAction`: 결과를 반환하지 않는 작업(`void`)
#### `RecursiveTask`/`RecursiveAction`의 구현 방법
- `compute()`메서드를 재정의해서 필요한 작업 로직을 작성한다.
- 일반적으로 일정 기준(임계값)을 두고, 작업 범위가 작으면 직접 처리하고,크면 작업을 둘로 분할하여 각각 병렬로 처리하도록 구현한다.
## Fork/Join 프레임워크2 - 작업 훔치기
==임계값을 낮춰서 좀더 많은 병렬처리==
## 작업 훔치기 알고리즘
==작업 훔치기 알로리즘에 대한 설명과 임계값 설정 팁등..==
## Fork/Join 프레임워크3 - 공용 풀
### Fork/Join 공용 풀의 특징
#### 시스템 전체에서 공유
#### 자동 생성
#### 편리한 사용
#### 병렬 스트림 활용
#### 자원 효율성
#### 병렬 수준 자동 설정
### 공용 풀 vs 커스텀 풀
#### 차이점
1. 자원 관리
2. 재사용성
3. 설정 제어
4. 라이프사이클
### 공용 풀이 `CPU-1`만큼 스레드를 생성하는 이유
1. 메인 스레드의 참여
2. 다른 프로세스와의 자원 경쟁 고려
3. 효율적인 자원 활용
## 자바 병렬 스트림
==Stream..parallel()... ForkJoinPool 사용한다 알아서==
## 병렬 스트림 사용시 주의점1
### 주의사항 - Fork/Join 프레임워크는 CPU 바운드 작업에만 사용해라!
- Fork/Join 프레임워크는 주로 CPU 바운드 작업(계산 집약적인 작업)을 처리하기 위해 설계되었다.
### I/O 작업처럼 블로킹 대기 시간이 긴 작업을 `ForkJoinPool`에서 처리하면 다음과 같은 문제가 발생한다.
1. 스레드 블로킹에 따른 CPU 낭비
2. 컨텍스트 스위칭 오버헤드 증가
3. 작업 훔치기 기법 무력화
4. 분할-정복(작업 분할) 이점 감소
### 핵심 문제점
1. 공용 풀 병목 현상
2. 자원 경쟁
3. 예측 불가능한 성능
## 병렬 스트림 사용시 주의점2
==Executors를 활용해서 처리하는것이 더 빠르다 I/O 바운드는==
## 정리
### `CompletableFuture`와 주의 사항
- 병렬 스트림을 I/O 대기 작업에 사용하거나, 또는 `CompletableFuture`를 사용할 때 발생한다.
- `CompletableFuture`를 생성할 때는 별도의 스레드 풀을 반드시 지정해야 한다. 그렇지 않으면 `Fork/Join`공용 풀이 대신 사용된다. **반드시 커스텀 풀을 지정해서 사용하자!**

****
# 14. 함수형 프로그래밍
## 프로그래밍 패러다임
### 프로그래밍 패러다임
#### 명령형 프로그래밍 (Imperative)
- 절차지향 프로그래밍 (Procedural)
- 객체지향 프로그래밍 (OOP)
##### 핵심 개념
- 어떻게(How) 할것인지 구체적으로 명령(Instruction)을 내리는 방식
##### 특징
- 프로그램이 어떤 순서와 단계로 동작해야 하는지를 구체적인 제어 흐름(조건문, 반복문등)으로 기술
- 변수의 값이 바뀌면서 상태(state)가 변해간다.
- CPU의 동작 방식(메모리 수정, 제어 흐름에 따른 실행)과 유사하여, 전통적인 하드웨어와의 직관적인 일치
- 예시: C, C++, Java등 대부분의 언어가 명령형 특성을 지닌다.
##### 장단점
- 장점
	- 컴퓨터의 동작 방식과 매우 유사해 이해하기 직관적, 제어 흐름을 상세히 제어하기 쉽다.
- 단점
	- 프로그램 규모가 커지면 상태 변경에 따른 복잡도 증가
#### 선언형 프로그래밍 (Declarative)
- 함수형 프로그래밍 (Functional)
##### 핵심 개념
- 무엇을(What) 할 것인지를 기술하고, 어떻게(How) 구현, 실행될지는 위임하는 방식
##### 특징
- 구체적인 제어 흐름(조건문, 반복문등)을 직접 작성하기보다, 원하는 결과나 조건을 선언적으로 표현
- 상태 변화보다는 결과에 초첨을 맞추어 코드를 작성
- 대표적인 예시: SQL(쿼리로 원하는 데이터나 조건을 선언), HTML(화면 구조/콘텐츠만 기술하면 브라우저가 렌더링)
- 함수형 프로그래밍 드이 선언형 패러다임에 속하거나 밀접하게 관련됨
##### 장단점
- 장점
	- 구현의 복잡한 로직을 많이 숨길 수 있어, 높은 수준에서 문제 해결에 집중 가능. 비즈니스 로직을 직관적으로 표현하기 쉬움
- 단점
	- 언어나 환경이 제공하는 추상화 수준에 의존적이며, 내부 동작이 보이지 않을 경우 디버깅이 어려울 수 있음, 낮은 수즌의 최적화나 세밀한 제어가 필요한 상황에서는 제약이 생길 수 있음.
## 함수형 프로그래밍이란?
### 함수형 프로그래밍의 핵심 개념과 특징
#### 순수 함수(Pure Function)
- 같은 인자를 주면 항상 같은 결과를 반환하는 함수
- 외부 상태(변할 수 있는 전역 변수등)에 의존하거나, 외부 상태를 변경하는 부수 효과(Side Effect)가 없는 함수를 의미한다.
#### 부수 효과(Side Effect) 최소화
- 함수형 프로그래밍에서는 상태 변화를 최소화하기 위해 변수나 객체를 변경하는 것을 지양한다.
- 이로 인해 프로그램의 버그가 줄어들고, 테스트나 병렬 처리(Parallelism), 동시성(Concurrency)지원이 용이해진다.
#### 불변성(Immutable State) 지향
- 데이터는 생성된 후 가능한 변경하지 않고, 변경이 필요한 경우 새로운 값을 생성해 사용한다.
- 가변 데이터 구조에서 발생할 수 있는 오류를 줄이고, 프로그램의 예측 가능성을 높여준다.
#### 일급 시민(First-class Citizen) 함수
- 함수가 일반 값(숫자, 문자열, 객체(자료구조) 등)과 동일한 지위를 가진다.
- 함수를 변수에 대입하거나, 다른 함수의 인자로 전달하거나, 함수에서 함수를 반환하는 고차 함수(Higher-orderFunction)를 자유롭게 사용할 수 있다.
#### 선언형(Declarative) 접근
- 어떻게가 아닌 무엇을 계산할지 기술한다.
- 복잡한 제어 구조나 상태 관리를 함수의 합성과 함수 호출로 대체하여 간결하고 가독성 높은 코드를 작성한다.
#### 함수 합성(Composition)
- 간단한 함수를 조합해 더 복잡한 함수를 만드는 것을 권장한다.
- 작은 단위의 함수들을 체이닝(Chaining)하거나 파이프라이닝(Pipelining)해서 재사용성을 높이고, 코드 이해도를 높인다.
#### Lazy Evaluation(지연 평가) (선택적 특징)
- 필요한 시점까지 계산을 미루는 평가 전략이다.
- 불필요한 계산 비용을 줄인다.
### 함수형 프로그래밍의 장단점
#### 장점
- 코드 가독성 및 유지보수성
- 병렬 처리 및 동시성
- 테스트 용이성
#### 단점
- 학습 곡선
- 성능
## 자바와 함수형 프로그래밍1
****
# 15. 다음으로

****