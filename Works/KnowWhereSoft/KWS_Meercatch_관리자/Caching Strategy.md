## Caching Strategy

### 읽기 전략
#### Look Aside (= Lazy Loading)
- cache에서 먼저 찾고 Cache Hit되면 전달하고 아니면 데이터베이스에 요청하고 cache에 저장후 응답 한다.
- 반복적인 읽기가 많은 호출에 적합
- 단점
	- 최신 데이터를 가지고 있다는 것을 보장하지 못한다.
	- key값이 존재하지 않을 때만 캐시에 업데이트가 일어나기 때문
	- 캐시에 붙어있던 connection이 많았다면, redis가 다운된 순간 순간적으로 DB로 몰려서 부하 발생

#### Read Through
- cache에서만 데이터를 읽어오는 전략
- 데이터 동기화를 캐시 제공자에게 위임
- 단점
	- 데이터 조회에 있어 속도가 느리다
	- 조회를 cache 제공자에만 의지 하므로 다운 될 경우 서비스 이용에 차질이 생긴다.
- 데이터 동기화가 항상 이루어져 데이터 정합성 문제에서 벗어날 수 있다.
- 읽기가 많은 워크로드에 적합

### 쓰기 전략

#### Write Back
- 데이터를 저장할 때 DB에 바로 쿼리하지 않고, 캐시에 모아서 일정 주기 배치 작업을 통해 DB에 반영
- 모아서 DB에 쓰기 때문에 쓰기 쿼리 회수 비용과 부하를 줄일 수 있다.
- Write가 빈번하면서 Read를 하는데 많은 양의 Resource가 소모 되는 서비스에 적합
- 데이터 정합성 확보
- 단점
	- 자주 사용되지 않는 불필요한 리소스 저장
	- 캐시에서 오류가 발생하면 데이터 영구 소실

#### Write-Through
- 데이터베이스에 데이터를 작성할 때 마다 캐시에 데이터를 추가하거나 업데이트 한다.
- 캐시의 데이터가 항상 최신 상태로 유지가 가능하다
- 단점
	- 데이터 입력 시 두번의 과정을 거쳐야 하므로 지연 시간이 증가
	- 사용하지 않는 데이터를 캐시가 저장하기 때문에 리소스 낭비가 발생
- TTL사용을 권장한다.

#### Write Around
- Write Through보다 훨씬 빠르다
- 모든 데이터는 DB에 저장 (캐시를 갱신하지 않는다)
- Cache miss가 발생하는 경우에만 DB와 캐시에도 데이터를 저장
- 단점
	- 캐시와 DB 내의 데이터가 다를 수 있다.
	- 데이터 수정 삭제마다 Cache또한 수정 삭제 해야한다