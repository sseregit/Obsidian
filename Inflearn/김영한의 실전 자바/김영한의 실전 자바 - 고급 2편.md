# 강의 소개와 자료

****
# 문자 인코딩
## 프로젝트 환경 구성
## 컴퓨터와 데이터
## 컴퓨터와 문자 인코딩1
### ASCII 문자 집합
- 각 컴퓨터 회사가 독자적인 문자 집합을 사용한다면, 서로 다른 컴퓨터 간에 문자가 올바르게 표시되지 않는 문제가 발생할 수 있다. 이러한 호환성 문제를 해결하기 위해 ASCII(American Standard Code for Information Interchange)라는 표준 문자 집합이 1960년도에 개발되었다.
### ISO_8859_1
- 1980년도
- 기존 ASCII에 서유럽 문자의 추가 필요
- 국제 표준화 기구에서 서유럽 문자를 추가한 새로운 문자 규격을 만듬
- `ISO_8859_1`, `LATIN1`, `ISO-LATIN-1`등으로 불린다.
- 기존 ASCII 문자 집합과 호환 가능
### EUC-KR
- 1980년도
- 초창기 등장한 한글 문자 집합
- 모든 한글을 담는 것 보다는 자주 사용하는 한글 2350개만 포함해서 만들었따.
- 한글의 글자는 아주 많기 때문에 256가지만 표현할 수 있는 1byte로 표현하는 것은 불가능하다.
- 2byte(16bit)를 사용하면 총 65536가지 표현 가능
- ASCII는 1byte, 한글은 2byte를 사용한다
	- 영어를 사용하면 1byte를, 한글을 사용하면 2byte를 메모리에 저장한다.
- 기존 ASCII 문자 집합과 호환 가능
### MS949
- 1990년도
- 마이크로소프트가 EUC-KR을 확장하여 만든 인코딩
- 한글 초성, 중성, 종성 모두 조합하면 가능한 한글의 수는 총 11,172자
- EUC-KR은 '쀍', '삡'과 같이 드물게 사용하는 음절을 표현하지 못함
- 기존 EUC-KR과 호환을 이루면서 한글 11,172자를 모두 수용하도록 만든 것이 MS949
- 윈도우 시스템에서 계속 사용됨
## 컴퓨터와 문자 인코딩2
### 유니코드의 등장
- 전 세계의 모든 문자들을 단일 문자 세트로 표현할 수 있는 유니코드(Unicode) 표준이 1990년대에 도입되었다.
- 하나의 문자 세트에 전 세계 대부분의 언어를 넣어보자! 이름하여 유니코드 -> Uni(Universal) -> 전 세계적인 코드!
- 전 세계의 모든 문자와 기호를 하나의 표준으로 통합하여 표현할 수 있는 문자 집합을 만드는 것
- UTF-16, UTF-8의 시작
- 두 표준이 비슷하게 등장, 초반에는 UTF-16이 인기
#### UTF-16
- 1990년도
- 16bit(2byte) 기반
- 자주 사용하는 기본 다국어들은 2byte로 표현
- 그 외는 4byte로 표현
- 초반에는 UTF-16이 인기, 이 시기에 등장한 자바도 언어 내부적으로 문자를 표현할 때 UTF-16을 사용한다. 그래서 자바의 `char`타입이 2byte를 사용함
##### 단점
- ASCII 영문도 2byte를 사용한다. **ASCII와 호환되지 않음**
- UTF-16을 사용한다면 영문의 경우 다른 문자 집합 보다 2배의 메모리를 더 사용한다.
#### UTF-8
- 1990년도
- 8bit(1byte) 기반, 가변길이 인코딩
- 1byte ~ 4byte를 사용해서 문자를 인코딩
	- 1byte: ASCII, 영문, 기본 라틴 문자
	- 2byte: 그리스어, 히브리어 라틴 확장 문자
	- 3byte: 한글, 한자, 일본어
	- 4byte: 이모지, 고대문자등
- **ASCII 문자는 1바이트로 표현, ASCII 호환**
##### 단점
- 상대적으로 사용이 복잡함
- UTF-16은 대부분의 기본 문자들이 2바이트로 표현되기 때문에, 문자열의 특정 문자에 접근하거나 문자 수르 세는 작업이 상대적으로 간단하다. 반 면 UTF-8은에서는 각 문자가 가변 길이로 인코딩되므로 이런 작업이 더 복잡함.
- ASCII를 제외한 일부 언어에서 더 많은 용량 사용
##### 현대의 사실상 표준 인코딩 기술
- 1990년도 후반 ~ 2000년도 초반에 인터넷과 웹이 빠르게 성장하면서 저변 확대
- 2008년 W3C 웹 표준에 UTF-8 채택
- 현재 대부분의 웹사이트와 애플리케이션에서 기본 인코딩으로 사용
### 정리
**UTF-8이 현대의 사실상 표준 인코딩 기술이 된 이유**
#### 저장 공간 절약과 네트워크 효율성
- 서양 문자에 대해 1바이트를 사용하기 때문에 영문 텍스트에서 효율적
- 데이터를 네트워크로 전달할 때는 매우 큰 효율의 차이르 보인다.
- 웹에 있는 문서의 80% 이상은 영문 문서이다.
#### ASCII와의 호환성
- ASCII와 호환 되면서 전 세계의 모든 문자를 표현할 수 있다.
## 문자 집합 조회
## 문자 인코딩 예제1
### 자바에서의 byte 표현
- 자바의 byte 타입은 양수와 음수를 모두 표현할 수 있다.
- 자바의 byte는 첫 번째 비트(bit)가 0이면 양수, 1이면 음수로 간주된다.
- 결국 자바의 byte는 256가지 값을 표현하지만, 표현 가능한 숫자의 범위는 `-128 ~ 127`이다.
## 문자 인코딩 예제2
### 한글이 깨지는 가장 큰 2가지 이유
#### EUC-KR(MS949), UTF-8이 서로 호환되지 않음
- 한글이 깨지는 대부분의 문제는 UTF-8로 인코딩한 한글을 EUC_KR(MS949)로 디코딩하거나 또는 EUC-KR(MS949)로 인코딩한 한글을 UTF-8로 디코딩할 때 발생한다.
#### EUC-KR(MS949) 또는 UTF-8로 인코딩한 한글을 `ISO-8859-1`로 디코딩 할 때
- EUC-KR(MS949) 또는 UTF-8로 인코딩한 한글을 한글을 지원하지 않는 `ISO-8859-1`로 디코딩 할 때 발생한다.
## 정리

****
# I/O 기본1
## 스트림 시작1
### `read()`가 int를 반환하는 이유
- 참고로 `write()`의 경우도 비슷한 이유로 `int`타입을 입력 받는다.
#### 부호 없는 바이트 표현
- 자바에서 `byte`는 부호 있는 8비트 값(-128 ~ 127)이다.
- `int`로 반환함으로써 0에서 255까지의 모든 가능한 바이트 값을 부호 없이 표현할 수 있다.
#### EOF(End of File) 표시
- byte를 표현하려면 256 종류의 값을 모두 사용해야 한다.
- 자바의 `byte`는 -128에서 127까지 256종류의 값만 가질 수 있어, EOF를 위한 특별한 값을 할당하기 어렵다.
- `int`는 0~255까지 모든 가능한 바이트 값을 표현하고,여기에 추가로 -1을 반환하여 스트림의 끝(EOF)을 나타낼 수 있다.
## 스트림 시작2
### 부분으로 나누어 읽기 vs 전체 읽기
#### `read(byte[], offset, length)`
- 스트림의 내용을 부분적으로 읽거나, 읽은 내용을 처리하면서 스트림을 계속해서 읽어야 할 경우에 적합하다.
- 메모리 사용량을 제어할 수 있다.
- 예시) 파일이나 스트림에서 일정한 크기의 데이터를 반복적으로 읽어야 할 때 유용하다. 예를 들어 대용량 파일을 처리할 때, 한번에 메모리에 로드하기보다는 이 메서드를 사용하여 파일을 조각조각 읽어들일 수 있다.
- 100M의 파일을 1M 단위로 나누어 읽고 처리하는 방식을 사용하면 한 번에 최대 1M의 메모리만 사용한다.
#### `readAllBytes()`
- 한번의 호출로 모든 데이터를 읽을 수 있어 편리하다.
- 작은 파일이나 메모리에 모든 내용을 올려서 처리해야 하는 경우에 적합하다.
- 메모리 사용량을 제어할 수 없다.
- 큰 파일의 경우 OutOfMemoryError가 발생할 수 있다.
## InputStream, OutputStream
### `InputStream`, `OutputStream`의 추상화의 장점
#### 일관성
- 모든 종류의 입출력 작업에 대해 동일한 인터페이스(여기서는 부모의 메서드)를 사용할 수 있어, 코드의 일관성이 유지된다.
#### 유연성
- 실제 데이터 소스나 목적지가 무엇인지에 관계없이 동일한 방식으로 코드를 작성할 수 있다. 예를 들어, 파일, 네트워크, 메모리 등 다양한 소스에 대해 동일한 메서드를 사용할 수 있다.
#### 확장성
- 새로운 유형의 입출력 스트림을 쉽게 추가할 수 있다.
#### 재사용성
- 다양한 스트림 클래스들을 조합하여 복잡한 입출력 작업을 수행할 수 있다. 예를 들어 `BufferedInputStream`을 사용하여 성능을 향상시키거나, `DataInputStream`을 사용하여 기본 데이터 타입을 쉽게 읽을 수 있다.이 부분은 뒤에서 설명한다.
#### 에러 처리
- 표준화된 예외 처리 메커니즘을 통해 일관된 방식으로 오류를 처리할 수 있다.
## 파일 입출력과 성능 최적화1 - 하나씩 쓰기
## 파일 입출력과 성능 최적화2 - 버퍼 활용
### 버퍼의 크기에 따른 쓰기 성능
- 버퍼의 크기가 커진다고 해서 속도가 계속 줄어들지는 않는다. 왜냐하면 디스크나 파일 시스템에서 데이터를 읽고 쓰는 기본 단위가 보통 4KB 또는 8KB이기 때문이다.
- 버퍼의 크기는 보통 4KB, 8KB 정도로 잡는 것이 효율적이다.
## 파일 입출력과 성능 최적화3 - Buffered 스트림 쓰기
### 기본 스트림, 보조 스트림
- `FileOutputStream`과 같이 단독으로 사용할 수 있는 스트림을 기본 스트림이라 한다.
- `BufferedOutputStream`과 같이 단독으로 사용할 수 없고, 보조 기능을 제공하는 스트림을 보조 스트림이라 한다.
## 파일 입출력과 성능 최적화4 - Buffered 스트림 읽기


🍅🍅🍅🍅
****
# I/O 기본2

****
# I/O 활용

****
# File, Files

****
# 네트워크 - 기본 이론

****
# 네트워크 - 프로그램1

****
# 네트워크 - 프로그램2

****
# 채팅 프로그램

****
# HTTP - 기본 이론

****
# HTTP 서버 만들기

****
# 리플렉션

****
# 애노테이션

****
# HTTP 서버 활용

****
# 다음으로

****