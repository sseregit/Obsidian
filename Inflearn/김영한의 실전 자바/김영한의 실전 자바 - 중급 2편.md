# 강의 소개와 자료
****
# 제네릭 - Generic1
## 제네릭이 필요한 이유
## 다형성을 통한 중복 해결 시도
## 제네릭 적용
## 제네릭 용어와 관례

### 제네릭의 핵심
- **사용할 타입을 미리 결정하지 않는다는점 이다.**
- 클래스 내부에서 사용하는 타입을 클래스를 정의하는 시점에 결정하는 것이 아니라 실제 사용하는 생성 시점에 타입을 결정하는 것이다.
- 메서드는 **매개변수**에 **인자**를 전달해서 사용할 값을 결정한다.
- 제네릭 클래스는 **타입 매개 변수**에 **타입 인자**를 전달해서 사용할 타입을 결정한다.
### 용어 정리
#### 제네릭(Generic)
#### 제네릭 타입(Generic Type)
#### 타입 매개 변수(Type Parameter)
- `GenericBox<T>`
- `T`를 뜻한다.
#### 타입 인자(Type Argument)
- `GenericBox<Integer>`
- `Integer`를 뜻한다.
### 제네릭 명명 관례
- 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례
#### 주로 사용하는 키워드
- E - Element
- K - Key
- N - Number
- T - Type
- V - Value
- S,U,V etc. - 2nd, 3rd, 4th types

### Row Type
`GenericBox a = new GenericBox()`
- 타입 인자를 지정하지 않은 경우 로 타입 또는 원시 타입이라 한다.
## 제네릭 활용 예제
## 문제와 풀이1
****
# 제네릭 - Generic2
## 타입 매개변수 제한1 - 시작
## 타입 매개변수 제한2 - 다형성 시도
## 타입 매개변수 제한3 - 제네릭 도입과 실패
## 타입 매개변수 제한4 - 타입 매개변수 제한
## 제네릭 메서드
## 제네릭 메서드 활용
## 와일드카드1
### 참고
와일드 카드는 제네릭 타입이나, 제네릭 메서드를 선언하는 것이 아니다. 와일드 카드는 이미 만들어진 제네릭 타입을 활용할 때 사용한다.
### 비제한 와일드 카드
- 와일드 카드는 제네릭 타입이나 제네릭 메서드를 정의할 때 사용하는 것이 아니다.`Box<Dog>`, `Box<Cat>`처럼 타입 인자가 정해진 제네릭 타입을 전달 받아서 활용할 때 사용한다.
- 와일드카드인 `?`는 모든 타입을 다 받을 수 있다는 뜻이다.
	- `? == <? extends Object>`
- `?`만 사용해서 제한 없이 모든 타입을 다 받을 수 있는 와일드카드를 **비제한 와일드카드**라 한다.
### 제네릭 메서드 vs 와일드카드
- 제네릭 타입이나 제네릭 메서드를 정의하는게 꼭 필요한 상황이 아니라면, 더 단순한 와일드카드 사용을 권장한다.
## 와일드카드2
### 상한 와일드카드
- `? extends Animal`
	- Animal 이하
### 하한 와일드카드
- `? super Animal`
	- Animal 이상
- 제네릭 타입, 제네릭 메서드에서는 사용할 수 없다.
### 타입 매개변수가 꼭 필요한 경우
- 와일드카드는 제네릭을 정의할 때 사용하는 것이 아니다. 타입 인자가 전달된 제네릭 타입을 활용할 때 사용한다.
- 제네릭 타입이나 제네릭 메서드가 꼭 필요한 상황이면 `<T>`를 사용하고, 그렇지 않은 상황이면 와일드 카드를 사용하는 것을 권장한다.
```java
Box<T extends Animal> box //로 지정하면 타입 추론에 따라 Animal의 자식들로 사용가능
Box<? extends Animal> box //로 지정하면 무조건 Animal타입으로 사용
```
## 타입 이레이저
### 타입 이레이저
- 제네릭은 자바 컴파일 단계에서만 사용되고, 컴파일 이후에는 제네릭 정보가 삭제된다. 제네릭에 사용한 타입 매개변수가 모두 사라지는 것이다.
#### 한계
- `param instanceof T` and `return new T()` 불가능
## 문제와 풀이2
## 정리
****
# 컬렉션 프레임워크 - ArrayList
## 배열의 특징1 - 배열과 인덱스
### 배열 인덱스 찾기 공식
- `배열의 시작 참조 + (자료의 크기 * 인덱스 위치)`
## 빅오(O) 표기법
### 빅오(Big O) 표기법
- 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식이다.
- 알고리즘이 처리해야 할 데이터의 양이 증가할 때, 그 알고리즘이 얼마나 빠르게 실행되는지 나타낸다.
#### O(1)
- 상수 시간
	- 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정한다.
- 예) 배열의 인덱스를 사용하는 경우
#### O(n)
- 선형 시간
	- 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가한다.
- 예) 배열의 검색, 배열의 모든 요소를 순회하는 경우
#### O(n^2)
- 제곱 시간
	- 알고리즘의 실행 시간이 입력 데이터의 크기의 제곱에 비례하여 증가한다.
- 예) 보통 이중 루프를 사용하는 알고리즘에서 나타난다.
#### O(log n)
- 로그 시간
	- 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
- 예) 이진 탐색
#### O(n log n)
- 선형 로그 시간
- 예) 많은 효율적인 정렬 알고리즘들
## 배열의 특징2 - 데이터 추가
## 직접 구현하는 배열 리스트1 - 시작
## 직접 구현하는 배열 리스트2 - 동적 배열
## 직접 구현하는 배열 리스트3 - 기능 추가
## 직접 구현하는 배열 리스트4 - 제네릭1
## 직접 구현하는 배열 리스트4 - 제네릭2
****
# 컬렉션 프레임워크 - LinkedList
## 노드와 연결1
## 노드와 연결2
## 노드와 연결3
## 직접 구현하는 연결 리스트1 - 시작
## 직접 구현하는 연결 리스트2 - 추가와 삭제1
## 직접 구현하는 연결 리스트3 - 추가와 삭제2

### 배열리스트 vs 연결 리스트 사용
- 데이터를 조회할 일이 많고, 뒷 부분에 데이터를 추가한다면 배열리스트가 보통 더 좋은 성능을 제공한다.
- 앞쪽의 데이터를 추가하거나 삭제할 일이 많다면 연결 리스트를 사용하는 것이 보통 더 좋은 성능을 제공한다.
## 직접 구현하는 연결 리스트4 - 제네릭 도입
****
# 컬렉션 프레임워크 - List
## 리스트 추상화1 - 인터페이스 도입
### List 자료 구조
- 순서가 있고, 중복을 허용하는 자료 구조
## 리스트 추상화2 - 의존관계 주입
## 리스트 추상화3 - 컴파일 타임, 런타임 의존관계
### 컴파일 타임 의존관계
#### 컴파일 타임(compile time)
- 코드 컴파일 시점을 뜻한다.
#### 의존관계
- 자바 컴파일러가 보는 의존관계이다. 클래스에 모든 의존관계가 다 나타난다.
### 런타임 의존관계
#### 런타임(runtime)
- 프로그램 실행 시점을 뜻한다.
#### 의존관계
- 실제 프로그램이 작동할 때 보이는 의존관계다. 주로 생성된 인스턴스와 그것을 참조하는 의존관계이다.
## 직접 구현한 리스트의 성능 비교
### 시간 복잡도와 실제 성능
- 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받는다.
- 배열은 메모리상 에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.
- LinkedList는 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느릴 수 있다.
### 배열 리스트 vs 연결 리스트
- 대부분의 경우 배열 리스트가 성능상 유리하다. 이런 이유로 실무에서는 주로 배열 리스트를 기본으로 사용한다.
- 만약 데이터를 앞쪽에서 자주 추가하거나 삭제할 일이 있다면 연결 리스트를 고려하자.
## 자바 리스트
### 자바 ArrayList
#### 특징
- 배열을 사용해서 데이터를 관리한다.
- 기본 `CAPACITY`는 10이다.
	- `CAPACITY`를 넘어가면 배열을 50% 증가한다.
- 메모리 고속 복사 연산을 사용한다.
	- 배열의 요소 이동은 시스템 레벨에서 최적화된 메모리 고속 복사 연산을 사용해서 비교적 빠르게 수행된다. `System.arraycopy()`사용
### 자바 LinkedList
#### 특징
- 이중 연결 리스트 구조
- 첫 번째 노드와 마지막 노드 둘다 참조
## 자바 리스트의 성능 비교
## 문제와 풀이1
## 문제와 풀이2
****
# 컬렉션 프레임워크 - 해시(Hash)
## 리스트(List) vs 세트(Set)
### 리스트(List)
#### 정의
- 리스트는 요소들의 순차적인 컬렉션이다. 요소들은 특정 순서를 가지며, 같은 요소가 여러 번 나타날 수 있다.
#### 특징
##### 순서 유지
- 리스트에 추가된 요소는 특정한 순서를 유지한다. 이 순서는 요소가 추가된 순서를 반영할 수 있다.
##### 중복 허용
- 리스트는 동일한 값이나 객체의 중복을 허용한다. 예를 들어, 같은 숫자나 문자열을 리스트 안에 여러 번 저장할 수 있다.
##### 인덱스 접근
- 리스트의 각 요소는 인덱스를 통해 접근할 수 있다. 이 인덱스는 보통 0부터 시작한다.
#### 용도
- 순서가 중요하거나 중복된 요소를 허용해야 하는 경우에 주로 사용된다.
### Set(세트, 셋)
#### 정의
- 세트(셋)는 유일한 요소들의 컬렉션이다. 참고로 세트보다는 셋으로 많이 불린다.
#### 특징
##### 유일성
- 셋에는 중복된 요소가 존재하지 않는다. 셋에 요소를 추가할 때, 이미 존재하는 요소면 무시된다.
##### 순서 미보장
- 대부분의 셋 구현에서는 요소들의 순서를 보장하지 않는다. 즉 요소를 출력할 때 입력 순서와 다를 수 있다.
##### 빠른 검색
- 셋은 요소의 유무를 빠르게 확인할 수 있또록 최적화되어 있다.이는 데이터의 중복을 방지하고 빠른 조회를 가능하게 한다.
#### 용도
- 중복을 허용하지 않고, 요소의 유무만 중요한 경우에 사용된다.
## 직접 구현하는 Set0 - 시작
## 해시 알고리즘1 - 시작
## 해시 알고리즘2 - index 사용
## 해시 알고리즘3 - 메모리 낭비
## 해시 알고리즘4 - 나머지 연산
### 해시 인덱스
- 배열의 인덱스로 사용할 수 있도록 원래의 값을 계산한 인덱스를 해시 인덱스(hashIndexl)라 한다.
## 해시 알고리즘5 - 해시 충돌 설명
## 해시 알고리즘6 - 해시 충돌 구현
****
# 컬렉션 프레임워크 - HashSet
## 직접 구현하는 Set1 - MyHashSetV1
## 문자열 해시 코드
### 용어 정리
#### 해시 함수(Hash Function)
- 임의의 길이의 데이터를 입력으로 받아,고정된 길이의 해시값(해시 코드)을 출력하는 함수이다.
	- 여기서 의미하는 고정된 길이는 저장 공간의 크기를 뜻한다.
		- 예를 들어 `int`형 `1`,`100`은 둘다 4byte를 차지하는 고정된 길이는 뜻한다.
- 같은 데이터를 입력하면 항상 같은 해시코드가 출력된다.
- 다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다. 이것을 해시 충돌이라 한다.
#### 해시 코드(Hash Code)
- 데이터를 대표하는 값을 뜻한다. 보통 해시 함수를 통해 만들어진다.
#### 해시 인덱스(Hash Index)
- 데이터의 저장 위치를 결정하는데, 주로 해시 코드를 사용해서 만든다.
- 보통 해시 코드의 결과에 배열의 크기를 나누어 구한다.
## 자바의 hashCode()
## 직접 구현하는 Set2 - MyHashSetV2
## 직접 구현하는 Set3 - 직접 만든 객체 보관
## equals, hashCode의 중요성1
## equals, hashCode의 중요성2
## 직접 구현하는 Set4 - 제네릭과 인터페이스 도입
****
# 컬렉션 프레임워크 - Set
## 자바가 제공하는 Set1 - HashSet, LinkedHashSet
### HashSet
#### 구현
- 해시 자료 구조를 사용해서 요소를 저장한다.
#### 순서
- 요소들은 특정한 순서 없이 저장된다. 즉 요소를 추가한 순서를 보장하지 않는다.
#### 시간 복잡도
- `HashSet`의 주요 연산(추가, 삭제, 검색)은 평균적으로 `O(1)`시간 복잡도를 가진다.
#### 용도
- 데이터의 유일성만 중요하고, 순서가 중요하지 않은 경우에 적합하다.
### LinkedHashSet
#### 구현
- `HashSet`에 연결 리스트를 추가해서 요소들의 순서를 유지한다.
#### 순서
- 요소들은 추가된 순서대로 유지된다. 즉 순서대로 조회시 요소들이 추가된 순서대로 반환된다.
#### 시간 복잡도
- `HashSet`과 마찬가지로 주요 연산에 대해 평균`O(1)`시간 복잡도를 가진다.
#### 용도
- 데이터의 유일성과 함께 삽입 순서를 유지해야 할 때 적합하다.
#### 참고
- 연결 링크를 유지해야 하기 때문에 `HashSet`보다는 조금 더 무겁다.
## 자바가 제공하는 Set2 - TreeSet
### TreeSet
#### 구현
- `TreeSet`은 이진 탐색 트리를 개선한 레드-블랙 트리를 내부에서 사용한다.
#### 순서
- 요소들은 정렬된 순서로 저장된다. 순서의 기준은 비교자(Comparator)로 변경할 수 있다.
#### 시간 복잡도
- 주요 연산들은 `O(log n)`의 시간 복잡도를 가진다. 따라서 `HashSet`보다는 느리다.
#### 용도
- 데이터들을 정렬된 순서로 유지하면서 집합의 특성을 유지해야 할 때 사용한다. 예를 들어, 범위 검색이나 정렬된 데이터가 필요한 경우에 유용하다. 참고로 입력된 순서가 아니라 데이터 값의 순서이다. 예를 들어 3, 1, 2를 순서대로 입력해도 1, 2, 3 순서로 출력된다.
## 자바가 제공하는 Set3 - 예제
## 자바가 제공하는 Set4 - 최적화
### 최적화
- 해시 기반 자료 구조를 사용하는 경우 통계적으로 입력한 데이터의 수가 배열의 크기를 75% 정도 넘어가면 해시 인덱스가 자주 충돌한다. 따라서 75%가 넘어가면 성능이 떨어지기 시작한다.
	- 해시 충돌로 같은 해시 인덱스에 들어간 데이터를 검색하려면 모두 탐색해야 한다. 따라서 성능이 O(n)으로 좋지 않다.
- 하지만 데이터가 동적으로 계속 추가되기 때문에 적절한 배열의 크기를 정하는 것은 어렵다.
- 자바의 `HashSet`은 데이터의 양이 배열 크기의 75% 넘어가면 배열의 크기를 2배로 늘리고 2배 늘어난 크기를 기준으로 모든 요소에 해시 인덱스를 다시 적용한다.
	- 해시 인덱스를 다시 적용하는 시간이 걸리지만, 결과적으로 해시 충돌이 줄어든다.
- 자바 `HashSet`의 기본 크기는 `16`이다.
## 문제와 풀이1
## 문제와 풀이2
****
# 컬렉션 프레임워크 - Map, Stack, Queue
## 컬렉션 프레임워크 - Map 소개1
### Map
- 키-값의 쌍을 저장하는 자료구조
- 키는 맵 내에서 유일해야 한다. 그리고 키를 통해 값을 빠르게 검색할 수 있다.
- 키는 중복될 수 없지만, 값은 중복될 수 있다.
- `Map`은 순서를 유지하지 않는다.
## 컬렉션 프레임워크 - Map 소개2
## 컬렉션 프레임워크 - Map 구현체
### HashMap
#### 구조
- 해시를 사용해서 요소를 저장한다. 키(Key)값은 해시 함수를 통해 해시 코드로 변환되고, 이 해시 코드는 데이터를 저장하고 검색하는 데 사용된다.
#### 특징
- 삽입, 삭제, 검색 작업은 해시 자료 구조를 사용하므로 일반적으로 상수 시간`O(1)`의 복잡도를 가진다.
#### 순서
- 순서를 보장하지 않는다.
### LinkedHashMap
#### 구조
- `HashMap`과 유사하지만, 연결 리스트를 사용하여 삽입 순서 또는 최근 접근 순서에 따라 요소를 유지한다.
#### 특징
- 입력 순서에 따라 순회가 가능하다. 입력 순서를 링크로 유지해야 하므로 조금 더 무겁다.
#### 성능
- 대부분의 작업은 `O(1)`의 시간 복잡도를 가진다.
#### 순서
- 입력 순서를 보장한다.
### TreeMap
#### 구조
- 레드-블랙 트리를 기반으로 한 구현이다.
#### 특징
- 모든 키는 자연 순서 또는 생성자에 제공된 `Comparator`에 의해 정렬된다.
#### 성능
- `get`, `put`, `remove`와 같은 주요 작업들은`O(log n)`의 시간 복잡도를 가진다.
#### 순서
- 키는 정렬된 순서로 저장된다.
## 스택 자료 구조
### 주의 - Stack 클래스는 사용하지 말자
- 자바의 `Stack`클래스는 내부에서 `Vector`라는 자료 구조를 사용한다. 이 자료 구조는 자바 1.0에 개발되었는데 지금은 사용되지 않고 하위 호환을 위해 존재한다. 지금은 더 빠른 좋은 자료 구조가 많다. 따라서 `Vector`를 사용하는 `Stack`도 사용하지 않는 것을 권장한다. 대신에 이후에 설명할 `Deque`를 사용하는 것이 좋다.
## 큐 자료 구조
## Deque 자료 구조
## Deque와 Stack, Queue
## 문제와 풀이1 - Map1
## 문제와 풀이2 - Map2
## 문제와 풀이3 - Stack
## 문제와 풀이4 - Queue
****
# 컬렉션 프레임워크 - 순회, 정렬, 전체 정리
## 순회1 - 직접 구현하는 Iterable, Iterator
## 순회2 - 향상된 for문
## 순회3 - 자바가 제공하는 Iterable, Iterator
## 정렬1 - Comparable, Comparator
## 정렬2 - Comparable, Comparator
## 정렬3 - Comparable, Comparator
### Collections.sort(list) vs list.sort(null)
- 둘은 같은 결과를 가진다.
- 하지만 이 객체 스스로 정렬 메서드를 가지고 있는 `list.sort()`사용을 더 권장한다.
## 컬렉션 유틸
- Arrays.asList() 가변 리스트
- List.of() 불변 리스트
## 컬렉션 프레임워크 전체 정리
****
# 다음으로

****