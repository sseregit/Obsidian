==Netflix-Eureka는 서비스 디스커버리로써의 역할을 한다. @LoadBalanced가 로드 밸런스 역할을 한다. 그리고 가장 중요한것은 한번 요청시에 그 해당 인스턴스들을 캐싱하고 있기때문에 유레카 서버가 죽더라도 캐싱되어있는 인스턴스를 사용한다. 그렇지만 그 캐싱되어 있는 인스턴스가 죽으면 시간초과 및 재시도 등의 복원 메커니즘을 사용해야 한다==
# 1. 스프링 이니셜라이저로 만든 스프링 부트 애플리케이션을 넷플릭스 유레카 서버로 전환하려면 어떻게 해야 하는가?
- `spring-cloud-starter-netflix-eureka-server`의존성을 추가한다.
- 애플리케이션 클래스에 `@EnableEurekaServer` 애너테이션을 붙이고
- 개발용 단일 인스턴스로 실행하거나 운영용 고가용성 클러스터로 실행할 수 있도록 필요한 설정을 포함해야 한다.
# 2. 스프링 부트 기반 마이크로서비스가 시작하는 동안 자동으로 자신을 넷플릭스 유레카에 등록하게 하려면 어떻게 해야 하는가?
- `spring-cloud-starter-netflix-eureka-client`의존성을 추가하고, `eureka.client.serviceUrl.defualtZone`속성을 사용하여 유레카 서버의 위치를 설정해야 한다.
# 3. 스프링 부트 기반 마이크로서비스가 넷플릭스 유레카 서버에 등록된 다른 마이크로서비스를 호출할 수 있게 하려면 어떻게 해야 하는가?
- 예를 들어 `@LoadBalanced` 애너테이션이 붙은 `WebClient`인스턴스를 사용하여 클라이언트가 로드 밸런서를 인식하도록 설정해야 한다. 서비스 디스커버리를 사용할때는 호출하려는 서비스의 `spring.application.name`값과 URI의 호스트 부분이 일치해야 한다.
# 4. 마이크로 서비스 A의 인스턴스 1개와 마이크로서비스 B의 인스턴스 2개와 함께 넷플릭스 유레카 서버가 실행 중이라고 가정한다. 모든 마이크로서비스 인스턴스는 자신을 넷플릭스 유레카 서버에 등록한다. 마이크로서비스 A는 유레카 서버에서 얻은 정보를 바탕으로 마이크로서비스 B에 HTTP 요청을 보낸다. 다음과 같은 상황이 발생하면 어떻게 될까?
```
1. 넷플릭스 유레카 서버 종료
2. 마이크로서비스 B의 인스턴스 중 하나 종료
3. 새로운 마이크로서비스 A 인스턴스 시작
4. 새로운 마이크로서비스 B 인스턴스 시작
5. 넷플릭스 유레카 서버 다시 시작
```
- =`Eureka`, `Ribbon`, `Spring Cloud`가 제공하는 복원력 덕분=에 모든 것이 결국 정리된다. `Eureka`서버와 그 클라이언트 사이에는 레지스트리 데이터가 복제되며, `Eureka`서버가 재시작되면 해당 레지스트리 데이터가 적절히 갱신된다.
- 서비스 A의 두 인스턴스는 서비스 B의 두 인스턴스를 사용할 수 있게된다.