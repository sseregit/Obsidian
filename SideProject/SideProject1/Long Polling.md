[What is HTTP Long Polling — and is it still relevant today?](https://ably.com/topic/long-polling)

클라이언트와 서버 간의 실시간 통신을 HTTP를 통해 구현하는 기법

서버에 새로운 데이터가 생길 때까지 연결을 열린 상태로 유지하여, 클라이언트가 즉시 업데이트를 받을 수 있도록 한다.

WebSocket이 표준화되기 이전에 실용적인 해결책으로 등장.

오늘날에도 특히 제약이 있는 환경이나 레거시 시스템에서는 여전히 유효하다.

클라이언트가 요청하고 서버가 응답하는 단방향 기반의 웹 플랫폼 위에서 양방향 애플리케이션을 구축하는 문제를 해결해준다.

works start
클라이언트가 서버로 GET 요청을 보낸다. 
	특정 응답을 요청하는 것이 아니라, 준비되는 대로 어떤 응답이든 받겠다는 의미

시간이 흐른다.
	HTTP 타임아웃은 Keep-Alive 헤더를 사용하여 조정할 수 있다. 이를 활용해 매우 길거나 무기한에 가까운 타임아웃을 설정하여, 서버가 즉시 응답하지 않더라도 요청이 열린 상태로 유지되도록 한다.

서버가 응답한다.
	서버에 보낼 데이터가 생기면 응답과 함께 연결을 종료한다.

사이클의 반복
works end

HTTP 롱 폴링의 성공할 수 있었던 핵심은, 클라이언트 측에서 기본 웹의 구조를 전혀 변경하지 않는다는 점이다.

대부분의 부담은 서버 측에 있다. 특히 수십만 개의 연결 상태를 관리하는 것은 자원을 많이 소모한다.

롱 폴링의 뚜렷한 한계 start
각 열린 요청은 서버 자원을 점유한다.
	비동기 환경에서도 수천에서 수백만 개에 이르는 롱 폴링 연결을 동시에 관리하려면 메모리와 연산 자원이 크게 증가한다.

타임아웃과 재시도가 병목이 된다.
	시스템이 높은 부하를 받을 경우, 응답 지연과 재시도 폭주가 백엔드 시스템을 마비시킬 수 있다.

인프라의 예측 가능한 확장이 어려워진다
	지속적인 연결을 위한 프로토콜(WebSocket 등)과 달리, 롱 폴링은 멀티플렉싱이나 연결 재사용을 지원하지 않아 자원 활용이 비효율적이다.
롱 폴링의 뚜렷한 한계 end


