# 강의 소개와 자료
****
# 제네릭 - Generic1
## 제네릭이 필요한 이유
## 다형성을 통한 중복 해결 시도
## 제네릭 적용
## 제네릭 용어와 관례

### 제네릭의 핵심
- **사용할 타입을 미리 결정하지 않는다는점 이다.**
- 클래스 내부에서 사용하는 타입을 클래스를 정의하는 시점에 결정하는 것이 아니라 실제 사용하는 생성 시점에 타입을 결정하는 것이다.
- 메서드는 **매개변수**에 **인자**를 전달해서 사용할 값을 결정한다.
- 제네릭 클래스는 **타입 매개 변수**에 **타입 인자**를 전달해서 사용할 타입을 결정한다.
### 용어 정리
#### 제네릭(Generic)
#### 제네릭 타입(Generic Type)
#### 타입 매개 변수(Type Parameter)
- `GenericBox<T>`
- `T`를 뜻한다.
#### 타입 인자(Type Argument)
- `GenericBox<Integer>`
- `Integer`를 뜻한다.
### 제네릭 명명 관례
- 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례
#### 주로 사용하는 키워드
- E - Element
- K - Key
- N - Number
- T - Type
- V - Value
- S,U,V etc. - 2nd, 3rd, 4th types

### Row Type
`GenericBox a = new GenericBox()`
- 타입 인자를 지정하지 않은 경우 로 타입 또는 원시 타입이라 한다.
## 제네릭 활용 예제
## 문제와 풀이1
****
# 제네릭 - Generic2
## 타입 매개변수 제한1 - 시작
## 타입 매개변수 제한2 - 다형성 시도
## 타입 매개변수 제한3 - 제네릭 도입과 실패
## 타입 매개변수 제한4 - 타입 매개변수 제한
## 제네릭 메서드
## 제네릭 메서드 활용
## 와일드카드1
### 참고
와일드 카드는 제네릭 타입이나, 제네릭 메서드를 선언하는 것이 아니다. 와일드 카드는 이미 만들어진 제네릭 타입을 활용할 때 사용한다.
### 비제한 와일드 카드
- 와일드 카드는 제네릭 타입이나 제네릭 메서드를 정의할 때 사용하는 것이 아니다.`Box<Dog>`, `Box<Cat>`처럼 타입 인자가 정해진 제네릭 타입을 전달 받아서 활용할 때 사용한다.
- 와일드카드인 `?`는 모든 타입을 다 받을 수 있다는 뜻이다.
	- `? == <? extends Object>`
- `?`만 사용해서 제한 없이 모든 타입을 다 받을 수 있는 와일드카드를 **비제한 와일드카드**라 한다.
### 제네릭 메서드 vs 와일드카드
- 제네릭 타입이나 제네릭 메서드를 정의하는게 꼭 필요한 상황이 아니라면, 더 단순한 와일드카드 사용을 권장한다.
## 와일드카드2
### 상한 와일드카드
- `? extends Animal`
	- Animal 이하
### 하한 와일드카드
- `? super Animal`
	- Animal 이상
- 제네릭 타입, 제네릭 메서드에서는 사용할 수 없다.
### 타입 매개변수가 꼭 필요한 경우
- 와일드카드는 제네릭을 정의할 때 사용하는 것이 아니다. 타입 인자가 전달된 제네릭 타입을 활용할 때 사용한다.
- 제네릭 타입이나 제네릭 메서드가 꼭 필요한 상황이면 `<T>`를 사용하고, 그렇지 않은 상황이면 와일드 카드를 사용하는 것을 권장한다.
```java
Box<T extends Animal> box //로 지정하면 타입 추론에 따라 Animal의 자식들로 사용가능
Box<? extends Animal> box //로 지정하면 무조건 Animal타입으로 사용
```
## 타입 이레이저
### 타입 이레이저
- 제네릭은 자바 컴파일 단계에서만 사용되고, 컴파일 이후에는 제네릭 정보가 삭제된다. 제네릭에 사용한 타입 매개변수가 모두 사라지는 것이다.
#### 한계
- `param instanceof T` and `return new T()` 불가능
## 문제와 풀이2
## 정리
****
# 컬렉션 프레임워크 - ArrayList
## 배열의 특징1 - 배열과 인덱스
### 배열 인덱스 찾기 공식
- `배열의 시작 참조 + (자료의 크기 * 인덱스 위치)`
## 빅오(O) 표기법
### 빅오(Big O) 표기법
- 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식이다.
- 알고리즘이 처리해야 할 데이터의 양이 증가할 때, 그 알고리즘이 얼마나 빠르게 실행되는지 나타낸다.
#### O(1)
- 상수 시간
	- 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정한다.
- 예) 배열의 인덱스를 사용하는 경우
#### O(n)
- 선형 시간
	- 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가한다.
- 예) 배열의 검색, 배열의 모든 요소를 순회하는 경우
#### O(n^2)
- 제곱 시간
	- 알고리즘의 실행 시간이 입력 데이터의 크기의 제곱에 비례하여 증가한다.
- 예) 보통 이중 루프를 사용하는 알고리즘에서 나타난다.
#### O(log n)
- 로그 시간
	- 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
- 예) 이진 탐색
#### O(n log n)
- 선형 로그 시간
- 예) 많은 효율적인 정렬 알고리즘들
## 배열의 특징2 - 데이터 추가
## 직접 구현하는 배열 리스트1 - 시작
## 직접 구현하는 배열 리스트2 - 동적 배열
## 직접 구현하는 배열 리스트3 - 기능 추가
## 직접 구현하는 배열 리스트4 - 제네릭1
## 직접 구현하는 배열 리스트4 - 제네릭2
****
# 컬렉션 프레임워크 - LinkedList
## 노드와 연결1
## 노드와 연결2
## 노드와 연결3
****
# 컬렉션 프레임워크 - List

****
# 컬렉션 프레임워크 - 해시(Hash)

****
# 컬렉션 프레임워크 - HashSet

****
# 컬렉션 프레임워크 - Set

****
# 컬렉션 프레임워크 - Map, Stack, Queue

****
# 컬렉션 프레임워크 - 순회, 정렬, 전체 정리

****
# 다음으로

****