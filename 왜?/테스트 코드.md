# 목적
1. 회귀 버그 방지
2. 유연한 설계로 개선
	1. 테스트를 쉽게 만들어준다.
	2. 테스트를 결정적이게 만들어준다.

# TDD의 장단점
## 장점
1. 깨지는 테스트를 먼저 작성해야하기 때문에, 인터페이스를 먼저 만드는 것이 강제된다.
2. 장기적인 관점에서 개발 비용 감소
## 단점
1. 초기 개발 비용
2. 난이도

# 필요성
1. Regression 회귀 버그 방지
2. 좋은 아키텍처를 유도한다.
```text
S 단일 책임 원칙
- 테스트는 명료하고 간단하게 작성해야하기 때문에, 단일 책임 원칙을 지키게된다.
O 개방 폐쇄 원칙
- 테스트 컴포넌트와 프로덕션 컴포넌트를 나눠 작업하게 되고 필요에 따라 이 컴포넌트를 자유자재로 탈부착이 간으하게 개발됨.
L 리스코프 치환 원칙
- 이상적으로 테스트는 모든 케이스에 커버하고 있으므로, 서브 클래스에 대한 치환 여부를 테스트가 알아서 판단해줌
I 인터페이스 분리 원칙
- 테스트는 그 자체로 인터페이스를 직접 사용해볼 수 있는 환경. 불필요한 의존성을 실제로 확인할 수 있는 샌드박스
D 의존성 역전 원칙
- 가짜 객체를 이용하여 테스트를 작성하려면, 의존성이 역전되어 있어야 하는 경우가 생김
```

# 테스트의 3분류
small(소형) 테스트
- 단일 서버, 단일 프로세스, 단일 스레드, 디스크 I/O 사용해선 안됨, Blocking call 허용 안됨

medium(중형) 테스트
- 단일 서버, 멀티 프로세스, 멀티 스레드 (h2같은 테스트 DB를 사용할 수 있다.)

large(대형) 테스트
- 멀티 서버, End to end 테스트

# 테스트에 필요한 개념
SUT (System under test) 
- 테스트 하려는 대상

BDD 
- (given-when-then), (Arrange - Act - Asset)

상호 작용 테스트(Interaction test)
- 대상 함수의 구현을 호출하지 않으면서 그 함수가 어떻게 호출되는지 검증하는 기법
	- 상호 작용 테스트보다는 상태를 테스트하는게 좋다.

상태 기반 검증(state-based-verification)

행위 기반 검증(behaviour-based-verification)

테스트 픽스처
- 테스트에 필요한 자원을 생성하는 것

## test double = 테스트 대역
Dummy
- 아무런 동작도 하지 않고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체

Fake
- Local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체, 자체적인 로직이 있다는게 특징

Stub
- 미리 준비된 값을 출력하는 객체

Mock
- 메소드 호출을 확인하기 위한 객체, 자가 검증 능력을 갖춤, 사실상 테스트 더블과 동일한 의미

Spy
- 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체

# FIRST 원칙
Fast 
- 테스트는 빨라야한다.
Independent 
- 테스트는 독립적이어야 한다.
Repeatable 
- 테스트는 반복 수행해도 결과가 같아야 한다.
Self-validating 
- 테스트를 수행하면 시스템의 성공/실패 알 수 있어야 한다.
Timely 
- 테스트는 적시에(코드 구현 전)작성되어야 한다

# 왜?
테스트 코드 작성은 회귀 버그를 방지하고 좋은 아키텍처 설계를 유도한다.