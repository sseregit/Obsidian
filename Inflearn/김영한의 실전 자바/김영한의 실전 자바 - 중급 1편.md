# Object 클래스

## java.lang 패키지 소개

### java.lang
- 자바 언어를 이루는 가장 기본이 되는 클래스들을 보관하는 패키지
#### 대표적인 클래스들
##### Object
- 모든 자바 객체의 부모 클래스
##### String
- 문자열
##### Integer, Long, Double
- 래퍼 타입, 기본형 데이터 타입을 객체로 만든 것
##### Class
- 클래스 메타 정보
##### System
- 시스템과 관련된 기본 기능들을 제공

## Object 클래스

### 묵시적(Implicit) vs 명시적(Explicit)
#### 묵시적
- 개발자가 코드에 직접 기술하지 않아도 시스템 또는 컴파일러에 의해 자동으로 수행되는 것을 의미
#### 명시적
- 개발자가 코드에 직접 기술해서 작동하는 것을 의미

### 자바에서 Object 클래스가 최상위 부모 클래스인 이유
#### 공통 기능 제공
#### 다형성의 기본 구현

## Object 다형성

## Object 배열

## toString()

### 객체의 참조값 직접 출력
```java
int i = System.identityHashCode(object);  
System.out.println("i = " + i);  
String refValue = Integer.toHexString(i);  
System.out.println("refValue = " + refValue);
```

## Object와 OCP

### 추상적
- 단순히 추상 클래스나 인터페이스만 뜻하는 것은 아니다. 부모타입으로 올라갈 수록 개념은 더 추상적이게 되고, 하위 타입으로 내려갈 수록 개념은 더 구체적이게 된다.
### 정적 의존관계 vs 동적 의존관계
#### 정적 의존관계
- 컴파일 시간에 결정되며, 주로 클래스 간의 관계를 의미한다.
#### 동적 의존관계
- 프로그램을 실행하는 런타임에 확인할 수 있는 의존관계이다.
## equals() - 1. 동일성과 동등성
### 동일성(Identity)
- `==`연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
### 동등성(Equality)
- `equals()`메서드를 사용하여 두 객체가 논리적으로 동등한지 확인
## equals() - 2. 구현

### equals() 메서드를 구현할 때 지켜야 하는 규칙
#### 반사성(Reflexivity)
- 객체는 자기 자신과 동등해야 한다.(`x.equals(x)`는 항상 `true`)
#### 대칭성(Symmetry)
- 두 객체가 서로에 대해 동일하다고 판단하면, 이는 양방향으로 동일해야 한다.(`x.equals(y)` 가 `true`이면 `y.equals(x)`도 `true`)
#### 추이성(Transitivity)
- 만약 한 객체가 두 번째 객체와 동일하고,두 번째 객체가 세 번째 객체와 동일하다면, 첫 번째 객체는 세번째 객체와도 동일해야 한다.
#### 일관성(Consistency)
- 두 객체의 상태가 변경되지 않는 한,`equals()` 메소드는 항상 동일한 값을 반환해야 한다.
#### null에 대한 비교
- 모든 객체는 `null`과 비교했을 때 false를 반환해야 한다.

### 정리
- 동일성 비교가 항상 필요한 것은 아니다. 동일성 비교가 필요한 경우에만 `equals()`를 재정의하면 된다.
- `equals()`와`hashCode()`는 보통 함께 사용된다.

## 문제와 풀이

## 정리
### Object의 나머지 메서드
#### clone()
- 객체를 복사할 때 사용한다. 잘 사용하지 않으므로 다루지 않는다.
#### hashCode()
- `equals()`와`hashCode()`는 종종 함께 사용된다. `hashCode()`는 뒤에 컬렉션 프레임워크에서 자세히 설명한다.
#### getClass()
- 뒤에 `Class`에서 설명한다
#### notify(), notifyAll(), wait()
- 멀티스레드용 메서드이다. 멀티스레드에서 다룬다.
****
# 불변 객체
## 기본형과 참조형의 공유
### 기본형
- 하나의 값을 여러 변수에서 절대로 공유하지 않는다.
### 참조형
- 하나의 객체를 참조값을 통해 여러 변수에서 공유할 수 있다.
## 공유 참조와 사이드 이펙트
### 사이드 이펙트(Side Effect)
- 프로그래밍에서 어떤 계산이 주된 작업 외에 추가적인 부수 효과를 일으키는 것을 말한다.
## 불변 객체 - 도입
## 불변 객체 - 예제
## 불변 객체 - 값 변경

## 문제와 풀이

### 참고 - withXxx()
- 불변 객체에서 값을 변경하는 경우 "with"로 시작하는 경우가 많다.
- 관례처럼 사용되고 원본 객체의 상태가 그대로 유지됨으로 강조하면서 변경사항을 새 복사본에 포함하는 과정을 간결하게 표현한다.
## 정리
### 클래스를 불변으로 설계하는 이유
- 캐시 안정성
- 멀티 쓰레드 안전성
- 엔티티의 값 타입
****
# String 클래스

## String 클래스 - 기본

## String 클래스 - 비교

### 문자열 리터럴, 문자열 풀
- `String str = "hello"`와 같이 문자열 리터럴을 사용하는 경우 **자바는 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용한다.**
- 자바가 실행되는 시점에 클래스에 문자열 리터럴이 있으면 문자열 풀에 `String`인스턴스를 미리 만들어둔다. 이때 같은 문자열이 있으면 만들지 않는다.
#### 문자열 풀
- 문자열 풀은 힙 영역을 사용한다.
- 문자열 풀에서 문자를 찾을 때는 해시 알고리즘을 사용하기 때문에 매우 빠른속도로 원하는 `String` 인스턴스를 찾을 수 있다.

### 풀(Pool)
- 자원이 모여있는 곳을 의미한다. 프로그래밍에서 풀(Pool)은 공용 자원을 모아둔 곳을 뜻한다.
## String 클래스 - 불변 객체
## String 클래스 - 주요 메서드1
## String 클래스 - 주요 메서드2
## StringBuilder - 가변 String
## String 최적화

### 정리
- 문자열을 합칠 때 대부분의 경우 최적화가 되므로 `+`연산을 사용하면 된다.
#### StringBuilder를 직접 사용하는 것이 더 좋은 경우
- 반복문에서 반복해서 문자를 연결할 때
- 조건문을 통해 동적으로 문자열을 조합할 때
- 복잡한 문자열을 특정 부분을 변경해야 할 때
- 매우 긴 대용량 문자열을 다룰 때

### StringBuilder vs StringBuffer
#### StringBuffer
- 내부에 동기화가 되어 있어서, 멀티 스레드 상황에 안전하지만 동기화 오버헤드로 인해 성능이 느리다.
#### StringBuilder
- 멀티 스레드에 상황에 안전하지 않지만 동기화 오버헤드가 없으므로 속도가 빠르다.
## 메서드 체인닝 - Method Chaining

## 문제와 풀이1
## 문제와 풀이2
## 정리
****
# 래퍼, Class 클래스
## 래퍼 클래스 - 기본형의 한계1
### 기본형의 한계
#### 객체가 아님
#### null 값을 가질 수 없음
## 래퍼 클래스 - 기본형의 한계2
## 래퍼 클래스 - 자바 래퍼 클래스
### 자바가 제공하는 기본 래퍼 클래스의 특징
#### 불변이다.
#### `equlas`로 비교해야 한다.
## 래퍼 클래스 - 오토 박싱
### 오토 박싱 - Autoboxing
- Primitive <-> Wrapper 
## 래퍼 클래스 - 주요 메서드와 성능
### 기본형, 래퍼 클래스 어떤 것을 사용?
- CPU 연산을 아주 많이 수행하는 특수한 경우이거나, 수만~수십만 이상 연속해서 연산을 수행해야 하는 경우라면 기본형을 사용해서 최적화를 고려하자.
- 그렇지 않은 일반적인 경우라면 코드를 유지보수하기 더 나은 것을 선택하면 된다.
### 유지보수 vs 최적화
- 유지보수하기 좋은 코드를 먼저 고민해야한다. 특히 최신 컴퓨터는 매우 빠르기 때문에 메모리 상에서 발생하는 연산을 몇 번 줄인다고해도 실질적인 도움이 되지 않는 경우가 많다.
## Class 클래스
### Class 클래스
#### 타입 정보 얻기
#### 리플렉션
#### 동적 로딩과 생성
#### 애노테이션 처리
## System 클래스
## Math, Random 클래스
## 문제와 풀이1
## 문제와 풀이2
## 정리
****
# 열거형 - ENUM
## 문자열과 타입 안전성1
### String 사용 시 타입 안정성 부족 문제
- 값의 제한 부족
- 컴파일 시 오류 감지 불가
## 문자열과 타입 안전성2
## 타입 안전 열거형 패턴
### 타입 안전 열거형 패턴(Type-Safe Enum Pattern)의 장점
#### 타입 안전성 향상
- 정해진 객체만 사용할 수 있기 때문에, 잘못된 값을 입력하는 문제를 근본적으로 방지할 수 있다.
#### 데이터 일관성
- 정해진 객체만 사용하므로 데이터의 일관성이 보장된다.
#### 제한된 인스턴스 생성
- 클래스는 사전에 정의된 몇 개의 인스턴스만 생성하고, 외부에서는 이 인스턴스들만 사용할 수 있도록 한다. 이를 통해 미리 정의된 값들만 사용하도록 보장한다.
#### 타입 안전성
- 이 패턴을 사용하면, 잘못된 값이 할당되거나 사용되는 것을 컴파일 시점에 방지할 수 있다.
## 열거형 - Enum Type
### 열거형(ENUM)의 장점
#### 타입 안전성 향상
- 열거형은 사전에 정의된 상수들로만 구성되므로, 유효하지 않은 값이 입력될 가능성이 없다. 이런 경우 컴파일 오류가 발생한다.
#### 간결성 및 일관성
- 열거형을 사용하면 코드가 더 간결하고 명확해지며, 데이터의 일관성이 보장된다.
#### 확장성
- 새로운 회원 등급을 타입을 추가하고 싶을 때, ENUM에 새로운 상수를 추가하기만 하면 된다.
## 열거형 - 주요 메서드
## 열거형 - 리팩토링1
## 열거형 - 리팩토링2
## 열거형 - 리팩토링3
## 문제와 풀이1
## 문제와 풀이2
## 정리
****
# 날짜와 시간
## 날짜와 시간 라이브러리가 필요한 이유
## 자바 날짜와 시간 라이브러리 소개
[자바 날짜와 시간 라이브러리 표](https://docs.oracle.com/javase/tutorial/datetime/iso/overview.html)
### LocalDate, LocalTime, LocalDateTime
- 앞에 `Local`의 의미
	- 세계 시간대를 고려하지 않아서 타임존이 적용되지 않기 때문이다.
	- 특정 지역의 날짜와 시간만 고려할 때 사용한다.
#### LocalDate
- 날짜만 표현 `2013-11-21`
#### LocalTime
- 시간만 표현 `08:20:30.213`
#### LocalDateTime
- LocalDate + LocalTime `2013-11-21T08:20:30.213`
### ZonedDateTime, OffsetDateTime
#### ZonedDateTime
- 시간대를 고려한 날짜와 시간을 표현하고 시간대를 표현하는 타임존이 포함된다`2013-11-21T08:20:30.213+9:00[Asia/Seoul]`
- 일광 절약 시간제가 적용된다.
#### OffsetDateTime
- 시간대를 고려한 날짜와 시간을 표현할때 사용하고 타임존이 없고 UTC로부터 시간대 차이인 고정된 오프셋만 포함한다. `2013-11-21T08:20:30.213+9:00`
### Instant
- UTC(협정 시계시)를 기준으로 하는, 시간의 한 지점을 나타낸다.
- 날짜와 시간을 나노초 정밀도로 표현하며, 1970년 1월 1일 0시 0분 0초(UTC)를 기준으로 경과한 시간으로 계산된다.
- Instant 내부에는 초 데이터만 들어있다.(나노초 포함)
### Period, Duration
#### 시간의 개념은 크게 2가지로 표현할 수 있다.
- 특정 시점의 시간(시각)
- 시간의 간격(기간)
#### Period
- 두 날짜 사이의 간격을 년, 월, 일 단위로 나타낸다.
#### Duration
- 두 시간 사이의 간격을 시, 분, 초(나노초) 단위로 나타낸다.
## 기본 날짜와 시간 - LocalDateTime

**모든 날짜 클래스는 불변이다.**
### isEquals() vs equals()
#### isEquals()
- 단순히 비교 대상이 시간적으로 같으면 `true`
	-  ex) 서울의 9시와 UTC의 0시는 시간적으로 같다.
#### equals()
- 객체의 타입, 타임존 등등 내부 데이터의 모든 구성요소가 같아야 `true`
	- ex) 서울의 9시와 UTC의 0시는 시간적으로 같지만 타임존 데이터가 다르다.
## 타임존 - ZonedDateTime
### ZonedDateTime vs OffsetDateTime
#### ZonedDateTime
- 구체적인 지역 시간대를 다룰 때 사용하며, 일광 절약 시간을 자동으로 처리할 수 있다. 사용자 지정 시간대에 따른 시간 계산이 필요할 때 적합하다.
#### OffsetDateTime
- UTC와의 시간 차이만을 나타낼 때 사용하며, 지역 시간대의 복잡성을 고려하지 않는다. 시간대 변환 없이 로그를 기록하고, 데이터를 저장하고 처리할 때 적합하다.
## 기계 중심의 시간 - Instant
### Instant의 특징
#### 장점
- 시간대 독립성
	- `Instant`는 UTC를 기준으로 하므로, 시간대에 영향을 받지 않는다. 이는 전세계 어디서나 동일한 시점을 가리키는데 유용하다.
- 고정된 기준점
	- 모든 `Instant`는 1970년 1월 1일 UTC를 기준으로 하기 때문에, 시간 계산 및 비교가 명확하고 일관된다.
#### 단점
- 사용자 친화적이지 않음
	- `Instant`는 기계적인 시간 처리에는 적합하지만, 사람이 읽고 이해하기에는 직관적이지 않다. 예를 들어 날짜와 시간을 계산하고 사용하는데 필요한 기능이 부족하다.
- 시간대 정보 부재
	- `Instant`에는 시간대 정보가 포함되어 있지 않아, 특정 지역의 날짜와 시간으로 변환하려면 추가적인 작업이 필요하다.

### 사용예
- 전 세계적인 시간 기준이 필요 시
- 시간대 변환없이 시간 계산 필요시
- 데이터 저장 및 교환
## 기간, 시간의 간격 - Duration, Period
## 날짜와 시간의 핵심 인터페이스
### TemporalAccessor
- 날짜와 시간을 읽기 위한 기본 인터페이스
- 특정 시점의 날짜와 시간 정보를 읽을 수 있는 최소한의 기능을 제공
###  Temporal
- `TemporalAccessor`의 하위 인터페이스로, 날짜와 시간을 조작(추가, 빼기등)하기 위한 기능을 제공한다. 이를 통해 날짜와 시간을 변경하거나 조정할 수 있다.
### TemporalAmount
- 시간의 간격(시간의 양, 기간)을 나타내며,날짜와 시간 객체에 적용하여 그 객체를 조정할 수 있다.예를 들어, 특정 날짜에 일정 기간을 더하거나 빼는 데 사용된다.

### 시간의 단위와 시간 필드
#### TemporalUnit <- - - - - ChronoUnit
- 날짜와 시간을 측정하는 단위를 나타내며, 주로 사용되는 구현체는 `java.time.temporal.ChronoUnit`열거형으로 구현되어 있다.
- `ChronoUnit`은 다양한 시간 단위를 제공한다
- 여기서 `Unit`이라는 뜻을 번역하면 단위이다. 따라서 시간의 단위 하나하나를 나타낸다.
#### TemporalField <- - - - - ChronoField
****
# 중첩 클래스, 내부 클래스1

****
# 중첩 클래스, 내부 클래스2

****
# 예외 처리1 - 이론

****
# 예외 처리2 - 실습

****
# 다음으로

****