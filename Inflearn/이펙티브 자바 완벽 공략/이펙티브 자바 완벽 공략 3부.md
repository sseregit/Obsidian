# 섹션 1. 이펙티브 자바 완벽 공략 3
## 강의 소개

****
# 섹션 2. 아이템 34. int 상수 대신 열거 타입을 사용하라.
## 아이템 34. 핵심 정리 1: 정수 열거 패턴의 단점
### 핵심 정리 1: 정수 열거 패턴의 단점
#### 정수 열거 패턴
- 자바에서 열거 타입을 지원하기 이전에는 "정수 상수"를 선언하여 열거 타입을 표현했다.
##### 단점
- **타입 안전**을 보장할 수 없다.
- 표현력이 좋치 않다.
- 프로그램이 깨지기 쉽다.
- 문자열로 출력하기 까다롭다.
- 모든 상수를 순회하는 방법도 마땅치 않다.
## 아이템 34. 핵심 정리 2: 열거 타입의 장점 1   
### 핵심 정리 2: 열거 타입(enum)의 장점
- 열거 타입 선언으로 만들어진 인스턴스는 싱글턴이다.
- 컴파일타임 **타입 안정성**을 제공한다.
- 열거 타입에 이름 공간을 있으니 (공간이 다른) 이름이 같은 상수도 공존할 수 있다.
- 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일 하지 않아도 된다.
- `toString`메서드는 출력하기 적절한 문자열을 제공한다.
## 아이템 34. 핵심 정리 3: 열거 타입의 장점 2
### 핵심 정리 3: 열거 타입(enum)의 장점
- 메서드나 필드를 추가하고 인터페이스를 구현할 수도 있다.
- `values`메서드를 사용해 정의되어 있는 모든 상수 배열을 사용할 수 있다.
- 열거 타입에서 상수를 제거한다면?
- 상수마다 동적이 달라져야 한다면?
- `valueOf(String)`메서드를 사용해 문자열을 열거 타입 상수로 변환할 수 있다.
- `fromString(String)`구현하기
## 아이템 34. 핵심 정리 4: 예제 살펴보기
## 아이템 34. 핵심 정리 5: 열거 타입의 제약
### 핵심 정리 4: 열거 타입(enum)의 제약
- 생성자에서 접근할 수 있는 것은 상수 변수 뿐이다.
	- 다른 상수에도 접근할 수 없다.
	- enum에서는 생성자가 호출되는 시점에는 정적인 필드들이 초기화 되지 않은 상태이다.
- 열거 타입 상수끼리 코드를 공유하기 어렵다.
	- 예) `PayrollDay`
- 코드를 수정 할 수 없는 기존 열거 타입에 상수별 동작을 넣을 때는 `switch`문이 좋은 선택이 될 수 있다.
	- 예) `Inverse`

****
# 섹션 3. 아이템 35. ordinal 메서드 대신 인스턴스 필드를 사용하라.
## 아이템 35. 핵심 정리
### 핵심 정리
- `Enum`은 상수가 정의되어 있는 위치를 반환하는 `ordinal`이라는 메서드를 제공한다.
- 프로그래머가 직접 사용할 용도로 만들어진 메서드가 아니다.
- `Enum`에 정의하는 상수들의 순서가 바뀔 수 있고, 상수를 삭제하거나, 추가할 수도 있다는 것을 주의해야 한다.
- 필드와 메서드를 정의하는 것이 좋다.
- `ordinal`은 `EnumSet`과 `EnumMap`등 자바 내부에서 사용할 용도로 만들어진 것이다.

****
# 섹션 4. 아이템 36. 비트 필드 대신 EnumSet을 사용하라.
## 아이템 36. 핵심 정리

|               비트 필드               |             (권장) `EnumSet`             |
| :-------------------------------: | :------------------------------------: |
|     정수 열거 상수의 단점을 모두 가지고 있다.      |    비트를 직접 다룰 때 겪을 수 있는 오류들에서 해방된다.     |
| 비트 필드 값을 그대로 출력할 경우 해석하기가 훨씬 어렵다. | `Set`인터페이스의 구현체로 상수 값 집합을 효과적으로 표현해준다. |
|     최대 몇 비트가 필요한지 미리 정해야 한다.      |      비트 백터로 구현되어 있어 연산 작업이 효율적이다.      |
|            연산이 효율적이다.             |                                        |
## 아이템 36 완벽 공략48. bit array와 비트 연산자
### bit array와 비트 연산자
- **bit vector, bitmask, bitmap, bit set, bit string**
- 비트 (0 또는 1) 구성된 배열. 예) 01011011,
- 비트 연산을 활용해 복잡한 로직을 효율적으로 계산할 수 있음
#### 비트 연산
- `OR`
	- 둘 중에 하나라도 1인 경우에 1, 아니면 0 => 해당 비트를 1로 설정.
- `AND`
	- 둘 모두 1인 경우에만 1, 아니면 0 => 해당 비트를 0으로 설정
- `XOR`
	- 둘 중에 하나만 1인 경우에 1, 아니면 0 => 해당 비트를 반대값으로 설정.
- `NOT`
	- 모든 비트를 반대로 변경.
## 아이템 36 완벽 공략 49. EnumSet
### `EumSet`
- `Enum`만 담을 수 있는 `Set`
- `Enum`을 일반 `Set`구현체에 담아 사용하는 것 보다 `EnumSet`에 담아 사용하는 것이 효율적 이다.
#### 주요 기능
- `allOf(Enum.class)`
	- 해당 `Enum`타입의 모든 상수를 담은 `EnumSet`만들기.
- `nonOf(Enum.class)`
	- 비어 있는 `EnumSet`만들기
- `range(from, to)`
	- 개인적으로 사용을 권장하지 않는다.
- `contains`, `forEach`, `remove`
****
# 섹션 5. 아이템 37. ordinal 인덱싱 대신 EnumMap을 사용하라.
## 아이템 37. 핵심 정리 1
### 핵심 정리
- `ordinal`을 인덱스의 배열로 사용한 경우
	- 제네릭과 호환되지 않아 비검사 형변환을 수행해야 한다.
	- 배열 인덱스(`ordianl`)만으로는 의미를 알 수 없으니 출력할 때 레이블을 달아야 한다.
	- 정확한 정수값(`oridinal`)을 사용할 것을 개발자가 보장해야 한다.(타입 안정성이 보장되지 않음)
- 열거 타입(`enum`)을 키로 사용하도록 설계한 **아주 빠른**`Map`구현체, `EnumMap`을 사용하면 모든 문제를 해결할 수 있다.
## 아이템 37. 핵심 정리 2
## 아이템 37 완벽 공략 50. EnumMap
### `EnumMap`
- `Enum`을 Key로 사용하는 `Map`
- `EnumMap`은 내부 자료 구조로 배열을 사용한다. `HashMap`에 비해 빠르다.
- `Enum`이 정의된 순서를 따르는 컬렉션이다.
- `null`값을 key로 허용하지 않는다.
- 동기화 되어 있지 않다.
****
# 섹션 6. 아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라.
## 아이템 38. 핵심 정리
### 핵심 정리
#### 열거 타입 확장이 좋치 않은 이유
- 확장한 타입의 원소를 기반 타입의 원소로 취급하지만 그 반대는 성립하지 않음
- 기반 타입과 확장 타입의 원소 모두를 순회할 방법이 마땅치 않다.
- 확장성을 높이려면 고려할 요소가 늘어나 설계와 구현이 복잡해진다.
#### 인터페이스를 활용해 확장 가능한 열거 타입을 흉내낼 수 있다.
- 하지만 여전히 구현을 상속할 수는 없다.
- 인터페이스에 디폴트 구현을 추가하고 공유하는 것은 가능하다.
****
# 섹션 7. 아이템 39. 명명 패턴보다 애너테이션을 사용하라.
## 아이템 39. 핵심 정리 1: 명명 패턴 보다 애너테이션
### 핵심 정리 1: 명명 패턴 보다 애너테이션
#### 명명 패턴
- 특정한 이름 규칙을 정하고 그 규칙에 따르는 코드에 특정한 로직을 수행하는 코딩 패턴 예) JUnit 3
##### 단점
- 오타가 나면 안된다.
- 올바르게 사용되리란 보장이 없다.
- 매개변수를 전달할 방법이 없다.
#### 애너테이션 선언
- `@interface`
- 메타-애너테이션: `@Retention`, `@Target`
## 아이템 39. 핵심 정리 2: 애너테이션
### 핵심 정리 2: 애너테이션
#### 마커 인터페이스
- 아무 매개변수 없이 단순히 대상에 마킹하는 용도로 사용한 애너테이션
- 매개변수가 있는 애너테이션
	- 매개변수()
	- `value()`
	- `default`
## 아이템 39. 핵심 정리 3: 반복 사용 가능한 애너테이션
### 핵심 정리 3: 반복 사용 가능한 애너테이션
#### `@Repeatable`메타 애너테이션
- 컨테이너 애너테이션을 정의하고 서로 연결해야 한다.
- `getAnnotationsByType()`은 둘을 구분하지 않는다.
- `isAnnotationPresent()`는 구분한다.
## 아이템 39 완벽 공략 51. 애너테이션 프로세서
### 애너테이션 프로세스
- 소스코드에 붙어있는 애너테이션을 처리하는 기능
- `RetentionPolicy.SOURCE`여도 동작한다.
- `javax.annotation.processing.Processor`인터페이스 구현하기
	- `init`메서드에서 초기화 과정을 거친다. (한번만 호출 됨)
	- 각 라운드 마다 `process`메서드가 호출 된다. (여러번 호출 됨)
	- 프로세서가 애노테이션을 처리하는 동안 새로운 파일을 만들거나, 기존 소스 파일을 수정할 수 있다.

****
# 섹션 8. 아이템 40. @Override 애너테이션을 일관되게 사용하라.
## 아이템 40. 핵심 정리
### 핵심 정리
- 상위 클래스의 메서드를 재정의하려는 모든 메서드에 **`@Override`애너테이션**을 사용하자
- 구체 클래스에서 상위 클래스의 **추상 메서드**를 재정의할 때는 굳이 `@Override` 를 달지 않아도 된다. (하지만 내 개인적인 의견으로는 다는 게 좋다.)
- 인터페이스 메서드를 구현한 메서드에서 `@Override`를 다는 것이 좋다.
- **실수로 추가한 메서드가 없다는 것을 컴파일 시점에 확인할 수 있다.**

****
# 섹션 9. 아이템 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라.
## 아이템 41. 핵심 정리
### 핵심 정리: 마커 인터페이스 VS 마커 애너테이션
- 마커 애너테이션은 거대한 애너테이션 시스템의 지원을 받을 수 있다.
- **"이 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있을까?"**
#### 마커 애너테이션 보다 마커 인터페이스가 좋은 이유
- 마커 인터페이스는 이를 구현한 클래스의 인스턴스를 구분하는 타입으로 사용할 수 있다. 예) `Serializable`인터페이스
- 마커 인터페이스는 적용 대상을 더 정밀하게 지정할 수 있다.


****
# 섹션 10. 아이템 42. 익명 클래스보다는 람다를 사용하라.
## 아이템 42. 핵심 정리
### 핵심 정리
- 익명 클래스
- 익명 클래스의 인스턴스
- 함수형 인터페이스
- 함수형 인터페이스의 인스턴스 == 람다(식)
- 익명 클래스 인스턴스에서 `this`는 익명 클래스 인스턴스 자체를 가리킴.
- 람다에서 `this`는 바깥 인스턴스를 가리킨다.
- 직렬화 사용시 람다 사용을 자제 해야 한다
****
# 섹션 11. 아이템 43. 람다보다는 메서드 참조를 사용하라.
## 아이템 43 핵심정리 1: 람다 vs 메서드 참조 (Reference)
### 핵심 정리 1: 람다 vs 메서드 참조(Reference)
- 메서드 이름이 보다 읽기 쉽다면 -> 메서드 레퍼런스
- 매개변수 이름이 보다 읽기 쉽고 의미를 잘 표현한다면 -> 람다
- 메서드와 람다가 같은 클래스에 있을 때는 -> 람다
- 람다로 작성할 코드를 새로운 메서드로 담은 다음, 람다 대신 메서드 참조를 사용하기
## 아이템 43 핵심정리 2: 다섯 가지 메서드 참조 (Reference)

|  메서드 참조 유형  |            예             |                                같은 기능을 하는 람다                                 |
| :---------: | :----------------------: | :-------------------------------------------------------------------------: |
|     정적      |   `Integer::parseInt`    |                       `str -> Integer.parseInt(str)`                        |
| 한정적 (인스턴스)  | `Instant.now()::isAfter` | ```<br>Instant then = Instant.now();<br>t -> then.isAfter(t)<br>```<br><br> |
| 비한정적 (인스턴스) |  `String::toLowerCase`   |                         `str -> str.toLowerCase()`                          |
|   클래스 생성자   |   `TreeMap<K,V>::new`    |                         `() -> new TreeMap<K,V>()`                          |
|   배열 생성자    |       `int[]::new`       |                            `len -> new int[len]`                            |

****
# 섹션 12. 아이템 44. 표준 함수형 인터페이스를 사용하라.
## 아이템 44. 핵심정리 1: java.util.function 패키지
### 핵심 정리 1: `java.util.function`패키지
- API가 다루는 개념의 수가 줄어들어 익히기 더 쉬워진다.
- 표준 함수형 인터페이스들은 유용한 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호운용성도 크게 좋아진다.

| 인터페이스               | 함수 시그니처               | 예                     |
| ------------------- | --------------------- | --------------------- |
| `UnaryOperator<T>`  | `T apply(T t)`        | `String::toLowerCase` |
| `BinaryOperator<T>` | `T apply(T t1, T t2)` | `BigInteger:add`      |
| `Predicate<T>`      | `boolean test(T t)`   | `Collection::isEmpty` |
| `Function<T, R>`    | `R apply(T t)`        | `Arrays::asList`      |
| `Supplier<T>`       | `T get()`             | `Instant::now`        |
| `Consumer<T>`       | `void accept(T t)`    | `System.out::println` |
## 아이템 44. 핵심정리 2: 직접 정의해서 사용하는 경우
### 핵심 정리 2: 직접 정의해서 사용하는 경우
- 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
- 반드시 따라야 하는 규약이 있다.
- 유용한 디폴트 메서드를 제공할 수 있다.
#### `@FunctionalInterface`
- 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
- 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일 되게 해준다.
- 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.

****
# 섹션 13. 아이템 45. 스트림은 주의해서 사용하라.

****
# 섹션 14. 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라.

****
# 섹션 15. 아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다.

****
# 섹션 16. 아이템 48. 스트림 병렬화는 주의해서 적용하라.

****
# 섹션 17. 아이템 49. 매개변수가 유효한지 검사하라.

****
# 섹션 18. 아이템 50. 적시에 방어적 복사본을 만들라.

****
# 섹션 19. 아이템 51. 메서드 시그니처를 신중히 설계하라.

****
# 섹션 20. 아이템 52. 다중정의는 신중히 사용하라.

****
# 섹션 21. 아이템 53. 가변인수는 신중히 사용하라.

****
# 섹션 22. 아이템 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라.

****
# 섹션 23. 아이템 55. 옵셔널 반환은 신중히 하라.

****
# 섹션 24. 아이템 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라.

****