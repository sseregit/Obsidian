# 챕터 1 왜 클로드 코드인가?

- 에이전트 AI의 등장은 개발 생산성의 정의 자체를 바꾸고 있다.
	- 더 이상 얼마나 많은 코드를 작성했는가는 중요하지 않고 얼마나 가치 있는 문제를 해결했는가?가 새로운 생산성의 척도가 되고 있다.
	- 이제 개발자가 해야할 역할
		- 방향 제시
			- AI가 올바른 방향으로 작업하도록 명확한 목표와 제약 조건 설정
		- 비판적 검토
			- AI가 생성한 결과물의 품질, 보안, 아키텍처 적합성을 비판적으로 검토하고 개선 지시
		- 최종 문제 해결
			- AI가 해결할 수 없는 복잡한 아키텍처 문제나 창의적인 해결책이 필요한 영역에 집중

---
# 챕터 6 CLAUDE.md 파일에 대한 모든 것
- CLAUDE.md 파일 관리 노하우
	- **IMPORTANT나 YOU MUST 등 강조 표현을 사용하면 좋다.**
		- `/compact`시에도 다음 콘텍스트에 살아남을 가능성이 높아진다.
---
# 챕터 7 클로드 코드의 3가지 모드 알아보기
- 하나하나 확인하고 보고 싶을 때, 일반모드
	- 새 라이브러리나 프레임워크를 도입하면서 기본 사용법을 익힐 때
	- 특정 로직을 구현하기 위한 다양한 알고리즘 아이디어를 얻고 싶을 때
	- 발생한 오류 메시지의 의미를 정확히 이해하고 싶을 때
	- 코드 리뷰 전 자신의 코드에 대한 제3자의 의견을 구하고 싶을 때
	- 아직 클로드 코드를 신뢰하지 못하여 하나씩 내가 컨트롤하고 싶을 때
- 반복 작업에 유용한, 자동 수정 모드
	- 사용자에게 허락받지 않고 직접 코드를 수정한다.
	- 프로젝트 전반에 걸쳐 사용한 변수명, 함수명, 클래스명을 일괄 변경할 때
	- 기존 코드를 최신 패턴이나 스타일 가이드에 맞도록 리팩터링할 때
	- JSDoc등 문서 작업을 할 때
	- 단순한 작업을 반복해서 해야 할 때
	- 테스트 코드를 작성해야 할 때
		- 특히 테스트 코드는 아무리 방대하더라도 프로젝트를 망치거나 하지 않으므로 자동 수정 모드와 궁합이 좋다.
- 가장 강력한 기능, 플래닝 모드
	- 코드를 작성하기 전에 설계도를 그리듯 소프트웨어의 구조와 개발 계획을 수립하는 단계에서 클로드 코드를 활용하는 모드
	- **이 기능이 클로드 코드의 가장 핵심적인 기능으로 작가는 보고 있다. 가장 많이, 가장 오래 사용해야하는 기능!**
		- Opus에서 써보고 싶다!!
		- 무언가 막연히 구현해야 할 기능이 있을 때는 일단 플래닝 모드로 진입 할 것!
	- 플래닝 끝난 후 플랜을 기준으로 작업을 실행할 지 질문을 하는데 이때 `No, Keep planning`을 선택하면 콘텍스트를 이어가며 플랜을 세울 수 있다.
		- 작가 추천은 첫 번째 플랜은 `Yes`를 바로 선택하지 않는 것
	- 계획이 너무 큰 경우 제어할 수 있는 범위 내에서 작업을 나눠 진행하는 것이 좋다.
---
# 챕터 8 모델 선택, 사용량 관리 딱 알려드립니다!
- 기준 1. 계획은 Opus,빠른 코드 작성은 Sonnet
	- Opus 모델이 Sonnet보다 잘하는 작업은 추상적인 생각과 어려운 문제를 해결하는 것
- 기준 2. 작업 시간
	- 한 세션 5시간 한 세견에 시간을 츶정하는 시작점이 첫 번째 요청을 보낸 순간부터 이 특징을 전략적으로 사용해야 한다. Max Plan 기준
- 기준 3. 동시 실행하는 에이전트 기준
---
# 챕터 9 클로드 코드의 생각 과정 제어하기
- Cot (Chain of Thought)
	- 사고의 사슬, 논리적 사고 과정이라는 뜻의 프롬프팅 기법
	- AI가 최종 답변을 내놓기 전에, 사고 과정을 명시적으로 기술하도록 유도한다.
	- 특징
		- 정확성
			- 여러 단계를 거쳐야 하는 작업에서 발생할 수 있는 오류를 획기적으로 줄인다.
			- 각 단계를 검증하며 진행하므로 최종 결론의 신뢰도가 높아진다.
		- 일관성
			- 최종 결과물이 더욱 긴밀하고 체계적인 구성을 갖추도록 돕는다.
		- 디버깅 용이성
			- 어떤 논리적 흐름으로 특정 결과에 도달했는지 투명하게 보여준다.
	- 유도하기
		- 프롬프트 안에 ‘생각해라’ 라는 문구를 넣기
		- \<thinking> 생각과정, \<answer> 생각한 과정 분석 답변 태그를 이용하기
- 확장된 사고
	- 사고의 사슬에서 한 단계 발전한 기능
	- 모델이 확장된 사고를 사용하면 응답을 생성하는데 더 많은 노력을 들인다.
		- 이 노력을 사고 예산(Thinking Budget)이라 한다.
	- ‘고민해라’라고 프롬프트에 넣기
	- 고민해라 Think -> 깊게 고민해라 Think Hard -> 더 깊게 고민해라 Think Harder
	- 프롬프트 앞에 Think: , Think Hard: 를 추가하는 것도 방법
---
# 챕터 10 커스텀 슬래시 커맨드 사용하기

`/<prefix>:<command-name> [arguments]`

| 파라미터            | 설명                                                                                       |
| --------------- | ---------------------------------------------------------------------------------------- |
| \<prefix>       | 커스텀 커맨드의 스코프를 명시한다.(프로젝트 단위: project, 사용자 단위: user)                                      |
| \<command-name> | 커맨드가 정의된 마크다운 파일 이름. 확장자(.md)는 제외하고 입력                                                   |
| \[arguments]    | 커맨드에 제공할 선택적 매개변수, 매개변수로 issue-79 실제 변수를 입력할 수도 프롬프트를 입력할 수도 있다. 클로드 코드가 스스로 어떻게 활용할지 판단 |
- 관리 경로
	- User: `~/.claude/commands/`
	- Project: `<project>/.claude/commands/`
- 네임스페이싱
	- User 위치: `~/.claude/commands/<namespace>/<command>.md`
	- Project 위치: `<project>/.claude/commands/<namespace>/<command>.md`
	- User prefix: `/<namespace>/<command>`
	- Project prefix: `/<namespace>/<command>`	
	- `/<namespace>:<command>`
- 커스텀 슬래시 커맨드 마크다운 파일 정의하기
```markdown
---
allowed-tools: Bash(mkdir) -- 커맨드 실행할 때 사용할 도구
description: 하나의 디자인을 기반으로 여러 가지 독창적인 디자인 콘셉트를 병렬적으로 생성합니다. -- 커맨드에 대한 간략한 설명
---
# 디자인 콘셉트 병렬 생성기
....
---
## Prompt Instruction
....

-- 마크 다운 문법을 활용해 사람이 봐도 간결하고 명확하게 작성해주기
```
---
# 챕터 11 MCP 사용하기
- MCP (Model Context Protocol)
	- LLM이 데이터베이스, API, 파일 시스템과 같은 외부 도구 및 데이터 소스에 접근할 수 있도록 설계된 클라이언트-서버 구조의 개방형 프로토콜
	- 방식
		- stdio
			- 로컬 서버 방식
			- 클로드 코드가 사용자의 컴퓨터에서 직접 포컬 프로세스(프로그램)를 실행하고 해당 프로세스와 직접 통신하는 것
			- `claude mcp add <name> <command> [args..]`
				- `claude mcp add context7 -- npx -y @upstash/context7-mcp`
				- or .mcp.json에 직접 추가하기
		- sse
			- 서버가 클라이언트에게 지속적으로 데이터를 밀어주는 단방향 통신 기술
			- `claude mcp add --transport sse <name> <command> [args...]`
		- http
			- 웹에서 가장 널리 사용되는 요청-응답 방식의 통신
			- `claude mcp add --transport http <name> <command> [args...]`
- 유용한 MCP 리스트

| MCP 이름                     | 기능                                                              |
| -------------------------- | --------------------------------------------------------------- |
| Postgresql, Mongodb, Mysql | 데이터베이스에 접근할 수 있고, 실제 데이터베이스에 어떤 데이터가 있는지 조회하고 마이그레이션 계획을 짤 때 유용 |
| Playwright, Puppeteer      | MCP로 브라우저를 조종할 수 있다. 엔드투엔드 테스트를 하거나 크롤링할 때 유용                   |
| context7                   | 각종 개발 도구의 가장 최근 공식 문서를 가져온다.                                    |
| MagicUI                    | 21st Dev의 아름다운 UI 컴포넌트들을 적용할 수 있다                               |
| GitHub                     | 깃허브, 깃 기능을 실행할 수 있다.                                            |
| TossPayments, evenueCat    | 결제 관련 기능을 구현할 수 있다.                                             |
| Supabase                   | Supabase에 연결할 수 있다.                                             |

---
# 챕터 12 PRD와 실행 계획하기
- PRD (Product Requirements Document)
	- 제품 요구사항 문서
	- ‘무엇을 만들것 인가?’
	- 목적이 구현이 아닌 프로젝트의 방향을 정하고 이해를 돕는 것
	- 작성법
		- 문제 정의
		- 타깃 사용자 및 사용 사례
		- 제안 해결책
		- 목표 및 성공 지표
		- 추가로
			- 경쟁사 분석
			- MVP 요구사항
	- PRD를 제작하는 에이전트는 따로 다른 업무를 시키지 않고 PRD 작업 엄무만 시키는게 좋다.
- 실행 계획
	- ‘어떻게 만들 것인가?’
	- PRD를 구현하기 위한 계획을 작성한 문서
	- 작성법
		- 작업 분해
		- 기술 명세
		- 의존성 파악
		- 산출물 및 일정
	- **체크 박스를 꼭 사용하는게 중요하다.**
---
# 챕터 13 에이전트 병렬로 실행하기
- 서브에이전트
	- 병렬 실행
		- 병렬 실행을 처리할 때는 서로 독립적인 작업을 시키는 게 유리하다.
		- 유리한 작업들의 예
			- 다국어 작업할 때 여러 언어로 동시에 병렬로 번역
			- 많은 분량의 테스트를 독립적으로 나눠서 동시에 병렬로 작업
			- 여러 디자인 시안을 동시에 병렬로 작업할 때
			- 깃허브 이슈 여러 개를 동시에 생성하고 싶을 때
	- 직렬 실행
- 커스텀 서브에이전트
	- `/agents`
		- `/agents`를 사용해서 커스텀 에이전트를 생성하고 마크다운 파일을 수정하는 것을 추천한다.
	- 프런트매터 정리
```markdown
---  
name: test-coverage-optimizer  
description: 
model: sonnet  
color: red  
---
```

| 변수          | 설명                                                                                                           |
| ----------- | ------------------------------------------------------------------------------------------------------------ |
| name        | 서브에이전트의 이름을 정의할 수 있다.                                                                                        |
| description | 서브에이전트에 대한 설명, 클로드 코드가 어떤 서브에이전트를 사용해야 할지 판단할 때 이 필드를 확인하고 판단한다. 원하는 커스텀 서브에이전트 트리거가 잘 안된다면 더욱 상세하게 작성해야 한다. |
| color       | 서브에이전트의 색상. 커스텀 서브에이전트가 실행될 때 쉽게 확인할 수 있도록 색상을 지정할 수 있다.                                                     |
- 사용법
	- `서브에이전트를 사용해서 ...` 프롬프트 사용
	- `test-coverage-optimizer를 사용해서 ...` name지정 프롬프트 사용
- Git Worktree
	- 깃 프로젝트에 여러 워크스페이스를 생성하는 개념
	- `git worktree add [폴더 위치]`
		- 깃 프로젝트와 완전히 똑같은 프로젝트 구조
	- `git worktree add [폴더 위치] [브랜치 이름]`
	- `git worktree add [폴더 위치 및 폴더명] -b [브랜치 이름]`
		- 워크트리 이름과 브랜치 이름을 다르게 지정
	- `git worktree remove [폴더위치]`
		- 워크트리를 삭제한다.
		- **단순 폴더 개념이 아니라 직접 삭제하면 깃에는 워크트리 정보가 남아있게 된다!**
	- `git worktree prune`
		- 워크트리 정리