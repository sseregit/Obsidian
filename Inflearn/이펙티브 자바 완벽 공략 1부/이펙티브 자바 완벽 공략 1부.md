## 생성자 대신 정적 팩토리 메서드를 고려하라
- of or valufOf
	- 어떠한 매개변수를 받아서 만들경우
- getInstance or instance
	- 기존에 있던 인스턴스를 리턴할경우
- newInstance or create
	- 매번 새롭게 만들경우

- Enumeration
	- 상수 목록을 담을 수 있는 데이터 타입
	- **타입-세이프티**를 보장
	- **싱글톤 패턴**을 구현할 때 사용하기도 한다.
	- JVM내에서 Instance가 딱 하나만 생성된다.
	- JVM내에서 하나의 Instance를 보장하기 때문에 equals보다 == 로 비교하는것이 좋다.
		- equals를 사용하면 NullPointException이 나온다.

- 같은 객체가 자주 사용되는 경우 **플라이웨이트 패턴**을 사용할 수 있다.
	- 플라이웨이트 패턴
		- 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴
		- 자주 변하는 속성과 변하지 않는 속성을 분리하고 재사용하여 메모리 사용을 줄일 수 있다.

- 인터페이스와 정적 메서드

- 서비스 제공자 프레임워크
	- 확장 가능한 애플리케이션을 만드는 방법

- 리플렉션

## 생성자에 매개변수가 많다면 빌더를 고려하라.

- 대안1
	- 점층적 생성자 패턴 또는 생성자 체이닝
- 대안2
	- 자바빈즈 패턴
		- getter and setter

- 권장하는 방법
	- 빌더
		- 생성자의 매개변수가 매우 많거나 불변객체로 만들고 싶을때 좋은 선택이다.
- 완벽 공략
	- 자바빈(JavaBean)
		- 지켜야할 규칙
			- 아규먼트 없는 기본 생성자
				- 있어야 하는 이유
					- 객체를 만들기 편하기 때문에 (리플렉션)
			- getter와 setter 메소드 이름 규약
				- boolean형은 get이 아닌 is
				- getter와 setter가 주로 쓰는 이유?
					- JPA나 스프링과 같은 여러 프레임워크에서 리플렉션을 통해 특정 객체의 값을 조회하거나 설정하기 떄문이다.
			- Serializable 인터페이스 구현
				- 직렬화와 역직렬화
	- 객체 얼리기 (freezing)
	- 빌더 패턴
		- 복잡한 객체를 만드는 프로세스를 독립적으로 분리할 수 있다.
	- IllegalArgumentException
		- checked exception
			- 다시 checked exception을 던지거나 예외를 처리해야한다.
			- Compile타임에 check하기 때문에 위에처럼 처리하지 않으면 코드를 작성할수 없다.
			- 복구가 가능한 상황에서 던진다.
			- 사용하는 이유
				- 해당 에러가 발생할 경우 후속작업을 바라는 경우
		- unchecked exception
			- 다시 던지지않고 예외처리를 따로 할 필요가 없다.
			- 예외를 받아 처리할수 없는 상황에서 사용한다.
			- 메서드에 unchecked exception을 throw하는 경우는 client에게 명시적으로 알려주기 위함이다.
	- 가변인수
		- `void method(int... numbers) {}`
			- 매개변수의 가장 뒤쪽에 선언해야하고
			- 하나이상이 있을수 없다.

## 생성자나 열거타입으로 싱글턴임을 보증하라.
- 역직렬화
```java
private Object readResolve() {
  return INSTANCE;
}
```
- 역직렬화에서 싱글톤을 유지하는방법으로 사용하지만 Override개념은 아니다.
