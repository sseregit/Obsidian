# 섹션 1. 자료구조와 알고리즘 기초 (Data Structure and Algorithms)
## 1. 오리엔테이션 (OT)
### 자료 구조(Data Structures)
- 데이터를 정리하고 저장하는 방법
### 알고리즘(Algorithm)
- 어떤 문제를 해결하기 위한 단계적인 절차
### 자료 구조와 알고리즘의 관계
#### 자료 구조
- 데이터 저장 및 조직화를 담당
#### 알고리즘
- 이러한 데이터를 처리하고 조작하는 로직을 담당
### 자료 구조(Data Structures)란?
- 컴퓨터에서 데이터를 어떻게 메모리에 표현하고 정리할 것인지에 대한 방법을 연구하는 분야
- 개발자가 데이터를 효율적으로 사용할 수 있도록 정리하는 방식
#### 선형 자료구조
- 데이터를 연속적인 메모리 공간에 저장한느 방식
- 배열이나 리스트가 대표적
#### 비선형 자료구조
- 데이터가 연속적인 메모리 공간에 있지 않고 메모리 여기저기에 흩어져 있는 형태
- 트리, 그래프가 대표적
## 2. 배열과 리스트
### 자료 구조(Data Structure)
#### 단순(Primitive)
- integer, float, string, boolean...
#### 복합(Non-Primitive)
##### 선형(Linear)
###### 정적자료구조(Static)
- 생성 시 크기가 고정되는 형태
- 배열등
###### 동적자료구조(Dynamic)
- 실행 중에 크기가 유동적으로 변할 수 있다.
- 리스트, 스택, 큐, 연결 리스트등
##### 비선형(Non-Linear)
- 트리와 그래프가 대표적
##### 복합 자료구조의 또다른 분류
###### 내장형
- 이미 프로그래밍 언어에서 제공하는 자료구조
- 배열, 리스트
###### 사용자정의형
- 프로그래머가 직접 구현하여 사용하는 것
- 스택, 큐, 연결리스트, 트리, 그래프
### 배열
- 리스트에 비해 더 컴팩트하고 메모리 효율적인 저수준 데이터 구조
`항목의 메모리 위치 = 배열 시작 주소 + (index * 4)`
#### 장점
- 같은 타입을 갖는 데이터들이 연속한 위치에 있다.
- 데이터들이 연속된 메모리 공간에 저장되어 있고 인덱스를 통해 순차적으로 접근할 수 있다. 이 특성 덕분에 배열은 반복문과 함께 사용할 때 매우 효율적이다.
#### 단점
- 데이터의 삽입과 삭제가 비효율적이다.
- 고정된 크기
- 메모리 연속성 요구
### 리스트
- 데이터 삽입, 삭제가 훨씬 자유롭지만, 배열보다 처리 시간이 더 걸리는 고수준 데이터 구조
### 추상 자료형(ADT, Abstract Data Type)
- 자료와 그 자료를 다루는 연산에 대한 개념을 정의한 것
- 어떻게 구현되었는지 보다는 어떤 기능을 제공하는지에 집중하는 것이 핵심
- 오류에 대한 처리 방법 설명
#### 추상화
- 어떤 새로운 자료형을 정의하려면 필수적이고 중요한 특징만 골라서, 단순화 시키는 작업
## 3. 스택
### 스택(Stack)
- 후입선출(LIFO, Last-In, First-Out)
## 4. 큐
### 큐(Queue)
- 선입선출(FIFO, First-In, First-Out)
## 5. 연결 리스트
### 연결 리스트
- 각 데이터가 다음 데이터의 위치를 가리키는 형태로된 자료 구조
- 데이터의 삽입과 삭제가 유연하다
- 배열이나 리스트의 단점을 보완하기 위해 만들어진 자료 구조
#### 단순 연결리스트(Singly Linked List)
- 하나의 방향으로만 연결된 리스트
#### 원형 연결리스트(circular Linked List)
- 단순 연결 리스트에서 tail 노드의 링크를 약간 다르게 변형한 형태
	- tail노드가 head node를 바라보고 있다.
- 아무 node에서 시작해도, 링크를 타고 이동하면, 다른 모든 node를 접근할 수 있다는 장점이 있다.
- 하지만 node를 순서대로 방문할 때, 종료 조건이 되는 node를 찾는 것은 조금 어려울 수 있다.
#### 이중 연결리스트(doubly Linked List)
- 하나의 노드가 이전 노드와 다음 노드의 링크를 모두 갖도록 하는 형태
- prev 링크와 next 링크를 가지고 있어 어떤 노드든 이전 노드와 다음 노드를 바로 찾아갈 수 있는 장점이 있다.
## 6. 트리
### 트리(Tree) 구조
- 노드(Node)와 간선(Edge)로 이루어진 자료 구조
- 사이클이 없다
	- 한 노드에서 출발해 다른 노드를 거쳐 다시 그 출발점으로 돌아오는 경로가 없다
#### 노드(Node)
- 트리의 각 점
##### 루트 노드(Root Node)
- 하나의 시작점
- 이 루트 노드에서 트리의 모든 가지가 뻗어 나가기 시작한다.
##### 리프 노드(Leaf Node)
- 더 이상 자식이 없는 노드
##### 부모 노드(Parent Node)
- 하나의 노드가 다른 노드에 연결되어 있을 경우 그 상위 노드를 부르는 명칭
##### 자식 노드(Child Node)
- 하위 노드
##### 형제 노드(Siblings Node)
- 같은 부모노드를 가진 노드들
##### 조상 노드(Ancestor Node)
- 어떤 한 노드를 기준으로, 위로 루트 노드까지 경로 상에 있는 모든 노드
##### 자손 노드(descendent Node)
- 어떤 한 노드를 기준으로, 아래로 경로 상에 있는 모든 노드
#### 간선(edge)
- 그 노드와 노드를 연결하는 선
### 트리(Tree) 종류
#### 일반트리(General Tree)
- 트리 구조에서 각 노드가 자식 노드를 몇 개나 가질 수 있는지에 대한 제한이 없는 트리
#### 이진트리(Binary Tree)
- 각 노드가 최대 두개의 자식을 가지는 트리
- 데이터를 검색하고 삽입하는 데 효율적인 자료구조
##### 포화이진트리(Full Binary Tree)
- 모든 노드가 자식 노드를 두 개씩 가진 이진 트리
##### 완전이진트리(Complete Binary Tree)
- 마지막 레벨을 제외한 모든 레벨이 꽉찬 상태
- 여기서 레벨이란 트리의 수평방향
- 마지막 레벨에서는 오른쪽으로 노드가 비어 있을 수 있지만, 그외의 모든 레벨은 가득 차 있어야 한다.
##### 균형이진트리(Balanced Binary Tree)
- 트리의 왼쪽과 오른쪽 부분 트리의 높이 차이가 1이하(레벨)로 유지되는 트리
##### 편향이진트리(Skewed Binary Tree)
- 트리의 모든 노드가 한쪽 자식만 가지는 트리
- 왼쪽 또는 오른쪽으로만 자식 노드가 쭉 이어진 형태로 일종의 연결 리스트처럼 보이기도 한다.
- 트리의 높이가 노드 수와 같아지므로, 탐색, 삽입, 삭제 연산에서 비효율적일 수 있다.
#### 이진 탐색 트리(BST, Binary Search Tree)
- 이진 트리의 특별한 형태로, 모든 왼쪽 자식은 부모보다 작은 값을, 모든 오른쪽 자식은 부모보다 큰 값을 가지게 된다.
### 트리 순회(Tree Traversal)
- 트리의 모든 노드를 특정한 순서대로 한 번씩 방문하는 과정
#### 전위 순회(depth first traversal or Preorder Traverse)
- Root 노드를 방문한 후 왼쪽 서브 트리를 순차적으로 둘러본 뒤 오른쪽 서브트리를 순회하는 것
- Root -> Left -> Right 순
#### 중위 순회(symmetric traversal or Inorder Traverse)
- 루트를 가운데에 두고 순회한다 왼쪽 서브 트리를 모두 순회한 후, 루트를 방문하고, 그 후 오른쪽 서브 트리를 모두 순회하는 방법이다.
- Left -> Root -> Right
- 이진 탐색 트리에서 오름차순 또는 내림차순으로 값을 가져올 때 사용한다.
#### 후위 순회(Postorder Traverse)
- 자식들을 모두 방문한 후에 마지막에 루트 노드를 방문하는 방식
- Left -> Right -> Root
### 이진트리 표현
#### 배열로 표현하기
- 트리의 노드를 배열의 인덱스로 매핑하는 방법
- 계산의 편의를 위해 루트의 노드 번호를 0으로 한다.
- 왼쪽 자식은 부모 노드의 인덱스 i에 대해 2 * i + 1로 한다.
- 오른쪽 자식은 부모 노드의 인덱스 i에 대해 2 * i + 2로 한다.
- 구현이 매우 간단함
- 포화이진트리와 완전 이진트리에 가장 적합하다.
	- 배열 항목 사이에 빈칸이 발생하지 않기 때문에
##### 단점
- 배열의 크기에 따라 트리의 높이가 제한되는 단점
#### 연결 리스트로 표현하기
- 각 노드당 두 개의 링크를 가지는 것으로 표현한다.
- 이진탐색트리와 같이 삽입과 삭제가 빈번하게 발생하는 경우이거나, 데이터가 많고, 트리가 불균형할 가능성이 높을 경우에는 연결리스트로 사용하는 것을 권장한다.
##### 장점
- 필요한 만큼만 메모리를 사용할 수 있다
- 복잡한 트리 구조를 시작적으로 구현하는 것이 용이하다.
##### 단점
- 포인터를 사용해야하므로, 배열보다 구현이 복잡하다.
- 탐색 속도도 배열보다 느리다.
## 7. 그래프
### 그래프(Graph)
- 정점(Node)과 간선(Edge)으로 이루어진 자료구조
#### 정점(Node)
- 표현하고자 하는 대상
#### 간선(Edge)
- 정점들 사이의 관계나 연결
### 트리와의 차이점
#### 트리
- 계층적인 구조를 가지는 자료 구조
- 순환 루프가 존재하지 않는다.
	- 어떤 경로를 따라가도 같은 정점을 두 번 지나지 않는다.
#### 그래프
- 트리에 비해 자유로운 연결을 가진 자료구조
- 순환이 가능하다
### 그래프의 종류
#### 무방향 그래프
- 양쪽이 모두 연결된 관계를 나타낼 경우
#### 유방향 그래프
- 연결이 한쪽 방향으로만 이루어져 있을 경우
#### 가중치 그래프
- 간선에 값(가중치)이 부여된 그래프
#### 비가중치 그래프
- 간선에 값이 없는 그래프
#### 순환 그래프
- 출발한 지점으로 다시 돌아올 수 있는 경로가 있는 그래프
#### 비순환 그래프
- 순환이 없는 그래프
- 한 방향으로만 쭉 가야하는 경우
### 그래프의 표현
#### 인접 행렬(Adjacency Matrix)
- 2차원 배열을 사용해서 그래프를 표현하는 방법
##### 장점
- 탐색 속도가 빠르다
- 구현이 단순하다
##### 단점
- 메모리를 많이 사용한다.
#### 인접 리스트(Adjacency List)
- 각 정점이 연결된 정점들의 목록을 따로 저장하는 방식
##### 장점
- 메모리 절약할 수 있다.
- 연결된 정점들을 쉽게 순회할 수 있다.
##### 단점
- 탐색 속도가 느리다.
- 구현이 복잡하다
### 그래프의 탐색
- 그래프 안의 모든 정점을 방문하거나 특정 경로를 찾는 과정
#### 깊이우선탐색(Depth-First-Search)
- 한 정점에서 출발해서 갈 수 있는 한 최대한 멀리가고, 더이상 갈곳이 없으면 다시 돌아와서 다른 길을 찾아가는 방식
#### 너비우선탐색(Breadth-First-Search)
- 한 정점에서 출발해서 가까운 곳 부터 차례대로 탐색한다.
## 8. 알고리즘이란?
### 알고리즘
#### 정의
- 문제 해결을 위한 명확한 절차나 규칙의 집합
#### 어원
- 알 콰리즈(Al-Khwarizmi)의 이름에서 유래되었다.
#### 역할
- 컴퓨터가 작업을 자동화하고 효율적으로 수행하도록 지시한다.
### 알고리즘의 중요성
#### 효율성
- 시간과 자원을 절약하게 해준다.
#### 보편성
- 다양한 문제에 적용 가능하다.
#### 실생활 예시
- 검색 엔진, 네비게이션, 데이터 분석 등에서 알고리즘이 사용된다.
### 알고리즘의 특징
#### 유한성
- 반드시 종료되어야 한다.
#### 명확성
- 각 단계가 명확해야 한다.
#### 입력과 출력
- 최소 1개의 입력과 출력이 필요하다.
	- 입력은 처리해야할 데이터나 조건
	- 출력은 알고리즘의 결과물
#### 효과성
- 각 단계는 기본적인 연산으로 수행 가능해야 한다.
### 알고리즘의 성능 평가
#### 시간 복잡도(Time Complexity)
##### O(1): 상수 시간
###### 특징
- 입력 크기에 상관없이 일정한 시간이 소요된다.
###### 예시
- 배열에서 특정 인덱스의 값을 조회하는 작업.
###### 효율성
- 가장 효율적인 시간 복잡도로,입력 크기와 무관하게 빠른 실행 시간을 보장한다.
##### O(log n): 로그 시간
###### 특징
- 입력 크기가 증가할수록 시간은 느리게 증가한다.
###### 예시
- 이진 탐색 알고리즘
###### 효율성
- 대규모 데이터셋에서도 효율적인 성능을 보이는 알고리즘
##### O(n): 선형 시간
###### 특징
- 입력 크기에 비례하여 시간이 증가한다.
###### 예시
- 배열에 특정 값을 찾기 위한 선형 탐색
###### 효율성
- 중간 정도의 효율성을 가지며, 작은 데이터셋에서는 충분히 빠르다.
##### O(n log n): 로그 선형 시간
###### 특징
- 시간이 입력 크기와 그 로그 값의 곱에 비례한다.
###### 예시
- 병합 정렬, 힙 정렬
###### 효율성
- 대규모 데이터 정렬에 효과적인 복잡도
##### O(n^2): 이차 시간
###### 특징
- 입력 크기의 제곱에 비례하여 시간이 증가한다.
###### 예시
- 버블 정렬, 선택 정렬
###### 효율성
- 작은 데이터셋에서는 사용 가능하짐만, 큰 데이터셋에서는 비효율적이다.
##### O(2n): 지수 시간
###### 특징
- 입력 크기에 따라 실행 시간이 지수적으로 증가한다.
###### 예시
- 부분집합 생성, 외판원 문제의 완전 탐색
###### 효율성
- 매우 비효율적이며, 작은 입력크기에서도 실행 시간이 급격히 증가한다.
#### 공간 복잡도
- 메모리 사용량 평가
#### 성능 평가
- 최선, 최악, 평균 성능
	- 다양한 시나리오에서의 평가
### 알고리즘 설계 패러다임
#### 1. 분할 정복(Divide and Conquer)
- 문제를 작은 부분으로 나누어 해결한다.
#### 2. 동적 프로그래밍(Dynamic Programming)
- 중복된 계산을 줄이고, 문제를 효율적으로 해결한다.
#### 3. 탐욕 알고리즘(Greedy Algorithm)
- 각 단계에서 최선의 선택을 한다.
## 9. 재귀

### 재귀(Recursion)란?
- 함수가 자기 자신을 호출하며 문제를 해결하는 방식으로, 복잡한 문제를 간단하게 표현할 수 있는 중요한 프로그래밍 기법
#### 중요한 두가지 부분
##### 기본 사례(Base Case)
- 재귀 호출이 멈추는 조건
##### 재귀 사례(Recursive Case)
- 문제를 더 작은 문제로 나누어 자기 자신을 다시 호출하는 부분
#### 재귀와 반복의 차이
##### 1. 동작 방식
- 재귀는 함수가 자기 자신을 호출하면서 문제를 해결하는 방식
- 반복은 루프(반복문)를 사용해 동일한 작업을 여러 번 수행하는 방식
##### 2. 메모리 사용
- 재귀는 함수가 호출될 때마다 스택 메모리 사용
- 반복은 메모리 사용이 적다.
##### 3. 가독성
- 재귀는 복잡한 문제를 간결하고 직관적인 코드로 표현
- 반복은 코드가 다소 길어질 수 있지만, 실행 흐름이 명확하고 이해하기 쉽다.
##### 4. 성능
- 재귀는 스택 메모리를 많이 사용하여, 큰 문제에서 성능이 저하 가능성
- 반복은 메모리 사용이 적고, 성능 면에서 재귀보다 효율적
#### 장점과 단점
##### 장점
- 코드가 매우 간결
- 작은 단위로 나누어 해결
##### 단점
- 메모리 사용 증가
- 무한 재귀의 위험
##### 활용 사례
- 팩토리얼 계산
- 피보나치 수열
- 하노이의 탑
- 이진 탐색 트리 탐색
## 10. 탐색
### 탐색
- 데이터 집합에서 우리가 원하는 값을 찾는 과정
- 얼마나 효율적으로 하느냐가 데이터 처리 속도에 큰 영향을 미친다.
#### 정의
- 데이터 구조 내에서 특정 값을 효율적으로 찾는 방법
#### 필요성
- 대규모 데이터에서 필요한 정보를 신속하고 효율적으로 찾아내기 위해 필수적인 도구
##### 1. 효율적인 데이터 처리
- 방대한 데이터 집합에서 원하는 정보를 신속하게 찾아내는 데 필수적
##### 2. 다양한 응용 분야
- 데이터베이스 검색, 파일 시스템 탐색, 네트워크 경로 탐색등 다양한 분야에서 사용
##### 3. 대규모 데이터 처리
- 대규모 데이터를 빠르고 정확하게 처리하는 데 중요한 역할
##### 4. 시스템 자원 최적화
- 적절한 탐색 알고리즘을 선택하면, 불필요한 자원 낭비를 줄이고 성능을 극대화할 수 있다.
##### 5. 실시간 응용
- 실시간 처리 시스템에서의 효율적인 탐색은 빠른 응답 시간을 제공하기 위해 필수적
#### 대표 탐색 알고리즘
- 선형 탐색, 이진 탐색, 해시 탐색, 깊이 우선 탐색, 너비 우선 탐색


| 종류                       | 설명                                                                         | 시간복잡도    |
| ------------------------ | -------------------------------------------------------------------------- | -------- |
| 선형 탐색<br>(Linear Search) | 배열이나 리스트를 처음부터 끝까지 순차적으로 탐색하여 원하는 항목을 찾는 탐색 방법                             | O(n)     |
| 이진 탐색<br>(Binary Search) | 정렬된 데이터 구조에서 중간 값과 찾고자 하는 값의 대소 관계를 비교하여 탐색 범위를 절반으로 줄여나가는 탐색 방법           | O(log n) |
| 해시 탐색<br>(Hash Search)   | 해시 테이블이라는 자료 구조를 사용하여, 입력된 데이터를 해시 함수를 통해 인덱스로 변환하고, 이를 기반으로 데이터를 저장하거나 검색 | O(1)     |
## 11. 정렬
### 정렬 알고리즘
#### 정의
- 데이터 목록(배열, 리스트등)을 특정 순서(오름차순, 내림차순등)로 재배열하는 방법
#### 주요 목적
- 데이터의 효율적 탐색 및 관리
- 데이터 구조에서 최적화된 성능 제공
#### 주요 정렬 알고리즘
##### 1. 버블 정렬
- 리스트의 인접한 두 요소를 비교하고, 필요시 교환하여 정렬하는 방식
##### 2. 선택 정렬
- 리스트에서 가장 작은(또는 큰) 요소를 찾아 첫 번째 위치로 이동시키는 과정을 반복
##### 3. 삽입 정렬
- 리스트의 요소를 하나씩 순서대로 선택하여 이미 정렬된 부분에 삽입하여 정렬
##### 4. 병합 정렬
- 리스트를 반으로 나누고 각각을 정렬한 후, 다시 합병하여 전체 리스트를 정렬
###### 정의
- 분할 정복(Divide and Conquer)전략을 사용하여 리스트를 작은 부분으로 나눈 후, 각각을 정렬하고 다시 병합하여 전체 리스트를 정렬하는 알고리즘
###### 동작 과정
1. 분할 (Divide)
	- 리스트를 반으로 나누어 더 이상 나눌 수 없을 때까지 분할한다.
2. 정복 (Conquer)
	- 각 하위 리스트를 개별적으로 정렬한다.
3. 병합 (Merge)
	- 정렬된 하위 리스트들을 병합하여 하나의 정렬된 리스트로 만든다.
###### 장점
- 시간 복잡도 O(n log n)
	- 항상 일정한 시간 복잡도를 유지하여 대규모 데이터셋에서도 안정적인 성능을 제공한다.
- 안전성
	- 동일한 값의 요소들이 정렬 후에도 원래의 순서를 유지한다.
- 큰 데이터 처리에 적합
	- 외부 정렬(external sorting)에서도 효율적으로 동작한다.
###### 단점
- 공간 복잡도 O(n)
	- 추가적인 메모리 공간이 필요하다.
- 작은 데이터셋에 비효율적
	- 데이터가 적을 경우, 다른 정렬 알고리즘보다 효율이 떨어질 수 있다.
##### 5. 퀵 정렬
- 피벗을 기준으로 리스트를 분할하여 정렬
#### 선택 정렬 알고리즘 선택 기준
##### 1. 데이터 크기
##### 2. 데이터의 초기 상태
##### 3. 알고리즘의 안전성
