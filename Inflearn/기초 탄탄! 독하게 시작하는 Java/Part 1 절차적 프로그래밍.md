# 시작에 앞서...
## 학습준비에 대해 가정하는 것들
## Windows OS 사용에 관한 정리
### bit stream
- 0과 1이 연속적으로 이어지면 stream이란 단어를 사용한다.
## 컴퓨터 구조에 대한 상식
## 실행의 다른 이름 '연산'
### 실행의 다른이름 '연산'
- 실행의 **실체는 연산**
- **연산에 필요한 정보는 메모리에서 가져와야함**
****
# 목표는 취업
## 제대로 달리는 학습순서
## 현실적인 이야기, 취업
## 개발자의 기본기
****
# 프로그래밍 언어의 시작
## 고급어와 저급어 그리고 JVM
### 고급어와 저급어
#### 저급어
- CPU가 인식 할 수 있는 명령어는 기계어
#### 고급어
- 장치에 의존적인 기계어를 사람이 이해하기 용이한 문자열 표기로 정의한 것이 고급어
## 컴파일러 창시자에 관한 이야기
## 항, 식, 구문
### 항, 식, 구문
- 여러 항이 모여 식을 이룸
- 식은 평가 대상
	- (식을 평가하기 위해서는 계산(연산)을 해야한다.)
- 여러 식을 모아 하나의 구문을 이루며 고급어 기준 실행단위가 된다.
- 연속되는 구문을 위에서 아래로 순차적 실행
## 컴파일러와 인터프리터
### Compiler
- 고급어 소스코드를 기계어로 번역하는 프로그램
- 전체 소스코드를 모두 기계어로 변환한 후 실행
- 성능 최적화가 용이하여 다수 언어가 채택
- C, C++등이 해당
### Interpreter
- 고급어 소스코드를 직접 실행하는 프로그램이나 환경을 의미
- 보통 한번에 한 줄 단위로 실행
- 성능(특히 속도)면에서 컴파일러방식보다 느림
- JavaScript나 Python등이 여기에 해당
****
# 프로그램을 쓰다
## 사실은 '글쓰기'
### 프로그래밍에 대한 개념적 이해
- 프로그래밍 그자체는 절차적 순서를 기술한 글쓰기
- **논리적으로 하나씩 풀어내는 훈련이 필요**
- 최대한 단순하게 시작
### 우연에 맡기는...
- **부적격**
### 적확한 글쓰기가 필수이다.
## 초보탈출 핵심전략! 변수와 상수 파악하기
### 상수리
- 연산식을 기술하는 시점에 값이 정해진 수
- 값이 확정되어 앞으로 변할 가능성이 없는 수
- 리터럴 (상수)
	- `'A'`, `"Hello"` 등등...
- 심볼릭 상수
	- `final`
### 변수
- 연산식을 기술하는 시점에 값이 정해지지 않은 수
- 구체화하지 않았거나 앞으로 변경될 가능성이 있는 수 (혹은 미지의 수)
- 개발자가 **메모리를 사용하는 가장 일반적인 방법**
- 구체적으로 결정되는 값에 따라 연산의 내용이 달라질 수 있는 원인으로 작용
## 경우의 수 그리고 흐름제어
### 변수
#### 범위
#### 경우의 수 그리고 흐름제어
## 함수의 탄생
### 루틴 == 프로시저 == 함수
- 거의 같은 의미를 가진다.
- 단위화된 절차
****
# 개발환경 구축
## JDK와 JRE
### JDK
- Java Development Kit
	- JRE를 포함
	- 컴파일러 등 프로그램 개발도구가 포함
	- 버전 중요(언어버전과 일치)
- Java SE 스펙 준수
	- Open JDK, Oracle JDK
### JRE
- Java Runtime Environment
	- Java 프로그램을 실행하는데 필요한 패키지
- 포함사항
	- JVM, 각종 명령
	- 클래스 라이브러리
## IntelliJ 다운로드 및 설치
## IntelliJ 실행 및 환경변수 추가
### 시점
#### Compile
- 번역
#### Link
#### Runtime
## 주요 단축키와 첫 번째 예제
## 반드시 알아야 할 중요한 시점
### 중요한 시점
#### 빌드 타임 (컴파일 타임 포함)
- `.java` 소스코드를 `.class(Java byte code)`로 번역
- 외부 라이브러리 사용 시 Symbolic references만 존재하며 정적 빌드 개념은 없음
- 외부 라이브러르(클래스 파일)링크는 JVM에서 처리
#### 런타임 (링크 타임 포함)
- JVM의 Class Loader가 절차에 따라 Bytecode로 로딩 후 메모리에 적재 (링크 타임 역할)
- 추가 클래스 파일도 로드하고 링크
##### 링크 타임
- import한 class들을 `.class` 결합하는 타임
## C/C++ 개발 경험자를 위한 안내
****
# 독하게 시작하기
## Java의 특징과 JVM
### Java 특징
- JVM 기반에서 작동하는 OOP언어
- C/C++의 가장 큰 특징인 메모리 관리와 책임이슈를 구조적으로 제거
- OS(혹은 Platform)에 대한 의존성 없음
- 컴파일러, 인터프리터 특징을 모두 가짐
	- 하이브리드
### JVM
#### Big endian system
##### endian system?
- Little
- Big
#### JIT(Just In Time) compiler
- Java bytecode를 실제 기계어로 번역
- JVM이 반복되는 코드를 발견할 경우 효율을 높일 목적으로 사용
	- Intermediate code generator
	- Code optimizer
	- Target code generator
	- Profiler (Hotspot)
- 실행 기록을 모아 자주 사용되는 코드에 주로 적용 (반복문)
- 프로그램을 오래 실행 할 수록 성능개선에 유리
## CPU 수준 자료형 소개
### 하드웨어 수준 자료형
#### 정수
- bit수에 따라 표현 범위 결정
- 2의 보수를 더하는 방식으로 뺄셈 구현
#### IEEE 754 기반 실수
- IEEE 754는 오차를 인정한다.
- 단정도 (float)
- 배정도 (double, 소수점 이하 15번째 자리까지 유효)
- 특수정도
## 실수형과 부동소수점 오차
### 실수형
- IEEE(Institute of Electrical and Electronics Engineers, 전기전자 기술자협회)가 규정한 표준 사용
	- IEEE 754 표준
- 소수점 이하 정보를 표시할 수 형식
- 부동 소수점 표현
- 두 정수 사이에는 무수히 많은 실수가 존재하기 때문에 일정 수준이 오류(부동소수점 오차)를 인정함
### 부동소수점 오차
#### 4.999998은 5.0과 같다고 할 수 있나?
- 단정도 일 경우 둘은 같다고 할 수 있고
- 배정도 형식일 경우 아니라고 말할 수 있다.
## Java의 자료형
### 기본형(Primitive type)
- 메모리 영역은 Stack
#### 정수
- `byte`(1 byte), `short`(2 byte), `int`(4 byte), `long`(8 byte)
- `char`(2 byte)
	- **0~65535 범위 유니코드(인코딩)**
#### 실수
- `float`(4 byte), `double`(8 byte)
#### 논리
- `boolean`(true, false)
### 유도형(Non-primitive or Derived type
- 메모리 영역 Heap
- Java에서 객체로 언급하는 대상
#### String
- 문자열을 다루기 위한 클래스
#### Class
- Array, List, Queue, Stack
- Interface
### 그 외 형식
- C언어 기준 Java는 정확히 언급하지는 않는다.
#### 무치형
- void
#### 함수형
- testFunc(int a)
## 객체, 클래스, 인스턴스, 참조 - 용어정리
### 객체, 클래스, 인스턴스
#### 객체(Object)
- 특정 목적을 가진 코드와 연산에 필요한 자료(변수)들을 한 세트로 묶어 구현할 대상
#### Class
- 객체를 기술하기 위한 문법으로 새로운 자료형이 될 수 있음
#### 인스턴스
- 특정 자료형에 대한 변수
## 문자와 문자(배)열 및 인코딩
### 문자와 문자열
- 영문 혹은 한글 한 글자를 `'문자'`로 규정
- 문자를 연이어진 배열 형태로 나열하면 `'문자(배)열'`
### Unicode와 인코딩 규칙
- C언어의 문자열은 MBCS(Multi-bytes Character Sets)과 Unicode 문자열로 나눔
	- Java에서 문자열의 끝은 NULL이 아니다.
- 유니코드는 한글 영문 모두 한 글자가 2바이트
- Java는 기본적으로 UTF-16 BE 체계와 Modified UTF-8 체계 병행
[[문자를 다루는 인코딩 규칙에 대한 모든 것!]]
****
# 변수와 주석문
## 변수 이름 - 식별자
### 변수 이름(식별자, Identifier) 작성 규칙
- 이름의 다른 표현은 식별자
- 영문 대/소문자, '\_', 숫자 가능
- 첫 글자는 숫자 사용 불가 (식으로 인식)
- 이름 중간에 공백 문자 사용 불가
- 예약어 사용 불가
- 너무 긴 이름 금지 (권장 사항)
	- 카멜 표기법 권장
- 의미를 알 수 없는 이름 하지말 것
## 변수 종류와 Stack 그리고 GC의 원리
### 변수 종류 및 사용
#### 지역변수
- 접근성에 따른 분류
- static 선언이 없다면 자동변수(Java 기준은 아니다. C/C++ 기준)이며 Stack 사용
#### 매개변수
- 함수 매개변수로 접근성은 지역
#### 인스턴스 변수(멤버 변수)
#### 클래스 변수
## 주석문
### 코드와 주석
- 프로그램 코드에 **메모**를 남기는 문법
	- 유지보수성 극대화
- 프로그램 코드에 포함되지 않음
	- 코드와 주석은 반드시 **동기화** 할 것!
****
# 콘솔 입/출력
## 콘솔이란?
### Console과 CLI
- CLI(Command Line Interface) 기반 HCI(Human Computer Interface)는 키보드 입력으로 구현
- 키보드 입력 시 그 값은 메모리(I/O Buffer)에 연속적으로 저장
- I/O Buffer에서 글자(혹은 키코드) 단위로 처리
## 키코드 값 읽기
### 콘솔 입력 키코드 값 읽기
- 키코드 값은 대부분 ASCII 코드 값과 일치
- 1byte씩 읽어서 값을 반환
- 한글 한 글자는 2바이트
## 또 생각하는 Java 인코딩 규칙
### UTF-8
- 유니코드 값을 1~4바이트로 가변 인코딩
### Java 인코딩 규칙
- Java 환경에서 문자열은 UTF-16 BE(Big Endian)로 인코딩
- 문자열 처리 과정에서 UTF-16 BE를 Modified UTF-8로 변경해 처리
- 문자열의 끝인 NULL은 본래 UTF-8 규칙으로 인코딩 시 0이지만 Modified UTF-8로 인코딩할 경우 0xC080
## Scanner를 이용한 정수, 실수 입/출력
## 문자열 입/출력
## 형식문자와 이스케이프 시퀀스
### 이스케이프 시퀀스(Escape squence)

| 문자  | 의미              |
| --- | --------------- |
| \\\ | Backslash 문자 자체 |
| \\" |                 |
| \\b | Backspace       |
| \\f | Form feed       |
| \\n | New line        |
| \\r | Carriage return |
| \\t | Tab             |
### 형식 문자
#### %d
- 10진수(정수형)
#### %c
- 유니코드 한 문자
#### %s
- 문자열
#### %f
- 실수형
#### %t
- 날짜시간
#### %x
- 16진수
## [필수실습 8-1] 나이와 영문 이름 입/출력하기
****
# 연산자 - 첫 번째
## 연산자 기본 이론
### 연산자
- CPU 연산과 직결되는 문법
- 연산자 자체는 하나의 항
- 여러 항을 모아 연산식 작성
	- 여러 항을 **소괄호로 묶어 하나의 항**처럼 처리
- 연산자와 피연산자로 구성
- 피연산자가 2개 항이면 2항 연산자
	- 하나는 단항, 셋이면 3항 연산자
#### 종류
- 산술 연산자 `+, -, *, /, %`
- 대입 연산자 `a = b`
- 단항 증/감 연산자 `++, --`
- 형변환 연산자 
- 비트(논리) 연산자
- 관계, 논리 연산자, 조건 연산자
- instanceof, new 연산자

| 순위  | 연산자                             | 결합성    |
| --- | ------------------------------- | ------ |
| 1   | `() []`                         | L -> R |
| 2   | `! ++ -- (type) -`              | L <- R |
| 3   | `* % /`                         | L -> R |
| 4   | `+ -`                           | L -> R |
| 5   | `<< >> >>>`                     | L -> R |
| 6   | `< > <= >=`                     | L -> R |
| 7   | `== !=`                         | L -> R |
| 8   | `&`                             | L -> R |
| 9   | `^`                             | L -> R |
| 10  | `\|`                            | L -> R |
| 11  | `&&`                            | L -> R |
| 12  | `\|\|`                          | L -> R |
| 13  | `? :`                           | L <- R |
| 14  | `= += -= *= %= /= &= \|= ^= ~=` | L <- R |
| 15  | `,`                             | L -> R |
### 연산자 결합성
- 우선순위가 같은 경우 어떤 것을 먼저 연산할 것인지 나타내는 것
- `3 + 4 + 5` 연산에서 두 덧셈 연산은 우선 순위가 같고 결합성이 L -> R이므로 `3 + 4`연산을 먼저 수행
## 산술 연산자와 형승격
### 산술 연산자
`+, -, *, /, %`
- 대표적인 2항 연산자
- 연산의 결과로 **임시결과** 발생
- 정수 간 나눗셈의 결과는 반드시 정수가 되며 소수점이하는 절사
### 형승격(Type promotion)
- 임시결과는 피연산자 표현범위 이상의 표현이 가능해야 함
- `char + int` 결과는 int
- `double * int` 결과는 double
- `4 + 3`과 `4.0 + 3`은 전혀 다른 연산
- 문자열(String)과 숫자 연산(+)의 결과는 문자열
## 문자열 덧셈
## 나누기 연산의 원리
### 나머지 연산
- `x % 2`
	- 2로나눠서 나머지를 구하면 뭐가됫든 경우의수는 2개로 축약
## [필수실습 9-1] 평균값 구하기
## [필수실습 9-2] 시, 분, 초 계산하기
## 단순 대입 연산자
### 대입 연산자
#### 단순 대입연산자 (`=`)
- l-value = locator-value
- 두 피연산자 중 오른쪽 피연산자(r-value)의 값을 왼쪽 피연산자(l-value)에 저장하는 연산자
- **l-value는 Overwrite가 발생하며 기존 값이 사라짐**
- 상수는 l-value가 될 수 없음
- 변수 선언 시 사용할 경우 초깃값 기술을 위한 문법
## 변수를 상수화 하는 final
### final
- 변수이나 한 번 정한값이 바뀌지 않도록 강제로 상수화
- 심볼릭 상수를 정의하기 위한 문법
- 컴파일러가 코드를 최적화 할 수 있도록 도와주며 코드의 직관성(읽기 좋은 코드) 및 유지보수성을 높여줌
## [필수실습 9-3] 두 변수 값 교환
## 복합 대입 연산자
### 복합 대입 연산자
- `+= -= *= %= /= &= |= ^= ~=`
- 기능상 단순 대입 연산자와 산술 연산자, 비트연산자가 조합된 연산자
- 누적 연산시 += 연산자 활용
## [필수실습 9-4] 세 정수 총합 계산하기(누산)
****
# 연산자 - 두 번째
## 단항 증/감 연산자
### 단항 증/감 연산자
- 피연산자에 저장된 값을 1씩 증가시키거나 감소시키는 연산
- 피연산자는 반드시 쓰기가 가능한 l-value라야 함
- 전위식, 후위식 표기가 가능하며
- 후위식이면 연산자 우선순위는 전체 식을 평가한 후로 밀림
## 형변환 연산자
### 형변환 연산자
- 피연산자의 형식을 강제로 변경해주는 단항 연산자
	- `double a = 3.3;`
	- `int b = (int) a;`
- 부적절한 변환 시 정보가 유실될 수 있음
## 비트 (논리) 연산자
### 비트 (논리) 연산자
- `&(AND), |(OR), ^(XOR), ~, << (짝수 곱셈이 일어난다), >> (나누기), >>>`
- 자료를 비트 단위로 논리 식을 수행하는 연산
- 보통 2진수로 변환해 판단
- AND, OR, NOT, XOR, Shift left, Shift right
- NOT은 단항, 나머지는 모두 2항 연산자
### 비트 마스크 연산
- `int data = 0x11223344; data & 0x0000FFFF`
- 데이터에서 특정 영역의 값이 모두 0이 되도록 지우는 연산
- AND의 특징을 이용
- 0과 AND연산을 수행하면 결과는 무조건 0
- JVM은 Big endian 시스템
## [필수실습 10-1] 뺄셈 연산 직접 구현하기
****
# 기본 제어문

****
# 반복문

****
# 배열과 프로그래밍

****
# 메서드 (함수)

****