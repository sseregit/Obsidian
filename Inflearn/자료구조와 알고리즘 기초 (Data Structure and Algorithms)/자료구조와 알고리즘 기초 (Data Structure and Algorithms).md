# 섹션 1. 자료구조와 알고리즘 기초 (Data Structure and Algorithms)
## 1. 오리엔테이션 (OT)
### 자료 구조(Data Structures)
- 데이터를 정리하고 저장하는 방법
### 알고리즘(Algorithm)
- 어떤 문제를 해결하기 위한 단계적인 절차
### 자료 구조와 알고리즘의 관계
#### 자료 구조
- 데이터 저장 및 조직화를 담당
#### 알고리즘
- 이러한 데이터를 처리하고 조작하는 로직을 담당
### 자료 구조(Data Structures)란?
- 컴퓨터에서 데이터를 어떻게 메모리에 표현하고 정리할 것인지에 대한 방법을 연구하는 분야
- 개발자가 데이터를 효율적으로 사용할 수 있도록 정리하는 방식
#### 선형 자료구조
- 데이터를 연속적인 메모리 공간에 저장한느 방식
- 배열이나 리스트가 대표적
#### 비선형 자료구조
- 데이터가 연속적인 메모리 공간에 있지 않고 메모리 여기저기에 흩어져 있는 형태
- 트리, 그래프가 대표적
## 2. 배열과 리스트
### 자료 구조(Data Structure)
#### 단순(Primitive)
- integer, float, string, boolean...
#### 복합(Non-Primitive)
##### 선형(Linear)
###### 정적자료구조(Static)
- 생성 시 크기가 고정되는 형태
- 배열등
###### 동적자료구조(Dynamic)
- 실행 중에 크기가 유동적으로 변할 수 있다.
- 리스트, 스택, 큐, 연결 리스트등
##### 비선형(Non-Linear)
- 트리와 그래프가 대표적
##### 복합 자료구조의 또다른 분류
###### 내장형
- 이미 프로그래밍 언어에서 제공하는 자료구조
- 배열, 리스트
###### 사용자정의형
- 프로그래머가 직접 구현하여 사용하는 것
- 스택, 큐, 연결리스트, 트리, 그래프
### 배열
- 리스트에 비해 더 컴팩트하고 메모리 효율적인 저수준 데이터 구조
`항목의 메모리 위치 = 배열 시작 주소 + (index * 4)`
#### 장점
- 같은 타입을 갖는 데이터들이 연속한 위치에 있다.
- 데이터들이 연속된 메모리 공간에 저장되어 있고 인덱스를 통해 순차적으로 접근할 수 있다. 이 특성 덕분에 배열은 반복문과 함께 사용할 때 매우 효율적이다.
#### 단점
- 데이터의 삽입과 삭제가 비효율적이다.
- 고정된 크기
- 메모리 연속성 요구
### 리스트
- 데이터 삽입, 삭제가 훨씬 자유롭지만, 배열보다 처리 시간이 더 걸리는 고수준 데이터 구조
### 추상 자료형(ADT, Abstract Data Type)
- 자료와 그 자료를 다루는 연산에 대한 개념을 정의한 것
- 어떻게 구현되었는지 보다는 어떤 기능을 제공하는지에 집중하는 것이 핵심
- 오류에 대한 처리 방법 설명
#### 추상화
- 어떤 새로운 자료형을 정의하려면 필수적이고 중요한 특징만 골라서, 단순화 시키는 작업
## 3. 스택
### 스택(Stack)
- 후입선출(LIFO, Last-In, First-Out)
## 4. 큐
### 큐(Queue)
- 선입선출(FIFO, First-In, First-Out)
## 5. 연결 리스트
### 연결 리스트
- 각 데이터가 다음 데이터의 위치를 가리키는 형태로된 자료 구조
- 데이터의 삽입과 삭제가 유연하다
- 배열이나 리스트의 단점을 보완하기 위해 만들어진 자료 구조
#### 단순 연결리스트(Singly Linked List)
- 하나의 방향으로만 연결된 리스트
#### 원형 연결리스트(circular Linked List)
- 단순 연결 리스트에서 tail 노드의 링크를 약간 다르게 변형한 형태
	- tail노드가 head node를 바라보고 있다.
- 아무 node에서 시작해도, 링크를 타고 이동하면, 다른 모든 node를 접근할 수 있다는 장점이 있다.
- 하지만 node를 순서대로 방문할 때, 종료 조건이 되는 node를 찾는 것은 조금 어려울 수 있다.
#### 이중 연결리스트(doubly Linked List)
- 하나의 노드가 이전 노드와 다음 노드의 링크를 모두 갖도록 하는 형태
- prev 링크와 next 링크를 가지고 있어 어떤 노드든 이전 노드와 다음 노드를 바로 찾아갈 수 있는 장점이 있다.
## 6. 트리
### 트리(Tree) 구조
- 노드(Node)와 간선(Edge)로 이루어진 자료 구조
- 사이클이 없다
	- 한 노드에서 출발해 다른 노드를 거쳐 다시 그 출발점으로 돌아오는 경로가 없다
#### 노드(Node)
- 트리의 각 점
##### 루트 노드(Root Node)
- 하나의 시작점
- 이 루트 노드에서 트리의 모든 가지가 뻗어 나가기 시작한다.
##### 리프 노드(Leaf Node)
- 더 이상 자식이 없는 노드
##### 부모 노드(Parent Node)
- 하나의 노드가 다른 노드에 연결되어 있을 경우 그 상위 노드를 부르는 명칭
##### 자식 노드(Child Node)
- 하위 노드
##### 형제 노드(Siblings Node)
- 같은 부모노드를 가진 노드들
##### 조상 노드(Ancestor Node)
- 어떤 한 노드를 기준으로, 위로 루트 노드까지 경로 상에 있는 모든 노드
##### 자손 노드(descendent Node)
- 어떤 한 노드를 기준으로, 아래로 경로 상에 있는 모든 노드
#### 간선(edge)
- 그 노드와 노드를 연결하는 선
### 트리(Tree) 종류
#### 일반트리(General Tree)
- 트리 구조에서 각 노드가 자식 노드를 몇 개나 가질 수 있는지에 대한 제한이 없는 트리
#### 이진트리(Binary Tree)
- 각 노드가 최대 두개의 자식을 가지는 트리
- 데이터를 검색하고 삽입하는 데 효율적인 자료구조
##### 포화이진트리(Full Binary Tree)
- 모든 노드가 자식 노드를 두 개씩 가진 이진 트리
##### 완전이진트리(Complete Binary Tree)
- 마지막 레벨을 제외한 모든 레벨이 꽉찬 상태
- 여기서 레벨이란 트리의 수평방향
- 마지막 레벨에서는 오른쪽으로 노드가 비어 있을 수 있지만, 그외의 모든 레벨은 가득 차 있어야 한다.
##### 균형이진트리(Balanced Binary Tree)
- 트리의 왼쪽과 오른쪽 부분 트리의 높이 차이가 1이하(레벨)로 유지되는 트리
##### 편향이진트리(Skewed Binary Tree)
- 트리의 모든 노드가 한쪽 자식만 가지는 트리
- 왼쪽 또는 오른쪽으로만 자식 노드가 쭉 이어진 형태로 일종의 연결 리스트처럼 보이기도 한다.
- 트리의 높이가 노드 수와 같아지므로, 탐색, 삽입, 삭제 연산에서 비효율적일 수 있다.
#### 이진 탐색 트리(BST, Binary Search Tree)
- 이진 트리의 특별한 형태로, 모든 왼쪽 자식은 부모보다 작은 값을, 모든 오른쪽 자식은 부모보다 큰 값을 가지게 된다.
### 트리 순회(Tree Traversal)
- 트리의 모든 노드를 특정한 순서대로 한 번씩 방문하는 과정
#### 전위 순회(depth first traversal or Preorder Traverse)
- Root 노드를 방문한 후 왼쪽 서브 트리를 순차적으로 둘러본 뒤 오른쪽 서브트리를 순회하는 것
- Root -> Left -> Right 순
#### 중위 순회(symmetric traversal or Inorder Traverse)
- 루트를 가운데에 두고 순회한다 왼쪽 서브 트리를 모두 순회한 후, 루트를 방문하고, 그 후 오른쪽 서브 트리를 모두 순회하는 방법이다.
- Left -> Root -> Right
- 이진 탐색 트리에서 오름차순 또는 내림차순으로 값을 가져올 때 사용한다.
#### 후위 순회(Postorder Traverse)
- 자식들을 모두 방문한 후에 마지막에 루트 노드를 방문하는 방식
- Left -> Right -> Root
### 이진트리 표현
#### 배열로 표현하기
- 트리의 노드를 배열의 인덱스로 매핑하는 방법
- 계산의 편의를 위해 루트의 노드 번호를 0으로 한다.
- 왼쪽 자식은 부모 노드의 인덱스 i에 대해 2 * i + 1로 한다.
- 오른쪽 자식은 부모 노드의 인덱스 i에 대해 2 * i + 2로 한다.
- 구현이 매우 간단함
- 포화이진트리와 완전 이진트리에 가장 적합하다.
	- 배열 항목 사이에 빈칸이 발생하지 않기 때문에
##### 단점
- 배열의 크기에 따라 트리의 높이가 제한되는 단점
#### 연결 리스트로 표현하기
- 각 노드당 두 개의 링크를 가지는 것으로 표현한다.
- 이진탐색트리와 같이 삽입과 삭제가 빈번하게 발생하는 경우이거나, 데이터가 많고, 트리가 불균형할 가능성이 높을 경우에는 연결리스트로 사용하는 것을 권장한다.
##### 장점
- 필요한 만큼만 메모리를 사용할 수 있다
- 복잡한 트리 구조를 시작적으로 구현하는 것이 용이하다.
##### 단점
- 포인터를 사용해야하므로, 배열보다 구현이 복잡하다.
- 탐색 속도도 배열보다 느리다.
## 7. 그래프
