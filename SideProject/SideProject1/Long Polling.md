[What is HTTP Long Polling — and is it still relevant today?](https://ably.com/topic/long-polling)

클라이언트와 서버 간의 실시간 통신을 HTTP를 통해 구현하는 기법

서버에 새로운 데이터가 생길 때까지 연결을 열린 상태로 유지하여, 클라이언트가 즉시 업데이트를 받을 수 있도록 한다.

WebSocket이 표준화되기 이전에 실용적인 해결책으로 등장.

오늘날에도 특히 제약이 있는 환경이나 레거시 시스템에서는 여전히 유효하다.

클라이언트가 요청하고 서버가 응답하는 단방향 기반의 웹 플랫폼 위에서 양방향 애플리케이션을 구축하는 문제를 해결해준다.

works start
클라이언트가 서버로 GET 요청을 보낸다. 
	특정 응답을 요청하는 것이 아니라, 준비되는 대로 어떤 응답이든 받겠다는 의미

시간이 흐른다.
	HTTP 타임아웃은 Keep-Alive 헤더를 사용하여 조정할 수 있다. 이를 활용해 매우 길거나 무기한에 가까운 타임아웃을 설정하여, 서버가 즉시 응답하지 않더라도 요청이 열린 상태로 유지되도록 한다.

서버가 응답한다.
	서버에 보낼 데이터가 생기면 응답과 함께 연결을 종료한다.

사이클의 반복
works end

HTTP 롱 폴링의 성공할 수 있었던 핵심은, 클라이언트 측에서 기본 웹의 구조를 전혀 변경하지 않는다는 점이다.

대부분의 부담은 서버 측에 있다. 특히 수십만 개의 연결 상태를 관리하는 것은 자원을 많이 소모한다.

롱 폴링의 뚜렷한 한계 start
각 열린 요청은 서버 자원을 점유한다.
	비동기 환경에서도 수천에서 수백만 개에 이르는 롱 폴링 연결을 동시에 관리하려면 메모리와 연산 자원이 크게 증가한다.

타임아웃과 재시도가 병목이 된다.
	시스템이 높은 부하를 받을 경우, 응답 지연과 재시도 폭주가 백엔드 시스템을 마비시킬 수 있다.

인프라의 예측 가능한 확장이 어려워진다
	지속적인 연결을 위한 프로토콜(WebSocket 등)과 달리, 롱 폴링은 멀티플렉싱이나 연결 재사용을 지원하지 않아 자원 활용이 비효율적이다.
롱 폴링의 뚜렷한 한계 end

장점 start
넓은 호환성
	모든 최신 브라우저, HTTP 클라이언트, 프록시 환경에서 동작한다.

방화벽 친화적
	WebSocket 연결을 차단하는 다양한 제약을 우회할 수 있다.

간단한 구현
	표준 HTTP 의미론과 요청/응답 흐름을 그대로 사용한다.

신뢰할 수 있는 대체 수단
	양방향 프로토콜을 지원하지 않는 환경에서 특히 유용하다.
장점 end

단점 start
부하에 비효율적
	각 클라이언트가 열린 연결을 유지하므로 서버 자원(스레드, 메모리)을 소비한다.

WebSocket보다 높은 지연시간
	서버 응답 시간이나 타임아웃 설정이 정밀하지 않을 경우 특히 그렇다.

복잡한 클라이언트 로직
	재시도 처리, 지수적 백오프, 타임아웃 관리를 요구한다.

확장성 부족
	대규모 사용자 기반을 수평 확장하려면 상당한 운영 부담이 따른다.

메시지 도착 순서 및 전달 보장 불가
	메시지가 올바른 순서로 도착하거나, 심지어 도착하는 것 자체를 보장하지 않는다.
단점 end

사용에 적합한 경우 start
WebSocket 연결이 프록시나 방화벽에 의해 차단되는 경우 - 특히 기업 네트워크 환경

구형 브라우저나 레거시 클라이언트 SDK와 함께 작업할 때

애플리케이션이 드물거나 간헐적으로 실시간 업데이트를 전송하는 경우

프로토타입이나 최소 기능 제품(MVP)을 위한 빠르고 간단한 실시간 기능이 필요할 때
사용에 적합한 경우 end

사용에 적합하지 않은 경우 start
수천 명 이상의 동시 사용자를 지원해야 할 때

애플리케이션이 낮은 지연시간과 높은 빈도의 업데이트를 요구할 경우

클라우드 네이티브 환경에서 비용 효율적인 확장을 목표로할 때

특히 모바일 환경에서 클라이언트 및 서버 로직을 단순화하고 싶을 때
사용에 적합하지 않은 경우 end

