# 강의 소개와 자료

****
# 문자 인코딩
## 프로젝트 환경 구성
## 컴퓨터와 데이터
## 컴퓨터와 문자 인코딩1
### ASCII 문자 집합
- 각 컴퓨터 회사가 독자적인 문자 집합을 사용한다면, 서로 다른 컴퓨터 간에 문자가 올바르게 표시되지 않는 문제가 발생할 수 있다. 이러한 호환성 문제를 해결하기 위해 ASCII(American Standard Code for Information Interchange)라는 표준 문자 집합이 1960년도에 개발되었다.
### ISO_8859_1
- 1980년도
- 기존 ASCII에 서유럽 문자의 추가 필요
- 국제 표준화 기구에서 서유럽 문자를 추가한 새로운 문자 규격을 만듬
- `ISO_8859_1`, `LATIN1`, `ISO-LATIN-1`등으로 불린다.
- 기존 ASCII 문자 집합과 호환 가능
### EUC-KR
- 1980년도
- 초창기 등장한 한글 문자 집합
- 모든 한글을 담는 것 보다는 자주 사용하는 한글 2350개만 포함해서 만들었따.
- 한글의 글자는 아주 많기 때문에 256가지만 표현할 수 있는 1byte로 표현하는 것은 불가능하다.
- 2byte(16bit)를 사용하면 총 65536가지 표현 가능
- ASCII는 1byte, 한글은 2byte를 사용한다
	- 영어를 사용하면 1byte를, 한글을 사용하면 2byte를 메모리에 저장한다.
- 기존 ASCII 문자 집합과 호환 가능
### MS949
- 1990년도
- 마이크로소프트가 EUC-KR을 확장하여 만든 인코딩
- 한글 초성, 중성, 종성 모두 조합하면 가능한 한글의 수는 총 11,172자
- EUC-KR은 '쀍', '삡'과 같이 드물게 사용하는 음절을 표현하지 못함
- 기존 EUC-KR과 호환을 이루면서 한글 11,172자를 모두 수용하도록 만든 것이 MS949
- 윈도우 시스템에서 계속 사용됨
## 컴퓨터와 문자 인코딩2
### 유니코드의 등장
- 전 세계의 모든 문자들을 단일 문자 세트로 표현할 수 있는 유니코드(Unicode) 표준이 1990년대에 도입되었다.
- 하나의 문자 세트에 전 세계 대부분의 언어를 넣어보자! 이름하여 유니코드 -> Uni(Universal) -> 전 세계적인 코드!
- 전 세계의 모든 문자와 기호를 하나의 표준으로 통합하여 표현할 수 있는 문자 집합을 만드는 것
- UTF-16, UTF-8의 시작
- 두 표준이 비슷하게 등장, 초반에는 UTF-16이 인기
#### UTF-16
- 1990년도
- 16bit(2byte) 기반
- 자주 사용하는 기본 다국어들은 2byte로 표현
- 그 외는 4byte로 표현
- 초반에는 UTF-16이 인기, 이 시기에 등장한 자바도 언어 내부적으로 문자를 표현할 때 UTF-16을 사용한다. 그래서 자바의 `char`타입이 2byte를 사용함
##### 단점
- ASCII 영문도 2byte를 사용한다. **ASCII와 호환되지 않음**
- UTF-16을 사용한다면 영문의 경우 다른 문자 집합 보다 2배의 메모리를 더 사용한다.
#### UTF-8
- 1990년도
- 8bit(1byte) 기반, 가변길이 인코딩
- 1byte ~ 4byte를 사용해서 문자를 인코딩
	- 1byte: ASCII, 영문, 기본 라틴 문자
	- 2byte: 그리스어, 히브리어 라틴 확장 문자
	- 3byte: 한글, 한자, 일본어
	- 4byte: 이모지, 고대문자등
- **ASCII 문자는 1바이트로 표현, ASCII 호환**
##### 단점
- 상대적으로 사용이 복잡함
- UTF-16은 대부분의 기본 문자들이 2바이트로 표현되기 때문에, 문자열의 특정 문자에 접근하거나 문자 수르 세는 작업이 상대적으로 간단하다. 반 면 UTF-8은에서는 각 문자가 가변 길이로 인코딩되므로 이런 작업이 더 복잡함.
- ASCII를 제외한 일부 언어에서 더 많은 용량 사용
##### 현대의 사실상 표준 인코딩 기술
- 1990년도 후반 ~ 2000년도 초반에 인터넷과 웹이 빠르게 성장하면서 저변 확대
- 2008년 W3C 웹 표준에 UTF-8 채택
- 현재 대부분의 웹사이트와 애플리케이션에서 기본 인코딩으로 사용
### 정리
**UTF-8이 현대의 사실상 표준 인코딩 기술이 된 이유**
#### 저장 공간 절약과 네트워크 효율성
- 서양 문자에 대해 1바이트를 사용하기 때문에 영문 텍스트에서 효율적
- 데이터를 네트워크로 전달할 때는 매우 큰 효율의 차이르 보인다.
- 웹에 있는 문서의 80% 이상은 영문 문서이다.
#### ASCII와의 호환성
- ASCII와 호환 되면서 전 세계의 모든 문자를 표현할 수 있다.
## 문자 집합 조회
## 문자 인코딩 예제1
### 자바에서의 byte 표현
- 자바의 byte 타입은 양수와 음수를 모두 표현할 수 있다.
- 자바의 byte는 첫 번째 비트(bit)가 0이면 양수, 1이면 음수로 간주된다.
- 결국 자바의 byte는 256가지 값을 표현하지만, 표현 가능한 숫자의 범위는 `-128 ~ 127`이다.
## 문자 인코딩 예제2
### 한글이 깨지는 가장 큰 2가지 이유
#### EUC-KR(MS949), UTF-8이 서로 호환되지 않음
- 한글이 깨지는 대부분의 문제는 UTF-8로 인코딩한 한글을 EUC_KR(MS949)로 디코딩하거나 또는 EUC-KR(MS949)로 인코딩한 한글을 UTF-8로 디코딩할 때 발생한다.
#### EUC-KR(MS949) 또는 UTF-8로 인코딩한 한글을 `ISO-8859-1`로 디코딩 할 때
- EUC-KR(MS949) 또는 UTF-8로 인코딩한 한글을 한글을 지원하지 않는 `ISO-8859-1`로 디코딩 할 때 발생한다.
## 정리

****
# I/O 기본1
## 스트림 시작1
### `read()`가 int를 반환하는 이유
- 참고로 `write()`의 경우도 비슷한 이유로 `int`타입을 입력 받는다.
#### 부호 없는 바이트 표현
- 자바에서 `byte`는 부호 있는 8비트 값(-128 ~ 127)이다.
- `int`로 반환함으로써 0에서 255까지의 모든 가능한 바이트 값을 부호 없이 표현할 수 있다.
#### EOF(End of File) 표시
- byte를 표현하려면 256 종류의 값을 모두 사용해야 한다.
- 자바의 `byte`는 -128에서 127까지 256종류의 값만 가질 수 있어, EOF를 위한 특별한 값을 할당하기 어렵다.
- `int`는 0~255까지 모든 가능한 바이트 값을 표현하고,여기에 추가로 -1을 반환하여 스트림의 끝(EOF)을 나타낼 수 있다.
## 스트림 시작2
### 부분으로 나누어 읽기 vs 전체 읽기
#### `read(byte[], offset, length)`
- 스트림의 내용을 부분적으로 읽거나, 읽은 내용을 처리하면서 스트림을 계속해서 읽어야 할 경우에 적합하다.
- 메모리 사용량을 제어할 수 있다.
- 예시) 파일이나 스트림에서 일정한 크기의 데이터를 반복적으로 읽어야 할 때 유용하다. 예를 들어 대용량 파일을 처리할 때, 한번에 메모리에 로드하기보다는 이 메서드를 사용하여 파일을 조각조각 읽어들일 수 있다.
- 100M의 파일을 1M 단위로 나누어 읽고 처리하는 방식을 사용하면 한 번에 최대 1M의 메모리만 사용한다.
#### `readAllBytes()`
- 한번의 호출로 모든 데이터를 읽을 수 있어 편리하다.
- 작은 파일이나 메모리에 모든 내용을 올려서 처리해야 하는 경우에 적합하다.
- 메모리 사용량을 제어할 수 없다.
- 큰 파일의 경우 OutOfMemoryError가 발생할 수 있다.
## InputStream, OutputStream
### `InputStream`, `OutputStream`의 추상화의 장점
#### 일관성
- 모든 종류의 입출력 작업에 대해 동일한 인터페이스(여기서는 부모의 메서드)를 사용할 수 있어, 코드의 일관성이 유지된다.
#### 유연성
- 실제 데이터 소스나 목적지가 무엇인지에 관계없이 동일한 방식으로 코드를 작성할 수 있다. 예를 들어, 파일, 네트워크, 메모리 등 다양한 소스에 대해 동일한 메서드를 사용할 수 있다.
#### 확장성
- 새로운 유형의 입출력 스트림을 쉽게 추가할 수 있다.
#### 재사용성
- 다양한 스트림 클래스들을 조합하여 복잡한 입출력 작업을 수행할 수 있다. 예를 들어 `BufferedInputStream`을 사용하여 성능을 향상시키거나, `DataInputStream`을 사용하여 기본 데이터 타입을 쉽게 읽을 수 있다.이 부분은 뒤에서 설명한다.
#### 에러 처리
- 표준화된 예외 처리 메커니즘을 통해 일관된 방식으로 오류를 처리할 수 있다.
## 파일 입출력과 성능 최적화1 - 하나씩 쓰기
## 파일 입출력과 성능 최적화2 - 버퍼 활용
### 버퍼의 크기에 따른 쓰기 성능
- 버퍼의 크기가 커진다고 해서 속도가 계속 줄어들지는 않는다. 왜냐하면 디스크나 파일 시스템에서 데이터를 읽고 쓰는 기본 단위가 보통 4KB 또는 8KB이기 때문이다.
- 버퍼의 크기는 보통 4KB, 8KB 정도로 잡는 것이 효율적이다.
## 파일 입출력과 성능 최적화3 - Buffered 스트림 쓰기
### 기본 스트림, 보조 스트림
- `FileOutputStream`과 같이 단독으로 사용할 수 있는 스트림을 기본 스트림이라 한다.
- `BufferedOutputStream`과 같이 단독으로 사용할 수 없고, 보조 기능을 제공하는 스트림을 보조 스트림이라 한다.
## 파일 입출력과 성능 최적화4 - Buffered 스트림 읽기
## 파일 입출력과 성능 최적화5 - 한 번에 쓰기
## 정리
### 정리
- 파일의 크기가 크지 않아서, 메모리 사용에 큰 영향을 주지 않는다면 쉽고 빠르게 한 번에 처리하자.
- 성능이 중요하고 큰 파일을 나누어 처리해야 한다면, 버퍼를 직접 다루자
- 성능이 크게 중요하지 않고, 버퍼 기능이 필요하면 `BufferedXxx`를 사용하자
	- `BufferedXxx`는 동기화 코드가 들어있어서 스레드 안전하지만, 약간의 성능 저하가 있다.

****
# I/O 기본2
## 문자 다루기1 - 시작
## 문자 다루기2 - 스트림을 문자로
### OutputStreamWriter
- 스트림에 byte 대신에 문자를 저장할 수 있게 지원한다.
### InputStreamReader
- 스트림에 byte 대신에 문자를 읽을 수 있게 지원한다.
## 문자 다루기3 - Reader, Writer

자바는 byte를 다루는 I/O 클래스와 문자를 다루는 I/O 클래스를 둘로 나누어 두었다.
**모든 데이터는 byte 단위(숫자)로 저장된다.**
## 문자 다루기4 - BufferedReader
## 기타 스트림
## 정리
### 정리
#### 기본(기반, 메인) 스트림
- File, 메모리, 콘솔등에 직접 접근하는 스트림
- 단독으로 사용할 수 있다.
- 예) `FileInputStream`, `FileOutputStream`, `FileReader`, `FileWriter`, `ByteArrayInputStream`, `ByteArrayOutputStream`
#### 보조 스트림
- 기본 스트림을 도와주는 스트림
- 단독으로 사용할 수 없음,반드시 대상 스트림이 있어야 한다.
- 예) `BufferedInputStream`, `BufferedOutputStream`, `InputStreamReader`, `OutputSTreamWriter`, `DataOutputStream`, `DataInputStream`, `PrintStream`

****
# I/O 활용
## 회원 관리 예제1 - 메모리
## 회원 관리 예제2 - 파일에 보관
## 회원 관리 예제3 - DataStream
### DataStream 원리
- `readUTF()`로 문자를 읽어올 때 어떻게 값을 정확하게 읽어올 수 있는것 일까?
- `writeUTF()`는 UTF-8 형식으로 문자를 저장하는데, 저장할 때 2byte를 추가로 사용해서 앞에 글자의 길이를 저장해둔다. (65535) 길이까지만 사용 가능
- 자바의 `Int(Integer)`는 4byte를 사용하기 때문에 4byte를 사용해서 파일을 저장하고, 읽을 때도 4byte를 읽어서 복원한다.
## 회원 관리 예제4 - ObjectStream
### 객체 직렬화
- 자바 객체 직렬화(Serialization)는 메모리에 있는 객체 인스턴스를 바이트 스트림으로 변환하여 파일에 저장하거나 네트워크를 통해 전송할 수 있도록 하는 기능이다. 이 과정에서 객체의 상태를 유지하여 나중에 역직렬화(Deserialization)를 통해 원래의 객체로 복원할 수 있다.
#### Serializable 인터페이스
- 객체 직렬화를 사용하려면 직렬화하려는 클래스는 반드시 `Serializable`인터페이스를 구현해야 한다.
- 이 인터페이스는 아무런 기능이 없다. 단지 직렬화 가능한 클래스라는 것을 표시하기 위한 인터페이스일 뿐이다.
- 메서드 없이 단지 표시가 목적인 인터페이스를 마커 인터페이스라 한다.
##### `serialVersionUID`
- 객체 직렬화 버전을 관리한다.
##### `transient` 키워드
- `transient`가 붙어있는 필드는 직렬화 하지 않고 무시한다.
## XML, JSON, 데이터베이스
### 객체 직렬화의 한계
#### 객체 직렬화를 사용하지 않는 이유
##### 버전관리의 어려움
- 클래스 구조가 변경되면 이전에 직렬화된 객체와의 호환성 문제가 발생한다.
- serialVersionUID 관리가 복잡하다.
##### 플랫폼 종속성
- 자바 직렬화는 자바 플랫폼에 종속적이어서 다른 언어나 시스템과의 상호 운용성이 떨어진다.
##### 성능 이슈
- 직렬화/역직렬화 과정이 상대적으로 느리고 리소스를 많이 사용한다.
##### 유연성 부족
- 직렬화된 형식을 커스터마이즈하기 어렵다.
##### 크기 효율성
- 직렬화된 데이터의 크기가 상대적으로 크다.
### 직렬화 대안
#### 대안 1 - XML
#### 대안2 - JSON
#### 대안 3 - Protobuf, Avro - 더 적은 용량, 더 빠른 성능
- JSON은 거의 모든곳에서 호환이 가능하고, 사람이 읽고 쓰기 쉬운 텍스트 기반 포맷이어서 디버깅과 개발이 쉽다.
- 만약 매우 작은 용량으로 더 빠른 속도가 필요하다면 Protobuf, Avro 같은 대안 기술이 있다.
- 이런 기술은 호환성은 떨어지지만 byte 기반에, 용량과 성능 최적화가 되어 있으므로 매우 빠르다.
- 다만 byte 기반이므로 JSON처럼 사람이 직접 읽기는 어렵다.
### 정리
- 자바 객체 직렬화는 대부분 사용하지 않는다.
- JSON이 사실상 표준이다. JSON을 먼저 고려하자.
- 성능 최적화가 매우 중요하다면 Protobuf, Avro 같은 기술을 고려하자. (대부분 JSON만 사용해도 충분하다.)
## 정리


****
# File, Files
## File
## Files
### Files의 특징
- 성능과 편의성이 모두 개선되었다.
- `File`은 과거의 호환을 유지하기 위해 남겨둔 기능이다. 이제는 `Files`사용을 먼저 고려하자.
- 여기에는 수 많은 유틸리티 기능이 있다. `File`클래스는 물론이고, `File`과 관련된 스트림(`FileInputStream`, `FileWriter`)의 사용을 고민하기 전에 `Files`에 있는 기능을 먼저 찾아보자. 성능도 좋고,사용하기도 편리하다.
- 기능이 너무 많기 때문에 주요 기능만 알아보고,나머지는 필요할 때 검색하자.
## 경로 표시
### 절대 경로(Absolute path)
- 절대 경로는 경로의 처음부터 내가 입력한 모든 경로를 다 표현한다.
- 절대 경로는 두가지 경로가 모두 가능하다.
	- `/Users/yeonsigjang/IdeaProjects/01-java-adv2/temp/..`
	- `/Users/yeonsigjang/IdeaProjects/01-java-adv2`
### 정규 경로(Canonical path)
- 경로의 계산이 모두 끝난 경로이다. 정규 경로는 하나만 존재한다.
- 정규 경로는 다음 하나만 가능하다.
	- `/Users/yeonsigjang/IdeaProjects/01-java-adv2`
## Files로 문자 파일 읽기
## 파일 복사 최적화
## 정리


****
# 네트워크 - 기본 이론
## 클라이언트와 서버
### 클라이언트-서버 개념의 기본이해
#### 클라이언트
- 서비스를 요청하는 쪽
#### 서버
- 클라이언트의 요청을 받아들이고, 그 요청에 맞게 서비스를 제공하는 쪽이다.
## 인터넷 통신
## IP(인터넷 프로토콜)
### IP 인터넷 프로토콜 역할
- 지정한 IP 주소(IP Address)에 데이터 전달
- 패킷(Packet)이라는 통신 단위로 데이터 전달
### IP 프로토콜의 한계
#### 비연결성
- 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
#### 비신뢰성
- 중간에 패킷이 사라지면?
- 패킷이 순서대로 안오면?
#### 프로그램 구분
- 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?
## TCP, UDP
### 인터넷 프로토콜 스택의 4계층
#### 애플리케이션 계층
- HTTP, FTP
#### 전송 계층
- TCP, UDP
#### 인터넷 계층
- IP
#### 네트워크 인터페이스 계층
### TCP 특징
- 전송 제어 프로토콜(Transmission Control Protocol)
- 연결지향 - TCP 3 way handshake (**가상 연결**)
- 데이터 전달 보증
- 순서 보장
- 신뢰할 수 있는 프로토콜
- 현재는 대부분 TCP 사용
### UDP 특징
- 사용자 데이터그램 프로토콜(User Datagram Protocol)
- 하얀 도화지에 비유(기능이 거의 없음)
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름
- IP와 거의 같다. + PORT + 체크섬 정도만 추가
- 애플리케이션에서 추가 작업 필요
## PORT
### PORT
- 0 ~ 65535 할당 가능
- 0 ~ 1023
	- 잘 알려진 포트, 사용하지 않는 것이 좋음
	- FTP - 20, 21
	- TELNET - 23
	- HTTP - 80
	- HTTPS - 443
## DNS
### DNS
- 도메인 네임 시스템(Domain Name System)
- 도메인 명을 IP 주소로 변환

****
# 네트워크 - 프로그램1
## 네트워크 프로그램1 - 예제
### localhost, 127.0.0.1
#### `localhost`
- 현재 사용중인 컴퓨터 자체를 가리키는 특별한 호스트 이름이다.
- `google.com`, `naver.com`과 같은 호스트 이름이지만, 자기 자신의 컴퓨터를 뜻하는 이름이다.
- `localhost`는 127.0.0.1이라는 IP로 매핑된다.
#### `127.0.0.1`
- IP 주소 체계에서 루프백 주소(loopback address)로 지정된 특별한 IP 주소이다. 이 주소는 컴퓨터가 스스로를 가리킬 때 사용되며, `localhost`와 동일하게취급된다.
- 컴퓨터가 네트워크 인터페이스를 통해 외부로 나가지 않고, 자신에게 직접 네트워크 패킷을 보낼 수 있도록 한다.
## 네트워크 프로그램1 - 분석
### `InetAddress`클래스를 사용하면 호스트 이름으로 대상 IP를 찾을 수 있다.
1. 자바는 `InetAddress.getByName("호스트명")`메서드를 사용해서 해당하는 IP 주소를 조회합니다.
2. 이 과정에서 시스템의 호스트 파일을 먼저 확인한다.
	1. `/etc/hosts`(리눅스, mac)
	2. `C:\Windows\System32\drivers\etc\hosts`(윈도우,Windows)
3. 호스트 파일에 정의되어 있지 않다면, DNS 서버에 요청해서 IP 주소를 얻는다.
## 네트워크 프로그램2 - 예제
## 네트워크 프로그램2 - 분석
## 네트워크 프로그램3
## 자원 정리1
## 자원 정리2
## 자원 정리3
## 자원 정리4
### Try with resources 장점
#### 리소스 누수 방지
- 모든 리소스가 제대로 닫히도록 보장한다.
- 실수로 `finally`블록을 적지 않거나, `finally`블럭 안에서 자원 해제 코드를 누락하는 문제들을 예방할 수 있다.
#### 코드 간결성 및 가독성 향상
- 명시적인 `close()`호출이 필요 없어 코드가 더 간결하고 읽기 쉬워진다.
#### 스코프 범위 한정
- 예를 들어 리소스로 사용되는 `resource`변수의 스코프가 `try`블럭 안으로 한정된다. 따라서 코드 유지보수가 더 쉬워진다.
#### 조금 더 빠른 자원 해제
- 기존에는 `try` -> `catch` -> `finally`로 `catch`이후에 자원을 반납했다.
- Try with resources구분은 `try`블럭이 끝나면 즉시 `close()`를 호출한다.
#### 자원 정리 순서
- 먼저 선언한 자원을 나중에 정리한다.
#### Try with resources 예외 처리와 부가 예외 포함
- `try-with-resources`를 사용하는 중에 핵심 로직 예외와 자원을 정리하느 중에 발생하는 부가 예외가 모두 발생하면 어떻게 될까?
	- `try-with-resources`는 핵심 예외를 반환한다.
	- 부가 예외는 핵심 예외안에 `Suppressed`로 담아서 반환한다.
	- 개발자는 자원 정리 중에 발생한 부가 예외를 `e.getSuppressed()`를 통해 활용할 . 수있다. `try-with-resources`를 사용하면 핵심 예외를 반환하면서, 동시에 부가 예외도 필요하면 확인할 . 수있다.
##### 참고
- 자바 예외에는 `e.addSupressed(ex)`라는 메서드가 있어서 예외 안에 참고할 예외를 담아둘 수 있다. 참고로 . 이기능도 `try-with-resources`와 함께 등장했다.

****
# 네트워크 - 프로그램2
## 네트워크 프로그램4 - 자원 정리1
## 네트워크 프로그램5 - 자원 정리2
## 네트워크 프로그램6 - 자원 정리3
### 셧다운 훅(Shutdown Hook)
- 자바는 프로세스가 종료될 때, 자원 정리나 로그 기록과 같은 종료 작업을 마무리 할 수 있는 셧다운 훅이라는 기능을 지원한다.
#### 정상 종료
- 모든 non 데몬 스레드의 실행 완료로 자바 프로세스 정상 종료
- 사용자가 `Ctrl + C`를 눌러서 프로그램을 중단
- `kill` 명령 전달 (`kill -9` 제외)
- IntelliJ의 stop 버튼
#### 강제 종료
- 운영체제에서 프로세스를 더 이상 유지할 수 없다고 판단할 때 사용
- 리눅스/유닉스의 `kill -9`나 Windows의 `taskkill /F`
### `try-with-resources`는 사용과 해제를 묶어서 처리할 때 사용한다.
- `try-with-resources`는 `try` 선언부에서 사용한 자원을 `try`가 끝나는 시점에 정리한다. 따라서 `try`에서 자원의 선언과 자원 정리를 묶어서 처리할 때 사용할 수 있다. 하지만 지금은 서버를 종료하는 시점에도 `Session`이 사용하는 자원을 정리해야 한다. 서버를 종료하는 시점에 자원을 정리하는 것은 `Session` 안에 있는 `try-with-resources`를 통해 처리할 수 없다.
## 네트워크 프로그램6 - 자원 정리4
## 네트워크 예외1 - 연결 예외
### TCP RST(Reset) 패킷
- TCP 연결에 문제가 있다는 뜻
- 이 패킷을 받으면 받은 대상은 바로 연결을 해제해야 한다.
## 네트워크 예외2 - 타임아웃
### OS 기본 대기 시간
- TCP 연결을 시도했는데 연결 응답이 없다면 OS에는 연결 대기 타임아웃이 설정되어 있다.
- Window: 약 21초
- Linux: 약 75초에서 180초 사이
- mac test: 75초
### TCP 소켓 타임아웃 - read 타임아웃
**외부 서버와 통신을 하는 경우 반드시 연결 타임아웃과 소켓 타임아웃을 지정하자.**
## 네트워크 예외3 - 정상 종료
## 네트워크 예외4 - 강제 종료
### RST(Reset)
- TCP에서 RST 패킷은 연결 상태를 초기화(리셋)해서 더 이상 현재의 연결을 유지하지 않겠다라는 의미를 전달한다.
	- 여기서 "Reset"은 현재의 세션을 강제로 종료하고, 연결을 무효화하라는 뜻이다.
- RST 패킷은 TCP 연결에 문제가 있는 다양한 상황에 발생한다. 예를 들어서 다음과 같은 경우들이 있다.
	- TCP 스펙에 맞지 않는 순서로 메시지가 전달될 때
	- TCP 버퍼에 있는 데이터를 아직 다 읽지 않았는데, 연결을 종료할 때
	- 방화벽 같은 곳에서 연결을 강제로 종료할 때도 발생한다.
### 정리
- 상대방이 연결을 종료한 경우 데이터를 읽으면 EOF가 발생한다.
	- `-1`, `null`, `EOFException`등이 발생한다.
	- 이 경우 연결을 끊어야 한다.
- `java.net.SocketException: Connection reset`
	- RST 패킷을 받은 이후에 `read()`호출
- `java.net.SocketException: Broken pipe`
	- RST 패킷을 받은 이후에 `write()`호출
- `java.net.SocketException: Socket is closed`
	- 자신이 소켓을 닫은 이후에 `read()`, `write()`호출
## 정리와 문제

****
# 채팅 프로그램
## 채팅 프로그램 - 설계
## 채팅 프로그램 - 클라이언트


🍒🍒🍒🍒
🍅🍅🍅
****
# HTTP - 기본 이론

****
# HTTP 서버 만들기

****
# 리플렉션

****
# 애노테이션

****
# HTTP 서버 활용

****
# 다음으로

****