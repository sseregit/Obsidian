# 1. 강의 소개와 자료
## 강의 소개
==람다, 스트림, 함수형 프로그래밍 등을 실무에서 사용할 수 있는 레벨의 강의가 될것이다. good==
## 수업 자료
## 강의 소스 코드
****
# 2. 람다가 필요한 이유
## 프로젝트 환경 구성
==intellij 세팅법==
## 람다가 필요한 이유1
**프로그래밍에서 중복을 제거하고, 좋은 코드를 유지하는 핵심은 변하는 부분과 변하지 않는 부분을 분리하는 것이다.**
### 값 매개변수화(Value Parameterization)
- 문자값(Value), 숫자값(Value)처럼 구체적인 값을 메서드(함수) 안에 두는 것이 아니라, 매개변수(파라미터)를 통해 외부에서 전달받도록 해서, 메서드의 동작을 달리하고, 재사용성을 높이는 방법.
- 값 매개변수화, 값 파라미터화 등으로 부른다.
## 람다가 필요한 이유2
### 동작 매개변수화(Behavior Parameterization)
- 코드 조각(코드의 동작 방법, 로직, Behavior)을 메서드(함수) 안에 두는 것이 아니라, 매개변수(파라미터)를 통해서 외부에서 전달 받도록  해서, 메서드의 동작을 달리하고, 재사용성을 높이는 방법을 동작 매개변수화라 한다.
- 동작 매개변수화, 동작 파라미터화, 행동 매개변수화(파라미터화), 행위 파라미터화등으로 부른다.
## 람다가 필요한 이유3
==기존의 익명클래스를 람다로 변환==
## 함수 vs 메서드
함수(Function)과 메서드(Method)는 둘 다 어떤 작업(로직)을 수행하는 코드의 묶음
### 객체(클래스)와의 관계
#### 함수(Function)
- 독립적으로 존재하며, 클래스(객체)와 직접적인 연관이 없다.
	- 사실 Java에서는 불가능한 이야기
- 객체지향 언어가 아닌 C 등의 절차적 언어에서는 모든 로직이 함수 단위로 구성된다.
- 객체지향 언어라 하더라도, 예를 들어 Python이나 JavaScript처럼 클래스 밖에서도 정의할 수 있는 “함수”개념을 지원하는 경우, 이를 그냥 함수라고 부른다.
#### 메서드(Method)
- 클래스(또는 객체)에 속해 있는 “함수”이다.
- 객체의 상태(필드, 프로퍼티 등)에 직접 접근하거나, 객체가 제공해야 할 기능을 구현할 수 있다.
- Java, C++, C#, Python등 대부분의 객체지향 언어에서 클래스 내부에 정의된 함수는 보통 “메서드”라고 부른다.
## 람다 시작
==매개변수가 없는 람다와 매개변수가 있는 람다 코드 작성==
****
# 3. 람다
## 람다 정의
### 람다
- 자바 8부터 도입된 람다는 자바서 함수형 프로그래밍을 지원기 위한 핵심 기능
- `람다 == 익명함수`
- 익명 함수를 지칭하는 일반적인 용어 == 개념
- 익명 클래스의 구현을 간단히 표현할 수 있는 **문법 설탕(Syntactic sugar, 코드를 간결하게 만드는 문법적 편의)**
### 람다식
- `(매개변수) -> {본문}`형태로 람다를 구현하는 구체적인 문법 표현
## 함수형 인터페이스 
### 함수형 인터페이스
- 정확히 하나의 추상 메서드를 가지는 인터페이스
- 람다는 추상 메서드가 하나인 함수형 인터페이스에만 할당할 수 있다.
- 단일 추상 메서드를 줄여서 SAM(Single Abstract Method)라 한다.
- 참고로 람다는 클래스, 추상 클래스에는 할당할 수 없다. 오직 단일 추상 메서드를 가지는 인터페이스에만 할당할 수 있다.
## 람다와 시그니처
==람다의 선언 방법 매개변수에 따른 사용방법==
## 람다와 생략
==람다의 문법에서 생략할 수 있는 방법들==
## 람다의 전달
==람다를 변수로, 람다를 매개변수로, 람다를 함수의 반환 타입으로, 전달하는법==
## 고차 함수
### 고차 함수(Higher-Order Function)
- 함수를 값처럼 다루는 함수
- 일반적으로 다음 두 가지 중 하나를 만족하면 고차 함수라 한다.
	- 함수를 인자로 받는 함수(메서드)
	- 함수를 반환하는 함수(메서드)
- **함수를 다루는 추상화 수준이 더 높다**는 데에서 유래
## 문제와 풀이1
==위에 코드들의 복습==
## 문제와 풀이2
==filter, map 문제 풀이==
## 문제와 풀이3
==고차함수 반환, reduce, compose 문제 풀이==
## 정리

****
# 4. 함수형 인터페이스
## 함수형 인터페이스와 제네릭1
==제네릭 사용전 Object까지 활용해서 함수형 인터페이스 사용하기==
## 함수형 인터페이스와 제네릭2
==제네릭을 활용한 함수형 인터페이스 활용==
## 람다와 타겟 타입
### 람다와 타겟 타입
- 람다는 그 자체만으로는 구체적인 타입이 정해져 있지 않고, **타겟 타입(target type)** 이라고 불리는 맥락(대입되는 참조형)에 의해 타입이 결정된다.
## 기본 함수형 인터페이스
==Funtion, Consumer, Supplier, Runnable==
## 특화 함수형 인터페이스
==Predicate, Operator에 대한 코드 가독성, 유지보수성 Function을 쓰지않고 사용하는 이유==
## 기타 함수형 인터페이스
==Primitive를 반환하고 입력하는 함수형 인터페이스와 3개이상의 매개변수를 사용하는 함수형 인터페이스는 없다 사용하려면 만들것. 람다를 사용할 때 왠만하면 제공해주는 함수형 인터페이스를 사용하고 아니라면 꼭 의미에 맞는 이름을 사용해서 만들것!==
## 문제와 풀이
## 정리

****
# 5. 람다 활용
## 필터 만들기1
==if문, Predicate를 활용해서 even, odd 구분하기==
## 필터 만들기2
==IntegerFilter, GenericFilter를 활용하기==
## 맵 만들기1
==변환, Function을 활용하기==
## 맵 만들기2
==StringToIntegerMapper, GenericMapper를 활용하기==
## 필터와 맵 활용1
### 명령형 프로그래밍 (Imperative Programming)
- 정의
	- 프로그램이 **어떻게(How)** 수행되어야 하는지, 즉 수행 절차를 명시하는 방식이다.
- 특징
	- 단계별 실행
		- 프로그램의 각 단계를 명확하게 지정하고 순서대로 실행한다.
	- 상태 변화
		- 프로그램의 상태(변수 값 등)가 각 단계별로 어떻게 변화하는지 명시한다.
	- 낮은 추상화
		- 내부 구현을 직접 제어해야 하므로 추상화 수준이 낮다.
	- 예시
		- 전통적인 `for`루프, `while`루프 등을 명시적으로 사용하는 방식
- 장점
	- 시스템의 상태와 흐름을 세밀하게 제어할 수 있다.
### 선언적 프로그래밍 (Declarative Programming)
- 정의
	- 프로그램이 **무엇(What)** 을 수행해야 하는지, 즉 원하는 결과를 명시하는 방식이다.
- 특징
	- 문제 해결에 집중
		- 어떻게(how)문제를 해결할지보다 무엇을 원하는지에 초점을 맞춘다.
	- 코드 간결성
		- 간결하고 읽기 쉬운 코드를 작성할 수 있다.
	- 높은 추상화
		- 내부 구현을 숨기고 원하는 결과에 집중할 수 있도록 추상화 수준을 높인다.
	- 예시
		- `filter`, `map`등 람다의 고차 함수를 활용한, HTML, SQL등
- 장점
	- 코드가 간결하고, 의도가 명확하며, 유지보수가 쉬운 경우가 많다.
## 필터와 맵 활용2
==한번더 명령형과 선언적 프로그래밍 코드 작성==
## 스트림 만들기1
==filter와 map을 내부적으로 가지고 있는 stream class 작성 및 메서드 체인 사용==
## 스트림 만들기2
### 정적 팩토리 메서드 (static factory method)
- 객체 생성을 담당하는 static 메서드로, 생성자(constructor) 대신 인스턴스를 생성하고 반환하는 역할을 한다.
- 일반적인 생성자(Constructor)대신에 클래스의 인스턴스를 생성하고 초기화하는 로직을 캡슐화 하여 제공하는 정적(static) 메서드이다.
#### 특징
- 정적 메서드
	- 클래스 레벨에서 호출되며, 인스턴스 생성 없이 접근할 수 있다.
- 객체 반환
	- 내부에서 생성한 객체(또는 이미 존재하는 객체)를 반환한다.
- 생성자 대체
	- 생성자와 달리 메서드 이름을 명시할 수 있어, 생성 과정의 목적이나 특징을 명확하게 표현할 수 있다.
- 유연한 구현
	- 객체 생성 과정에서 캐싱, 객체 재활용, 하위 타입 객체 반환 등 다양한 로직을 적용할 수 있다.
## 스트림 만들기3
==제네릭을 이용한 스트림 만들기==
## 스트림 만들기4
### 내부 반복 vs 외부 반복 선택
#### 내부 반복
- 많은 경우 내부 반복을 사용할 수 있다면 내부 반복이 선언형 프로그래밍 스타일로 직관적이기 때문에 더 나은 선택
#### 외부 반복 선택
- 단순히 한두 줄 수행만 필요한 경우
- 반복 제어에 대한 복잡하고 세밀한 조정이 필요할 경우
	- `break`, `continue`등을 사용해야 하는 경우
## 정리

****
# 6. 람다 vs 익명 클래스
## 람다 vs 익명 클래스1
### this 키워드의 의미
#### 익명 클래스
- 내부에서 `this`는 익명 클래스 자신을 가리킨다.
- 외부 클래스와 별도의 컨텍스트를 가진다.
#### 람다 표현식
- `this`는 람다를 선언한 클래스의 인스턴스를 가리킨다.
- 즉, 람다 표현식은 별도의 컨텍스트를 가지는 것이 아니라, 람다를 선언한 클래스의 컨텍스트를 유지한다.
## 람다 vs 익명 클래스2
### 익명 클래스와 람다의 용도 구분
#### 익명 클래스
- **상태를 유지**하거나 다중 메서드를 구현할 필요가 있는 경우
- 기존 클래스 또는 인터페이스를 상속하거나 구현할 때
- 복잡한 인터페이스 구현이 필요할 때
#### 람다
- **상태를 유지할 필요가 없고**, 간결함이 중요한 경우
- 단일 메서드만 필요한 간단한 함수형 인터페이스 구현 시
- 더 나은 성능(이 부분은 미미하다)과 간결한 코드가 필요한 경우
## 정리

****
# 7. 메서드 참조
## 메서드 참조가 필요한 이유
### 메서드 참조의 장점
- 코드가 더욱 간결해지고, 가독성이 향상된다.
- 더 이상 매개변수를 명시적으로 작성할 필요가 없다.
	- 컴파일러가 자동으로 매개변수를 매칭한다.
- 별도의 로직 분리와 함께 재사용성 역시 높아진다.
### 메서드 참조란?
- **”이미 정의된 메서드를 그대로 참조하여 람다 표현식을 더 간결하게 작성하는 방법”**
- 이미 정의된 메서드를 람다로 변환하여 더욱 간결하게 사용할 수 있도록 해주는 문법적 편의 기능
- 람다를 작성할 때, 이미 정의된 메서드를 **그대로 호출하는** 경우
## 메서드 참조1 - 시작
### 메서드 참조의 4가지 유형
1. 정적 메서드 참조
2. 특정 객체의 인스턴스 메서드 참조
3. 생성자 참조
4. 임의 객체의 인스턴스 메서드 참조
### 메서드 참조에서 `()`를 사용하지 않는 이유
- `()`는 메서드를 즉시 호출한다는 의미를 가진다. 여기서 `()`가 없는 것은 메서드 참조를 하는 시점에는 메서드를 호출하는게 아니라 단순히 메서드의 이름으로 해당 메서드를 참조만 한다는 뜻이다.
	- 해당 메서드의 실제 호출 시점은 함수형 인터페이스를 통해서 이후에 이루어진다.
## 메서드 참조2 - 매개변수1
### 메서드 참조에서 매개변수를 생략하는 이유
- 함수형 인터페이스의 시그니처(매개변수와 반환 타입)가 정해져 있고, 컴파일러가 그 시그니처를 바탕으로 메서드 참조와 연결해주기 때문에 명시적으로 매개변수를 작성하지 않아도 자동으로 추론되어 호출된다.
## 메서드 참조3 - 임의 객체의 인스턴스 메서드 참조
### 임의 객체의 인스턴스 메서드 참조
`Class::instanceMethod`
- `Class`는 Type (매개변수) `(Class clazz)`
- `instanceMethod`는 해당 Type이 가지는 메서드
## 메서드 참조4 - 활용1
==메서드를 활용해서 메서드 참조를 활용하는 예시==
## 메서드 참조5 - 활용2
### 메서드 참조의 장점
- 메서드 참조를 사용하면 람다 표현식을 더욱 직관적으로 표현할 수 있다.
- 각 처리 단계에서 호출되는 메서드가 무엇인지 쉽게 파악할 수 있다.
## 메서드 참조6 - 매개변수2
==매개변수의  수는 상관없다. 이미 메서드 정보로 매개변수의 정보를 알고 있다.==
## 정리


****
# 8. 스트림 API1 - 기본
## 스트림 API 시작
==스트림 맛보기==
## 스트림 API란?
### 스트림 API란?
#### 스트림(Stream)
- 자바 8부터 추가된 기능으로, 데이터의 흐름을 추상화해서 다루는 도구이다.
#### 컬렉션(Collection) 또는 배열등
- 연산 파이프라인을 통해 연속적인 형태로 처리할 수 있게 해준다.
##### 연산 파이프라인
- 여러 연산(중간 연산, 최종 연산)을 **체이닝**해서 데이터를 변환, 필터링 계산하는 구조
### 스트림의 특징
1. 데이터 소스를 변경하지 않는다(Immutable)
	- 스트림에서 제공하는 연산들은 원본 컬렉션을 변경하지 않고 결과만 새로 생성
2. 일회성(1회 소비)
	- 한번 사용(소비)된 스트림은 다시 사용할 수 없고 필요하다면 다시 생성해야한다.
3. 파이프라인(Pipeline) 구성
	- 중간 연산들이 이어지다가, 최종 연산을 만나면 연산이 수행되고 종료된다.
4. 지연 연산(Lazy Operation)
	- 중간 연간은 필요할 때까지 실제로 동작하지 않고, 최종 연산이 실행될 때 한번에 처리된다.
5. 병렬 처리(Parallel) 용이
	- 스트림으로 부터 병렬 스트림(Parallel Stream)을 쉽게 만들어서, 멀티코어 환경에서 병렬 연산을 비교적 단순한 코드로 작성할 수 있다.
## 파이프라인 구성
### 일괄 처리(Batch Processing)
- 공정(중간 연산)을 단계별로 쪼개서 데이터 전체를 한 번에 처리하고, 결과를 저장해두었다가 다음 공정을 또 한번에 수행한다.
### 파이프라인 처리(Pipeline Processing)
- 한 요소가 한 공정을 마치면, 즉시 다음 공정으로 넘어가는 구조
## 지연 연산
### 스트림 API의 지연 연산
- 파이프라인 설정을 해놓기만 하고, 실제 연산은 최종 연산이 호출되기 전까지 전혀 진행되지 않는다.
## 지연 연산과 최적화
### 지연 연산의 장점
1. 불필요한 연산의 생략(단축, Short-Circuiting)
2. 메모리 사용 효율
3. 파이프라인 최적화

****
# 9. 스트림 API2 - 기능
## 스트림 생성


****
# 10. 스트림 API3 - 컬렉터

****
# 11. Optional

****
# 12. 디폴트 메서드

****
# 13. 병렬 스트림

****
# 14. 함수형 프로그래밍

****
# 15. 다음으로

****