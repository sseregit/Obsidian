# 들어가며

## 강의 소개

오브젝트 초반부를 다루며
**책임 주도 설계 방식을 기반으로 객체 협력을 설계하는 방법 학습**
****
# 영화 예매 도메인

## 영화 예매 도메인

### 도메인 Domain
- 사용자가 프로그램을 사용하는 주제 영역
- 사용자가 프로그램을 사용해서 해결하고 싶은 문제들의 집합
- 소프트웨어로 구현할 요구사항의 범위

### 다중성 Multiplicity
- 도메인 개념의 사이에 연결 가능한 숫자의 범위 
****
# 절차적인 설계 개선하기

## 절차적인 설계

### 절차적 Procedural
- 프로그램을 구성하는 데이터와 프로세스를 개별적인 모듈로 분리해서 구현하는 방식
- 데이터를 먼저 구현하고 데이터를 사용하는 프로세스를 나중에 구현한다.

### 절차적인 프로세스(알고리즘) 설계
- 절차적인 설계는 로직을 실행 순서대로 클래스 안에 배치

### 절차적인 설계의 핵심
- 데이터가 사용될 **문액을 고려하지 않은 채** 독립적으로 데이터 설계
- 데이터가 완성되면 **외부의 프로세스**에 데이터를 처리하기 위한 로직 구현

## 예제 절차적인 설계

불변객체를 사용하면 누수 효과가 발생하지 않는다.

## 변경과 의존성

### 절차적인 설계의 단점

#### 가장 큰 단점
- 데이터를 구현한 코드를 수정할 때

### 의존성 Dependency
- 다른 코드가 수정될 때 함께 수정될 수 있는 **가능성**

### 데이터와 프로세스의 분리
- 절차적인 방식에서는 프로세스와 데이터를 별도의 모듈로 구현

### 추측에 의한 설계 전략 Design-By-Guessing Strategy
- 객체가 사용될 문맥을 고려하지 않고 데이터 설계
- 언제, 어떻게 사용될 지 모르기 때문에 **어떤 문맥에서도 사용될 수 있도록** getter/setter를 추가하는 경우

### 객체지향의 출발점
- 데이터와 프로세스의 통합

## 데이터와 프로세스 통합하기

### 수정하기 쉬운 설계를 만드는 방법
- 데이터 변경으로 인한 파급효과를 막는 것이 핵심

### 리팩토링 규칙
- 데이터의 **getter를 사용해서 판단하고 결정**하는 로직을 그 데이터로 옮겨라

### 책임의 이동 Shift or Responsibility
- 데이터를 이용해서 **의사 결정** 하거나 데이터의 **상태를 변경**하는 로직

### 데이터와 객체의 차이점
- 수동적인 데이터
- 능동적인 객체
#### 바보 데이터 객체 Dumb Data Object
- 데이터를 외부에 제공하고 외부에서 판단하고 결정하는 수동적인 존재

#### 똑똑한 객체 Smart Object
- 자기 자신의 **상태를 직접 관리**하고 **스스로 판단하고 결정**하는 **자율적인**존재

#### 객체
- 자기 자신의 상태를 직접 관리하고 스스로 판단하고 결정하는 **자율적**인 존재 특별한 설명 없이 객체라고 할 때는 **똑똑한 객체**를 의미

##### 자율적 autonomous
- 자기 스스로의 원칙에 따라 어떤 일을 하거나 자기 스스로를 통제하여 절제하는 것

## 절차에서 객체로

### 책임 주도 설계 Responsibility-Driven Design
- 객체를 설계할 때 객체가 사용될 문맥을 함께 고려하여 설계하는 방식

****
# 객체지향 기본 원칙

## 객체지향 설계 원칙

### 설계 Design란?
- 코드를 배치하는 방식

#### 설계가 필요한 이유 == 객체지향 설계가 필요한 이유
- 요구사항이 변경 될 때 코드를 쉽고 안전하게 수정하기 위해

### 객체지향 설계 원칙

#### 협력에 필요한 **행동**을 **먼저** 결정하고 행동에 적합한 **객체**를 **나중에** 선택하라.

#### 객체의 **행동**을 **먼저** 구현하고 행동에 필요한 **데이터**를 **나중에** 선택하라

#### 협력 Collaboration
- 객체가 다른 객체에 도움을 얻기 위해 요청하고 응답하는 과정

#### 진정한 객체지향 설계는 제한된 **문맥** 안에서 설계

#### 순서
- 객체 협력(런타임)에서 클래스 구조(컴파일 타임)의 순서로 진행

### 책임 주도 설계 Responsibility-Driven Design
- 협력에 초점을 맞춘 설계 방법

## 책임 주도 설계

### 객체지향 설계 흐름
1. **협력**을 위한 문맥 결정
2. 필요한 **책임**을 식별
3. 책임을 수행할 **객체**를 선택
4. **책임** 구현
5. **데이터** 결정

### 책임 Responsibility
- 협력에 참여하기 위해 객체가 수행하는 행동
- 책임은 **행동** 관점

#### 하는것 Doing
- 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
- 다른 객체(협력자)의 행동을 시작시키는 것
- 다른 객체(협력자)의 활동을 제어하고 조절하는 것

#### 아는 것 Knowing
- private로 캡슐화된 상태(데이터)에 관해 아는 것
- 관련된 객체(협력자)에 관하여 아는 것
- 자신이 유도하거나 계산할 수 있는 것(상태와 협력자)에 관하여 아는 것

### 애플리케이션 기능
- 객체와 협력을 설계하기 위한 **문맥** 제공

### 책임 주도 설계 살펴보기
- 애플리케이션이 제공할 기능 파악
- 애플리케이션의 기능 요구사항을 시스템의 책임으로 변환
- 시스템의 책임을 객체의 책임으로 변환
- 책임을 담당할 적절한 객체 선택
- 객체의 책임 일부를 수행하기 위해 외부의 도움이 필요하다면 다른 객체에게 도움을 요청

### 책임 주도 설계의 문맥
1. 애플리케이션의 기능이 협력을 위한 문맥 제공
2. 협력이 책임을 위한 문맥 제공

## 표현적 차이 줄이기

### 도메인 모델 Domain Model
- 도메인에 중요한 개념과 관계의 집합
- 객체지향 설계의 재료로 사용되는 도메인의 추상화

#### 도메인 모델의 용도
- 후보 객체를 찾을 때 **가장 먼저 참고**하는 개념과 관계의 집합

#### 도메인 모델을 참고하는 이유
- 표현적 차이를 줄이기 위해

### 표현적 차이 Representational Gap
- 도메인에 대한 개념적 모델과 소프트웨어 구현 사이의 거리

#### 표현적 차이를 줄이는 이유
- 변경하기 쉬운 유연한 설계를 만들기 위해
- 코드의 위치를 파악하기 용이

#### 명사의 가치
- 객체 지향은 명사를 이용해 동사를 묶을 수 있는 개념적 틀 제공

### GRASP
- General Responsibility Assignment Software Pattern
- 일반적인 책임 할당을 위한 소프트웨어 패턴

### CRC카드
- 책임과 협력을 표현하기 위한 객체지향 설계도구
- Candidate + Responsibility + Collaborator
	- 위 + 왼쪽 + 오른쪽
- 런타임에 실제로 행동을 수행하는 동적인 객체 
****
# 책임 할당하기

## 정보와 책임 할당 - 정보 전문가

### 책임 할당

#### 책임 할당의 가장 기본이 되는 패턴
- GRASP - INFOMATION EXPERT(정보 전문가)
	- 문제
		- 책임을 객체에게 할당하는 일반적인 원칙은 무엇인가?
	- 해결방법
		- 책임을 수행하는데 필요한 정보를 가장 많이 알고 있는 객체에게 할당하라

##### 정보 전문가의 정보란
- 데이터가 아니라 **행동**
- 어떤 상태를 수정하거나 질문에 답하는 **책임**
- 즉 정보를 가지고 있는 객체가아니라 질문에 **답**을 해줄 수 있는 객체를 의미한다.

#### 첫번째 질문
- 상영 예매를 시작할 책임을 어떤 객체에게 할당할 것인가?
	- 애플리케이션 기능을 상태 변경과 실행 결과의 관점에서 정리하고 나면 **상태 변경을 기반으로 객체 협력**을 설계할 수 있다.

### 애매 하다면
- 목적어에 책임을 할당하라

## 설계 트레이드오프 - 창조자와 낮은 결합도

### GRASP - CREATOR 창조자
- 문제
	- 새로운 인스턴스를 생성하는 책임을 어떤 객체에게 할당할 것인가?
- 해결방법
	- 다음 중 한 가지라도 만족할 경우 A의 인스턴스를 생성할 책임을 B에게 할당하라.
		- B가 A를 포함하거나 참조한다.
		- B가 A를 기록한다.
		- B가 A를 긴밀하게 사용한다.
			- 위 3가지는 **낮은 결합도**
		- B가 A를 초기화하는 데 필요한 정보를 알고 있다.
			- **정보 전문가**

### 결합도
- 객체들이 서로 연관되어 있는 정도

### GRASP - LOW COUPLING 낮은 결합도
- 문제
	- 어떻게 낮은 의존성을 유지하고, 변경에 따른 영향을 줄이면서, 재사용성을 높일 수 있을까?
- 해결방법
	- 설계의 전체적인 결합도를 낮게 유지할 수 있도록 책임을 할당하라
- 중요한 이유
	- 수정하기 쉬운 설계를 만들기 위해

## 설계 트레이드오프 - 높은 응집도

### GRASP - HIGH COHESION 높은 응집도
- 의미
	- 한 요소의 책임들이 얼마나 강력하게 관련되고 집중되어 있는가 연관성 높은 책임들을 가지면서 너무 많은 일을 하지 않는 객체에 책임 할당
- 문제
	- 어떻게 낮은 결합도를 유지하고, 변경에 따른 영향을 줄이면서, 재사용성을 높일 수 있을까?
- 해결방법
	- 높은 응집도를 유지하도록 책임을 할당하라
- 중요한 이유
	- 수정하기 쉬운 설계를 만들기 위해

**높은 응집도와 낮은 결합도는 설계의 평가 기준**

### 설계의 본질
- 트레이드 오프 Trade-off

## 유연한 설계 - 다형성

### 파급 효과 Ripple Effect
- 변경에 취약한 설계

### GRASP - POLYMORPHISM 다형성
- 문제
	- 타입을 기반으로 유사하지만 서로 다르게 행동할 때 조건문을 사용하지 않고 변하는 행동을 어떻게 처리할 것인가?
- 해결방법
	- 다형적인 메시지를 이용해서 행동이 변하는 타입들에게 각 행동을 다루기 위한 책임을 할당하라

## 결합도 낮추기 - 변경 보호

### 메시지 Message
- 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단
- 객체는 다른 객체에게 협력을 요청하기 위해 메시지를 전송

### 다형적인 메시지
- 동일한 요청, 타입에 따라 다른 행동, 동일한 결과

### GRASP - PROTECTED VARIATIONS 변경보호
- 문제
	- 요소들의 변화나 불안정한 요소가 다른 요소에 해로운 영향을 미치지 않도록 할 수 있을까?
- 해결방법
	- 변화가 예상되거나 불안정한 지점을 식별하고, 그 주위에 안정적인 인터페이스 또는 추상화를 형성하도록 책임을 할당하라

### 다형성 Polymorphism
- **메시지가 동일**하더라도 수신한 **객체의 타입에 따라** 실제로 수행하는 **행동이 달라지는** 능력

### 역할 Role
- 다른 것으로 **대체**할 수 있는 **책임의 집합**
- 객체와 역할
	- 한 종류의 객체만 요청에 응답하면 객체 역할은 동일

### 책임 주도 설계 구성 요소

#### 역할 Role, 책임 Responsibility, 협력 Collaboration
****
# 객체지향 구현

## 객체 구현하기

### 위임식delegated/ 분산식dispersed 제어 스타일

## 메시지와 메서드의 분리

### 메시지message
- 객체 사이의 의사소통 수단

### 메서드method
- 메시지를 처리하는 방법

### 메시지와 메서드를 분리하는 이유
- 수정하기 쉬운 코드를 작성하기 위해

### 동적 바인딩Dynamic Binding
- 런타임에 메시지를 처리할 적절한 클래스와 메서드 탐색

## 유연하고 일관적인 협력

### 컴파일타임 의존성과 런타임 의존성

### 의존성 주입Dependency Injection
- 두 의존성 사이의 차이를 해결하기 위한 외부의 객체가 의존하는 객체를 전달하는 방법

### 메시지와 메서드 분리의 장점
- 변경의 파급효과를 제어할 수 있기 때문에 기존 코드를 수정하지 않고도 기능 확장 가능
- 일관성 있는 설계

## 애플리케이션 객체 추가하기

### GRASP - INDIRECTION 간접화
- 문제
	- 직접적인 의존을 피하기 위해 어디에 책임을 할당해야 하는가?
- 해결방법
	- 다른 컴포넌트나 서비스가 직접 의존하지 않도록 중재하는 중간 객체에 책임을 할당하라

### GRASP - PURE FABRICATION 순수한 가공물
- 문제
	- 적당한 책임을 가진 클래스를 찾지 못하는 상황이거나 높은 응집도와 낮은 결합도를 위반하고 싶지 않은 경우에 누구에게 책임을 할당해야 하는가?
- 해결방법
	- 도메인 개념을 표현하지 않는 인위적으로 만든 클래스에 책임을 할당하라. 이런 클래스는 높은 응집도, 낮은 결합도, 재사용을 지원하기 위해 만들어 진다.

### GRASP - CONTROLLER 컨트롤러
- 문제
	- UI 계층을 통해 전달되는 시스템의 오퍼레이션을 전달받고 조정(제어할) 최초의 객체는 무엇인가?
- 해결방법
	- 워크플로우를 표현하는 객체에게 책임을 할당하라

## 예제 애플리케이션 객체 추가하기
****
# 변경과 설계
****