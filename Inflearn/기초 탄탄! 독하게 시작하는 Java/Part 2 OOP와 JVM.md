# 시작에 앞서...
## 알고 있다고 가정하는 것과 학습목표
## C/C++ 개발자에게 드리는 말씀
### C/C++ 개발자에게 드리는 말씀
- Java는 void형 변수 선언은 불가하며 반환 형식으로만 사용
- null값은 참조형에만 적용 가능
	- int a = null (불가)
	- null은 값(인스턴스)가 없다는 의미
	- 클래스 형식을 반환하는 메서드는 null 반환 가능
- 연산자 함수 없음
- Java에서 클래스 형식은 모두 참조자이며 포인터라고 생각하는 것이 용이
### Pointer스러운 참조형
- 참조형에 대한 관계연산(`==, !=`)은 객체의 메모리 주소에 대한 비교(Pointer와 동일)
- 포인터처럼 참조자 값은 변경될 수 있음
	- C++처럼 선언과 동시에 초기화 하지 않아도 무방
- null 대입 가능하며 참조 대상이 없는 참조자를 이용해 멤버접근 연산을 수행하면 NullPointerException 에러 발생
****
# 클래스 - 첫 번째
## 객체, 클래스, 인스턴스
### 객체(Object)란 무엇인가?
- OOP환경에서 소프트웨어(소스코드)를 구성한느 단위요소
- 변수 및 그와 관련한 메서드(Method)가 모여서 이뤄진 하나의 집합체
	- **클래스는 반드시 존재 이유와 목적이 명확해야함**
- Java에서는 클래스(Class)로 객체를 기술
### 항, 식, 구문
- 여러 항이 모여 식을 이룸
- 식은 평가 대상(식을 평가하기 위해서는 계산(연산)을 해야함)
- 여러 식을 모아 하나의 구문을 이루며 고급어 기준 실행단위가 됨
- 연속되는 구문을 위에서 아래로 순차적 실행
### 클래스, 객체, 인스턴스
- 클래스는 변수와 같은 자료형으로 이해
	- 클래스(집합체)는 객체(단위)를 기술하는 문법
	- 클래스 형식에 대해 선언 할 수 있는 것은 참조(null 가능)
- 사전적 의미는 '예시' 혹은 '경우'
- 변수 대신 인스턴스라고 표현
	- int형식에 대한 인스턴스 a
- 다양하게 사용되는 용어
	- 프로세스 인스턴스
## 클래스 기본 문법과 두 가지 관점
### 클래스 기본 문법
	`class class-name {}`
- 관계에 관해 생각하지 않는다면 함수(메서드)를 구성요소로 포함하는 단순 집합체로 이해
- 구성요소(변수나 함수)를 멤버라 지칭
	- 변수는 필드(Field), 함수는 메서드(Method)
	- 변수는 메모리를 사용하는 보편적인 수단
- 선언과 정의가 공존하는 구조
- **객체 작성자와 사용자를 구분해 생각하는 능력 필수**
#### Convention
	`className.java`
- 클래스 이름은 영문으로 작성하되 첫 글자는 대문자로 표기하는 것이 보편적 규칙
- 클래스 이름과 저장되는 .java 파일명이 같아야 함
	- 대소문자 구분
	- public 선언 시 필수
	- 단, 특정 .java 파일에 여러 클래스를 함께 정의할 경우 별도 파일로 저장하지 않음
## 생성자와 필드 초기화
### 멤버 선언 및 초기화
- 필드 선언 시 초깃값 정의 가능
	- 초깃값을 기술하지 않을 경우 기본 값은 0
- 생성자를 통해 초기화 가능
	- 필드 선언 시 기술한 초깃값과 생성자에서 정의하는 값이 서로 다를 경우 생성자에 기술한 코드가 우선
- `동적 == Dynamic == Runtime`
### 생성자
- 생성자는 객체가 생성되는 시점에 자동으로 호출 되는 메서드
	- 이름이 클래스 이름과 동일
	- 생략 시 컴파일러가 빈 생성자를 자동으로 추가
	- 반환자료와 호출자가 없다는 점에 유의
- 객체의 생성은 new 연산에 따른 동적 생성
- 다중 정의 가능
- **클래스 자체와 관련된 코드만 기술할 것**
### 인스턴스 동적 생성
- new 연산자를 이용해 인스턴스 동적 생성
- 클래스 형식에 대한 변수 선언은 모두 참조
	- 인스턴스가 존재하지 않는 경우는 null
- 한 인스턴스에 대해 여러 참조자가 존재할 수 있음
	- 사이드 이펙트 문제 고려
## 클래스 멤버에 대한 접근 제어
### 접근 제어 지시자
#### public
- 외부접근 허용
#### protected
- 외부접근 차단
- 같은 패키지 및 파생 클래스의 접근은 허용
#### default
- 같은 패키지 소속 클래스만 접근 허용
#### private
- 외부접근 차단
### getter()와 setter()
- 감춰진 필드에 대해 외부에서 접근 할 수 있도록 허용된 메서드
- 필드에 대한 읽기, 쓰기 접근을 분리해 통제 가능
- 도구에서 자동 생성 지원
- 객체지향 프로그래밍에서는 객체를 제작하는 관점과 생성하고 사용하는 관점 두 가지를 분리해 생각해야 함
## this
### this
- 클래스로 구현한 객체 자신의 인스턴스에 대한 참조자
- 클래스(현재 코드)에 대한 인스턴스(미래, 외부) 선언 시 값이 결정될 수 있음 (주소)
- 같은 클래스에 대한 인스턴스라 하더라도 this 값은 각자 다른값이 됨
- 메서드 호출 시 스택(0번 슬롯)에 값이 저장
- 정적 메서드에서는 사용 할 수 없음
## [실습] 문자열 처리를 위한 MyString 클래스 개발
## MyString 클래스 작성 실습 해설
****
# 클래스 - 두 번째
## 생성자 다중 정의
### 생성자 다중 정의
- 일반 메서드처럼 생성자도 매개변수 구성이 다른 생성자를 여럿 정의할 수 있음
	- 여러 개가 다중 정의되어 있다하더라도 new 연산 시 호출되는 생성자는 1개
- 생성자에서 다른 생성자 호출 가능
## [실습] MyString 클래스 생성자 다중 정의
## 깊은 복사와 얕은 복사 (※매우 중요)
### Shallow copy
- 참조의 대상은 복사해서 늘리지 않고 참조자만 늘리는 형태
	- 사이드 이펙트 발생의 원인
- 대상 인스턴스는 그대로 두고 참조만 늘어나는 경우
### Deep copy
- 원본 자체도 새로 할당하고 복사하는 방식
- Shallow copy와 달리 두 개의 원본 두 개의 참조가 각각 별도로 존재
- 사이드 이펙트 오류 가능성이 없음
- 참조를 멤버로 가지며 인스턴스를 동적 할당하는 경우 복사 생성자 구현
	- clone()
## 복사 생성자 (※매우 중요)
### 복사 생성자
	`class-name(class-name rhs)`
- 객체의 사본을 생성할 때 사용하기 적절한 생성자 함수
	- C++ 스타일 문법
- rhs는 Right Hand Side의 약어이며 복사의 원본 인스턴스에 대한 참조
- clone() 메서드를 만드는 방법이 있으나 규약에 모호한 부분이 있고 예외처리가 복잡한 단점이 있음
## [실습] MyString에 복사 생성자 추가
## 보이지 않는 임시 객체
### 보이지 않는 임시 객체
- 클래스가 함수의 반환 자료형이 될 경우 (이름이 없는) 임시 객체를 생성
- String 클래스는 덧셈 연산 시 임시 객체 생성
	- 비효율의 직접적 원인이 될 수 있음
## 정적 멤버와 특이한 코드
### 정적 멤버
- 클래스 인스턴스가 없어도 **독립적으로 존재**가능
	- 필드(**모든 인스턴스에서 공유**), 메서드
- 일반 메서드와 달리 인스턴스 선언 없이 호출 가능
- 메서드에서 this를 사용할 수 없음
- 정적 필드는 final 선언 함으로써 심볼릭 상수로 활용하는 경우가 많음
### 정적 필드와 인스턴스 메모리 차이
- 정적 필드는 인스턴스 메모리와 독립적이며 메소드 코드는 인스턴스 마다 다르지 않고 하나만 존재
## [실습] 정적 메서드로 MyString 클래스 객체 생성하기
****
# 상속과 관계
## 상속에 대한 기본 이론
### 상속에 대한 기본 이론
	`class child extends parent`
- 객체단위 코드를 재사용(확장)하는 문법
- is-a, has-a 관계로 설명 가능
- 부모/자식 클래스, 기본/파생 클래스로 구분 할 수 있음
- C++과 달리 다중 상속은 허용하지 않음
- Java에서 모든 클래스는 Object의 파생형식
- **파생 클래스 생성 시 기본 클래스도 함께 생성**(생성자 호출)
- 파생 클래스는 기본 클래스 멤버에 접근 가능
	- 접근제어 지시자에 따라 제어
- 파생 클래스에서 **기본 클래스 메서드 재정의(Override) 가능**(다중 정의와 다름에 주의)
- 추상 자료형 개념 적용 가능
- 상속 관계가 적용될 경우 코드의 흐름이 2차원적 구조를 갖게 되어 감춰지는 경향이 있음
## 상속과 생성자 (신박한 바보짓)
### 상속과 생성자 호출스택
- **파생 클래스 생성자는 가장 먼저 호출되지만 가장 나중에 실행된다.**
- 재귀호출과 비슷하게 생성자 함수에 대한 호출 스택이 쌓여 올라가는 것이 특징
- 파생 클래스에서 기본 클래스 필드를 정의하는 것은 적절하지 않은 경우가 대부분
### 상속관계에서 인스턴스 메모리 구조
- 파생 클래스 인스턴스는 부모 클래스(들) 인스턴스를 내부에 포함하고 있는 구조
- 파생 클래스는 부모 클래스의 멤버를 가진것
	- private이면 파생 클래스 접근도 차단
	- protected면 파생 클래스 접근 허용
### 상속을 배우는 순간부터 알아야 할 시간차
- 부모 클래스와 파생 클래스가 정의되는 시점
	- 부모 클래스 기준 '현재'는 파생 클래스가 '미래'에 정의되는 것임을 확정
	- 6개월 후 미래의 당신은 오늘 이 클래스에 대해 얼마나 기억할 수 있을 것인지 고려
- 이해도 부족에 따른 문제
	- 증조 할아버지에 대해 얼마나 알고 있는가?
	- 상속에 상속이 이어지는 것은 결코 바람직하지 않음
- 미래의 파생 클래스를 고려해 현재 클래스 코드 작성
## 부모 클래스 생성자 선택
### 부모 클래스 생성자 선택
- 파생 클래스 생성자에서 부모 클래스의 (다중정의 된) 여러 생성자 중 원하는 것이 호출되도록 강제화
- `super();`
## 메서드 재정의(Overriding, ※매우 중요)
### 메서드 재정의(Overriding)
- 파생 클래스에서 기본 클래스 메서드 재정의(Override) 가능 (다중 정의와 다름에 주의)
	- @Override 어노테이션
- 기본 클래스 메서드를 재정의 하는 것은 기존 메서드를 대체하거나 코드를 추가할 목적으로 볼 수 있음
- 메서드 재정의 시 실제 인스턴스 형식이 우선
- final 선언으로 파생 클래스에서 메서드가 재정의되지 못하도록 차단할 수 있음
### 어노테이션(Annotaion) 소개
- 코드에 추가 할 수 있는 메타 데이터로 단순히 주석처럼 쓰이거나 코드를 간소화 할 수 있는 도구로 사용
- 대표적 표준 어노테이션
	- @Override (재정의)
	- @SuppressWarning (컴파일러 경고 메시지 무시)
	- 메타 어노테이션 (어노테이션에 대한 어노테이션)
	- 사용자 정의 어노테이션
## 불필요한 호출로 미래와 대화하기 (※매우 중요)
### 불필요한 호출로 미래와 대화하기
- 부모 클래스에서 정한 함수 호출 관계로 파생 클래스에서 재정의된 메서드가 호출 될 수 있음
- 구조가 정한 흐름을 확장해 (그 구조에) 내 코드를 추가하는 방식으로 올라 탈 수 있음
	- Called by framework
	- onXxx() 메서드
## [실습] 상속과 문자열 필터 구현
## 객체간 관계와 UML
****
# 다형성

****
# JVM(Java Virtual Machine) 기본 이론

****
# JVM과 GC 그리고 객체

****
# 불변 객체와 String 클래스

****
# 내부 클래스, 익명 객체, 패키지

****
# 연결 리스트 기반 주소록과 OOP 실습

****
# 예외 처리

****