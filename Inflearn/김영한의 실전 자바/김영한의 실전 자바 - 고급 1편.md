# 강의 소개와 자료

****
# 프로세스와 스레드 소개
## 멀티태스킹과 멀티프로세싱
### 시분할(Time Sharing, 시간 공유) 기법
- 각 프로그램의 실행 시간을 분할해서 마치 동시에 실행되는 것 처럼하는 기법
### 멀티태스킹(Multitasking)
- 하나의 컴퓨터 시스템이 동시에 여러 작업을 수행하는 능력
### 스케줄링(Scheduling)
- CPU에 어떤 프로그램이 얼마만큼 실행될지는 운영체제가 결정한다.
### 멀티프로세싱(Multiprocessing)
- 컴퓨터 시스템에서 둘 이상의 프로세서(CPU 코어)를 사용하여 여러 작업을 동시에 처리하는 기술
### 멀티프로세싱 vs 멀티태스킹
- 멀티프로세싱은 하드웨어 장비의 관점
- 멀티태스킹은 운영체제 소프트웨어의 관점
#### 멀티프로세싱
- 여러 CPU(여러 CPU 코어)를 사용하여 동시에 여러 작업을 수행하는 것을 의미한다.
- 하드웨어 기반으로 성능을 향상시킨다.
#### 멀티태스킹
- 단일 CPU(단일 CPU 코어)가 여러 작업을 동시에 수행하는 것처럼 보이게 하는 것을 의미한다.
- 소프트웨어 기반으로 CPU 시간을 분할하여 각 작업에 할당한다.
## 프로세스와 스레드
### 프로세스
- 프로그램은 실제 실행하기 전까지는 단순한 파일에 불과하다.
- 프로그램을 실행하면 프로세스가 만들어지고 프로그램이 실행된다.
- 이렇게 운영체제 안에서 **실행중인 프로그램을 프로세스**라 한다.
- 프로세스는 실행 중인 프로그램의 **인스턴스**이다.
#### 프로세스의 메모리 구성
##### 코드 섹션
- 실행할 프로그램의 코드가 저장되는 부분
##### 데이터 섹션
- 전역 변수 및 정적 변수가 저장되는 부분
##### 힙 (Heap)
- 동적으로 할당되는 메모리 영역
##### 스택 (Stack)
- 메서드(함수) 호출 시 생성되는 지역 변수와 반환 주소가 저장되는 영역(스레드에 포함)
### 스레드 (Thread)
- **프로세스는 하나 이상의 스레드를 반드시 포함한다.**
#### 스레드의 메모리 구성
##### 공유 메모리
- 같은 프로세스의 코드 섹션, 데이터 섹션, 힙(메모리)은 프로세스 안의 모든 스레드가 공유한다.
##### 개별 스택
- 각 스레드는 자신의 스택을 갖고 있다.
### 멀티스레드
- 한 프로세스 내에 여러 스레드가 존재
#### 필요한 이유
- 하나의 프로그램도 그 안에서 동시에 여러 작업이 필요하다.
## 스레드와 스케줄링
## 컨텍스트 스위칭
### 스레드가 하는 작업 2가지
#### CPU-바운드 작업(CPU-bound tasks)
- CPU의 연산 능력을 많이 요구하는 작업을 의미한다.
- 이러한 작업은 주로 계산, 데이터처리, 알고리즘 실행 등 CPU의 처리 속도가 작업 완료 시간을 결정하는 경우다.
##### 설정
- CPU 코어 수 + 1개
- CPU를 거의 100% 사용하는 작업이므로 스레드를 CPU 숫자에 최적화
#### I/O-바운드 작업(I/O-bound tasks)
- 디스크, 네트워크, 파일 시스템 등과 같은 입출력(I/O) 작업을 많이 요구하는 작업을 의미한다.
- 이러한 작업은 I/O 작업이 완료될 때까지 대기 시간이 많이 발생하며, CPU는 상대적으로 유휴(대기) 상태에 있는 경우가 많다, 쉽게 이야기해서 스레드가 CPU를 사용하지 않고 I/O 작업이 완료될 때 까지 대기한다.
##### 설정
- CPU 코어 수 보다 많은 스레드를 생성, CPU를 최대한 사용할 수 있는 숫자까지 스레드 생성
- CPU를 많이 사용하지 않으므로 성능 테스트를 통해 CPU를 최대한 활용하는 숫자까지 스레드 생성
- 단 너무 많은 스레드를 생성하면 컨텍스트 스위칭 비용도 함께 증가 - 적절한 성능 테스트 필요

****
# 스레드 생성과 실행
## 프로젝트 환경 구성
## 스레드 시작1
### 자바 메모리 구조
#### 메서드 영역(Method Area)
- 프로그램을 실행하는데 필요한 공통 데이터를 관리한다. 이 영역은 프로그램의 모든 영역에서 공유한다.
##### 클래스 정보
- 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드등 모든 실행 코드가 존재한다.
##### static 영역
- `static` 변수들을 보관한다.
##### 런타임 상수 풀
- 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관한다.
#### 스택 영역(Stack Area)
- 잡 실행 시, 하나의 실행 스택이 생성된다. 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보등을 포함한다.
##### 스택 프레임
- 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임이다. 메서드를 호출할 때 마다 한의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거된다.
#### 힙 영역(Heap Area)
- 객체(인스턴스)와 배열이 생성되는 영역이다. 가비지 컬렉션(GC)이 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.
## 스레드 시작2
## 데몬 스레드
### 사용자 스레드(non-daemon 스레드)
- 프로그램의 주요 작업을 수행한다.
- 작업이 완료될 때까지 실행된다.
- 모든 user 스레드가 종료되면 JVM도 종료된다.
### 데몬 스레드
- 백그라운에서 보조적인 작업을 수행한다.
- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.
## 스레드 생성 - Runnable
### Thread 상속 vs Runnable 구현
- 스레드 사용할 때는 `Thread`를 상속 받는 방법보다 `Runnable` 인터페이스를 구현하는 방식을 사용하자
#### Thread 클래스 상속 방식
##### 장점
- 간단한 구현
	- `Thread` 클래스를 상속받아 `run()` 메서드만 재정의하면 된다.
##### 단점
- 상속의 제한
	- 자바는 단일 상속만을 허용하므로 이미 다른 클래스를 상속받고 있는 경우 `Thread` 클래스를 상속받을 수 없다.
- 유연성 부족
	- 인터페이스를 사용하는 방법에 비해 유연성이 떨어진다.
#### Runnable 인터페이스를 구현 방식
##### 장점
- 상속의 자유로움
	- `Runnable` 인터페이스 방식은 다른 클래스를 상속받아도 문제없이 구현할 수 있다.
- 코드의 분리
	- 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
- 여러 스레드가 동일한 `Runnable` 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.
##### 단점
- 코드가 약간 복잡해질 수 있다. `Runnable` 객체를 생성하고 이를 `Thread`에 전달하는 과정이 추가된다.
## 로거 만들기
## 여러 스레드 만들기
## Runnable을 만드는 다양한 방법
## 문제와 풀이
## 정리

****
# 스레드 제어와 생명 주기1
## 스레드 기본 정보
### `log("myThread.getState() = " + myThread.getState());`
#### getState()
- 스레드의 현재 상태를 반환하는 메서드이다. 반환되는 값은 `Thread.State` 열거형에 정의된 상수 중 하나이다.
##### NEW
- 스레드가 아직 시작되지 않은 상태이다.
##### RUNNABLE
- 스레드가 실행 중이거나 실행될 준비가 된 상태이다.
##### BLOCKED
- 스레드가 동기화 락을 기다리는 상태이다.
##### WAITING
- 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태이다.
##### TIMED_WAITING
- 일정 시간 동안 기다리는 상태이다.
##### TERMINATED
- 스레드가 실행을 마친 상태이다.

****
# 스레드 제어와 생명 주기2

****
# 메모리 가시성

****
# 동기화 - synchronized

****
# 고급 동기화 - concurrent.Lock

****
# 생산자 소비자 문제1

****
# 생산자 소비자 문제2

****
# CAS - 동기화와 원자적 연산

****
# 동시성 컬렉션

****
# 스레드 풀과 Executor 프레임워크1

****
# 스레드 풀과 Executor 프레임워크2

****
# 다음으로

****