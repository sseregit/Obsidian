
## 멀티태스킹과 멀티프로세싱

### 멀티태스킹
하나의 컴퓨터 시스템이 동시에 여러 작업을 수행하는 능력

### 시분할
프로그램의 실행 시간을 분할해서 마치 동시에 실행되는 것 처럼 하는 기법

### 스케줄링
CPU에 어떤 프로그램이 얼마만큼 실행될지는 운영체제가 결정한다.

### 멀티프로세싱
둘 이상의 프로세서를 사용하여 여러 작업을 동시에 처리하는 기술

### 멀티태스킹 vs 멀티프로세싱
- 멀티프로세싱
	- 여러 CPU를 사용하여 동시에 여러 작업을 수행하는 것을 의미
	- 하드웨어 기반으로 성능을 향상시킨다.
- 멀티태스킹
	- 단일 CPU가 여러 작업을 동시에 수행하는 것 처럼 보이게 하는 것을 의미한다.
	- 소프트웨어 기반으로 CPU 시간을 분할하여 각 작업에 할당한다.

## 프로세스와 스레드

### 프로세스
운영체제 안에서 실행중인 프로그램

#### 프로세스의 메모리 구성
- 코드 섹션
	- 실행할 프로그램의 코드가 저장되는 부분
- 데이터 섹션
	- 전역 변수 및 정적 변수가 저장되는 부분
- 힙(Heap)
	- 동적으로 할당되는 메모리 영역
- 스택(Stack)
	- 메서드(함수)호출 시 생성되는 지역 변수와 반환 주소가 저장되는 영역(스레드에 포함)

### 스레드(Thread)
**프로세스는 하나 이상의 스레드를 반드시 포함한다.**

#### 스레드의 메모리 구성
- 공유 메모리
	- 같은 프로세스의 코드 섹션, 데이터 섹션, 힙(메모리)은 프로세스 안의 모든 스레드가 공유한다
- 개별 스택
	- 각 스레드는 자신의 스택을 갖고 있다.

#### 단일 스레드
한 프로세스 내에 하나의 스레드 존재
#### 멀티 스레드
한 프로세스 내에 여러 스레드가 존재

## 스레드와 스케줄링

### 멀티태스킹과 스케줄링
멀티태스킹이란 동시에 여러 작업을 수행하는 것을 말하고
이를 위해 운영체제는 스케줄링이라는 기법을 사용한다.
#### 스케줄링
CPU 시간을 여러 작업에 나누어 배분하는 방법이다.

### 프로세스와 스레드
#### 프로세스
실행 중인 프로그램의 인스턴스
- 역할
	- 실행 환경을 제공한다
	- 메모리 공간, 파일 핸들, 시스템 자원 등이 포함된다.
#### 스레드
프로세스 내에서 실행되는 작은 단위
여러 스레드는 하나의 프로세스 내에서 자원을 공유한다
CPU에 의해 실행되는 단위는 스레드이다.

## 컨텍스트 스위칭

### 컨텍스트 스위칭
컨텍스트는 현재 작업하는 문맥을 뜻하고 작업하는 문맥이 변하기 때문에 컨텍스트 스위칭이다.

**멀티스레드는 대부분 효율적이지만,** 컨텍스트 스위칭 과정이 필요하므로 항상 효율적인것은 아니다.
### CPU-바운드 작업(CPU-bound tasks)
- CPU의 연산 능력을 많이 요구하는 작업
- 계산, 데이터처리, 알고리즘 실행등 CPU의 처리 속도가 완료 시간을 결정하는 경우

### I/O-바운드 작업(I/O-bound tasks)
- 디스크, 네트워크, 파일 시스템 등과 같은 입출력 작업을 많이 요구하는 작업을 의미한다.
- I/O 작업이 완료될 때까지 대기 시간이 많이 발생하며, CPU는 상대적으로 유휴 상태에 있는 경우가 많다.
- 스레드가 CPU를 사용하지 않고, I/O 작업이 완료될 때 까지 대기한다.

### 웹 애플리케이션 서버
실무에서는 CPU-바운드 작업 <<<< I/O-바운드 작업이 많다
스레드가 CPU를 많이 사용하지 않는 I/O-바운드 작업이 많다는 뜻

#### CPU-바운드 작업이 많을 경우
- CPU 코어 수 + 1개
- CPU를 거의 100% 사용하는 작업
#### I/O-바운드 작업이 많을 경우
- CPU 코어 수 보다 많은 스레드를 생성, CPU를 최대한 사용할 수 있는 숫자까지 스레드 생성
- CPU를 많이 사용하지 않으므로 성능 테스트를 통해 CPU를 최대한 활용하는 숫자까지 스레드 생성
- 단 너무 많은 스레드를 생성하면 컨텍스트 스위칭 비용도 함께 증가 - 적절한 성능 테스트 필요

## 프로젝트 환경 구성

## 스레드 시작1

`Thread.run()`이 아닌 `start()`를 호출해야 스택 공간을 할당 받고 스레드가 작동한다

## 스레드 시작2

### start() vs run()
- run()
	- 실행중인 스레드에서 실행됨
- start()
	- 별도의 스레드에서 run()을 실행한다

## 데몬 스레드

### 스레드의 종류

#### 사용자 스레드(non-daemon 스레드)
- 프로그램의 주요 작업을 수행한다.
- 작업이 완료될 때까지 실행된다.
- 모든 user 스레드가 종료되면 JVM도 종료된다.

#### 데몬 스레드
- 백그라운드에서 보조적인 작업을 수행한다.
- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.

JVM은 모든 사용자 스레드가 종료되면 종료된다.
- 메인 메서드의 종료가 아니다.

**run() 메서드는 throws로 Exception을 던질 수 없다**

## 스레드 생성 - Runnable

### 스레드를 만드는 방법
- Thread 클래스 상속 받는 방법
- Runnable 인터페이스를 구현하는 방법
- 

Runnable 구현을 사용하는것이 더 나은 방법

#### Thread 클래스 상속
- 장점
	- 간단한 구현 상속받아 run()만 재정의하면된다.
- 단점
	- 상속의 제한
	- 유연성 부족

#### Runnable 인터페이스를 구현방식
- 장점
	- 상속에 자유롭다
	- 코드의 분리
		- 스레드와 실행할 작업의 분리
	- 여러 스레드가 Runnable 객체를 공유할 수 있어 자원 관리를 효율적
- 단점
	- 코드가 약간 복잡해질 수 있다.

## 로거 만들기

## 여러 스레드 만들기

## Runnable을 만드는 다양한 방법

## 스레드 기본 정보
- getState()
	- NEW
		- 스레드가 아직 시작되지 않은 상태
	- RUNNABLE
		- 스레드가 실행 중이거나 실행될 준비가 된 상태
		- BLOCKED
			- 스레드가 동기화 락을 기다리는 상태
		- WAITING
			- 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태이다
		- TIMED_WAITING
			- 일정 시간 동안 기다리는 상태이다.
	- TERMINATED
		- 스레드가 실행을 마친 상태이다.

## 스레드의 생명 주기 - 설명

### New
스레드가 생성되고 아직 시작되지 않은 상태

### Runnable
스레드가 실행될 준비가 된 상태이다. 스레드는 실제로 CPU에서 실행될 수 있는 상태
스케줄러의 실행 대기열에 있든, CPU에서 실제 실행되고 있든 모두 RUNNABLE 상태이고 자바는 이 둘을 구분해서 확인할 수 없다.

### Blocked
스레드가 다른 스레드에 의해 동기화 락을 얻기 위해 기다리는 상태

### Waiting
스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태

### Timed Waiting
스레드가 특정 시간 동안 다른 스레드의 작업이 완료되기를 기다리는 상태

### Terminated
스레드의 실행이 완료된 상태
스레드는 종료되면 다시 시작할 수 없다.

## 스레드의 생명 주기 - 코드

## 체크 예외 재정의

### 재정의 메서드가 지켜야할 예외와 관련된 규칙
- 체크 예외
	- 부모 메서드가 체크 예외를 던지지 않는 경우, 재정의된 자식 메서드도 체크 예외를 던질 수 없다.
	- 자식 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.
- 언체크(런타임) 예외
	- 예외 처리를 강제하지 않으므로 상관없이 던질 수 있다.

## Join - 시작

### Waiting
스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.

## Join - 필요한 상황

## Join - sleep 사용

## Join - join 사용