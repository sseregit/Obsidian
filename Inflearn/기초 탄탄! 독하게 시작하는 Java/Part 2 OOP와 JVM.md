# 시작에 앞서...
## 알고 있다고 가정하는 것과 학습목표
## C/C++ 개발자에게 드리는 말씀
### C/C++ 개발자에게 드리는 말씀
- Java는 void형 변수 선언은 불가하며 반환 형식으로만 사용
- null값은 참조형에만 적용 가능
	- int a = null (불가)
	- null은 값(인스턴스)가 없다는 의미
	- 클래스 형식을 반환하는 메서드는 null 반환 가능
- 연산자 함수 없음
- Java에서 클래스 형식은 모두 참조자이며 포인터라고 생각하는 것이 용이
### Pointer스러운 참조형
- 참조형에 대한 관계연산(`==, !=`)은 객체의 메모리 주소에 대한 비교(Pointer와 동일)
- 포인터처럼 참조자 값은 변경될 수 있음
	- C++처럼 선언과 동시에 초기화 하지 않아도 무방
- null 대입 가능하며 참조 대상이 없는 참조자를 이용해 멤버접근 연산을 수행하면 NullPointerException 에러 발생
****
# 클래스 - 첫 번째
## 객체, 클래스, 인스턴스
### 객체(Object)란 무엇인가?
- OOP환경에서 소프트웨어(소스코드)를 구성한느 단위요소
- 변수 및 그와 관련한 메서드(Method)가 모여서 이뤄진 하나의 집합체
	- **클래스는 반드시 존재 이유와 목적이 명확해야함**
- Java에서는 클래스(Class)로 객체를 기술
### 항, 식, 구문
- 여러 항이 모여 식을 이룸
- 식은 평가 대상(식을 평가하기 위해서는 계산(연산)을 해야함)
- 여러 식을 모아 하나의 구문을 이루며 고급어 기준 실행단위가 됨
- 연속되는 구문을 위에서 아래로 순차적 실행
### 클래스, 객체, 인스턴스
- 클래스는 변수와 같은 자료형으로 이해
	- 클래스(집합체)는 객체(단위)를 기술하는 문법
	- 클래스 형식에 대해 선언 할 수 있는 것은 참조(null 가능)
- 사전적 의미는 '예시' 혹은 '경우'
- 변수 대신 인스턴스라고 표현
	- int형식에 대한 인스턴스 a
- 다양하게 사용되는 용어
	- 프로세스 인스턴스
## 클래스 기본 문법과 두 가지 관점
### 클래스 기본 문법
	`class class-name {}`
- 관계에 관해 생각하지 않는다면 함수(메서드)를 구성요소로 포함하는 단순 집합체로 이해
- 구성요소(변수나 함수)를 멤버라 지칭
	- 변수는 필드(Field), 함수는 메서드(Method)
	- 변수는 메모리를 사용하는 보편적인 수단
- 선언과 정의가 공존하는 구조
- **객체 작성자와 사용자를 구분해 생각하는 능력 필수**
#### Convention
	`className.java`
- 클래스 이름은 영문으로 작성하되 첫 글자는 대문자로 표기하는 것이 보편적 규칙
- 클래스 이름과 저장되는 .java 파일명이 같아야 함
	- 대소문자 구분
	- public 선언 시 필수
	- 단, 특정 .java 파일에 여러 클래스를 함께 정의할 경우 별도 파일로 저장하지 않음
## 생성자와 필드 초기화
### 멤버 선언 및 초기화
- 필드 선언 시 초깃값 정의 가능
	- 초깃값을 기술하지 않을 경우 기본 값은 0
- 생성자를 통해 초기화 가능
	- 필드 선언 시 기술한 초깃값과 생성자에서 정의하는 값이 서로 다를 경우 생성자에 기술한 코드가 우선
- `동적 == Dynamic == Runtime`
### 생성자
- 생성자는 객체가 생성되는 시점에 자동으로 호출 되는 메서드
	- 이름이 클래스 이름과 동일
	- 생략 시 컴파일러가 빈 생성자를 자동으로 추가
	- 반환자료와 호출자가 없다는 점에 유의
- 객체의 생성은 new 연산에 따른 동적 생성
- 다중 정의 가능
- **클래스 자체와 관련된 코드만 기술할 것**
### 인스턴스 동적 생성
- new 연산자를 이용해 인스턴스 동적 생성
- 클래스 형식에 대한 변수 선언은 모두 참조
	- 인스턴스가 존재하지 않는 경우는 null
- 한 인스턴스에 대해 여러 참조자가 존재할 수 있음
	- 사이드 이펙트 문제 고려
## 클래스 멤버에 대한 접근 제어
### 접근 제어 지시자
#### public
- 외부접근 허용
#### protected
- 외부접근 차단
- 같은 패키지 및 파생 클래스의 접근은 허용
#### default
- 같은 패키지 소속 클래스만 접근 허용
#### private
- 외부접근 차단
### getter()와 setter()
- 감춰진 필드에 대해 외부에서 접근 할 수 있도록 허용된 메서드
- 필드에 대한 읽기, 쓰기 접근을 분리해 통제 가능
- 도구에서 자동 생성 지원
- 객체지향 프로그래밍에서는 객체를 제작하는 관점과 생성하고 사용하는 관점 두 가지를 분리해 생각해야 함
## this
### this
- 클래스로 구현한 객체 자신의 인스턴스에 대한 참조자
- 클래스(현재 코드)에 대한 인스턴스(미래, 외부) 선언 시 값이 결정될 수 있음 (주소)
- 같은 클래스에 대한 인스턴스라 하더라도 this 값은 각자 다른값이 됨
- 메서드 호출 시 스택(0번 슬롯)에 값이 저장
- 정적 메서드에서는 사용 할 수 없음
## [실습] 문자열 처리를 위한 MyString 클래스 개발
## MyString 클래스 작성 실습 해설
****
# 클래스 - 두 번째
## 생성자 다중 정의
### 생성자 다중 정의
- 일반 메서드처럼 생성자도 매개변수 구성이 다른 생성자를 여럿 정의할 수 있음
	- 여러 개가 다중 정의되어 있다하더라도 new 연산 시 호출되는 생성자는 1개
- 생성자에서 다른 생성자 호출 가능
## [실습] MyString 클래스 생성자 다중 정의
## 깊은 복사와 얕은 복사 (※매우 중요)
### Shallow copy
- 참조의 대상은 복사해서 늘리지 않고 참조자만 늘리는 형태
	- 사이드 이펙트 발생의 원인
- 대상 인스턴스는 그대로 두고 참조만 늘어나는 경우
### Deep copy
- 원본 자체도 새로 할당하고 복사하는 방식
- Shallow copy와 달리 두 개의 원본 두 개의 참조가 각각 별도로 존재
- 사이드 이펙트 오류 가능성이 없음
- 참조를 멤버로 가지며 인스턴스를 동적 할당하는 경우 복사 생성자 구현
	- clone()
****
# 상속과 관계

****
# 다형성

****
# JVM(Java Virtual Machine) 기본 이론

****
# JVM과 GC 그리고 객체

****
# 불변 객체와 String 클래스

****
# 내부 클래스, 익명 객체, 패키지

****
# 연결 리스트 기반 주소록과 OOP 실습

****
# 예외 처리

****