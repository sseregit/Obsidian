# 시작에 앞서...
## 알고 있다고 가정하는 것과 학습목표
## C/C++ 개발자에게 드리는 말씀
### C/C++ 개발자에게 드리는 말씀
- Java는 void형 변수 선언은 불가하며 반환 형식으로만 사용
- null값은 참조형에만 적용 가능
	- int a = null (불가)
	- null은 값(인스턴스)가 없다는 의미
	- 클래스 형식을 반환하는 메서드는 null 반환 가능
- 연산자 함수 없음
- Java에서 클래스 형식은 모두 참조자이며 포인터라고 생각하는 것이 용이
### Pointer스러운 참조형
- 참조형에 대한 관계연산(`==, !=`)은 객체의 메모리 주소에 대한 비교(Pointer와 동일)
- 포인터처럼 참조자 값은 변경될 수 있음
	- C++처럼 선언과 동시에 초기화 하지 않아도 무방
- null 대입 가능하며 참조 대상이 없는 참조자를 이용해 멤버접근 연산을 수행하면 NullPointerException 에러 발생
****
# 클래스 - 첫 번째
## 객체, 클래스, 인스턴스
### 객체(Object)란 무엇인가?
- OOP환경에서 소프트웨어(소스코드)를 구성한느 단위요소
- 변수 및 그와 관련한 메서드(Method)가 모여서 이뤄진 하나의 집합체
	- **클래스는 반드시 존재 이유와 목적이 명확해야함**
- Java에서는 클래스(Class)로 객체를 기술
### 항, 식, 구문
- 여러 항이 모여 식을 이룸
- 식은 평가 대상(식을 평가하기 위해서는 계산(연산)을 해야함)
- 여러 식을 모아 하나의 구문을 이루며 고급어 기준 실행단위가 됨
- 연속되는 구문을 위에서 아래로 순차적 실행
### 클래스, 객체, 인스턴스
- 클래스는 변수와 같은 자료형으로 이해
	- 클래스(집합체)는 객체(단위)를 기술하는 문법
	- 클래스 형식에 대해 선언 할 수 있는 것은 참조(null 가능)
- 사전적 의미는 '예시' 혹은 '경우'
- 변수 대신 인스턴스라고 표현
	- int형식에 대한 인스턴스 a
- 다양하게 사용되는 용어
	- 프로세스 인스턴스
## 클래스 기본 문법과 두 가지 관점
### 클래스 기본 문법
	`class class-name {}`
- 관계에 관해 생각하지 않는다면 함수(메서드)를 구성요소로 포함하는 단순 집합체로 이해
- 구성요소(변수나 함수)를 멤버라 지칭
	- 변수는 필드(Field), 함수는 메서드(Method)
	- 변수는 메모리를 사용하는 보편적인 수단
- 선언과 정의가 공존하는 구조
- **객체 작성자와 사용자를 구분해 생각하는 능력 필수**
#### Convention
	`className.java`
- 클래스 이름은 영문으로 작성하되 첫 글자는 대문자로 표기하는 것이 보편적 규칙
- 클래스 이름과 저장되는 .java 파일명이 같아야 함
	- 대소문자 구분
	- public 선언 시 필수
	- 단, 특정 .java 파일에 여러 클래스를 함께 정의할 경우 별도 파일로 저장하지 않음
## 생성자와 필드 초기화
### 멤버 선언 및 초기화
- 필드 선언 시 초깃값 정의 가능
	- 초깃값을 기술하지 않을 경우 기본 값은 0
- 생성자를 통해 초기화 가능
	- 필드 선언 시 기술한 초깃값과 생성자에서 정의하는 값이 서로 다를 경우 생성자에 기술한 코드가 우선
- `동적 == Dynamic == Runtime`
### 생성자
- 생성자는 객체가 생성되는 시점에 자동으로 호출 되는 메서드
	- 이름이 클래스 이름과 동일
	- 생략 시 컴파일러가 빈 생성자를 자동으로 추가
	- 반환자료와 호출자가 없다는 점에 유의
- 객체의 생성은 new 연산에 따른 동적 생성
- 다중 정의 가능
- **클래스 자체와 관련된 코드만 기술할 것**
### 인스턴스 동적 생성
- new 연산자를 이용해 인스턴스 동적 생성
- 클래스 형식에 대한 변수 선언은 모두 참조
	- 인스턴스가 존재하지 않는 경우는 null
- 한 인스턴스에 대해 여러 참조자가 존재할 수 있음
	- 사이드 이펙트 문제 고려
## 클래스 멤버에 대한 접근 제어
### 접근 제어 지시자
#### public
- 외부접근 허용
#### protected
- 외부접근 차단
- 같은 패키지 및 파생 클래스의 접근은 허용
#### default
- 같은 패키지 소속 클래스만 접근 허용
#### private
- 외부접근 차단
### getter()와 setter()
- 감춰진 필드에 대해 외부에서 접근 할 수 있도록 허용된 메서드
- 필드에 대한 읽기, 쓰기 접근을 분리해 통제 가능
- 도구에서 자동 생성 지원
- 객체지향 프로그래밍에서는 객체를 제작하는 관점과 생성하고 사용하는 관점 두 가지를 분리해 생각해야 함
## this
### this
- 클래스로 구현한 객체 자신의 인스턴스에 대한 참조자
- 클래스(현재 코드)에 대한 인스턴스(미래, 외부) 선언 시 값이 결정될 수 있음 (주소)
- 같은 클래스에 대한 인스턴스라 하더라도 this 값은 각자 다른값이 됨
- 메서드 호출 시 스택(0번 슬롯)에 값이 저장
- 정적 메서드에서는 사용 할 수 없음
## [실습] 문자열 처리를 위한 MyString 클래스 개발
## MyString 클래스 작성 실습 해설
****
# 클래스 - 두 번째
## 생성자 다중 정의
### 생성자 다중 정의
- 일반 메서드처럼 생성자도 매개변수 구성이 다른 생성자를 여럿 정의할 수 있음
	- 여러 개가 다중 정의되어 있다하더라도 new 연산 시 호출되는 생성자는 1개
- 생성자에서 다른 생성자 호출 가능
## [실습] MyString 클래스 생성자 다중 정의
## 깊은 복사와 얕은 복사 (※매우 중요)
### Shallow copy
- 참조의 대상은 복사해서 늘리지 않고 참조자만 늘리는 형태
	- 사이드 이펙트 발생의 원인
- 대상 인스턴스는 그대로 두고 참조만 늘어나는 경우
### Deep copy
- 원본 자체도 새로 할당하고 복사하는 방식
- Shallow copy와 달리 두 개의 원본 두 개의 참조가 각각 별도로 존재
- 사이드 이펙트 오류 가능성이 없음
- 참조를 멤버로 가지며 인스턴스를 동적 할당하는 경우 복사 생성자 구현
	- clone()
## 복사 생성자 (※매우 중요)
### 복사 생성자
	`class-name(class-name rhs)`
- 객체의 사본을 생성할 때 사용하기 적절한 생성자 함수
	- C++ 스타일 문법
- rhs는 Right Hand Side의 약어이며 복사의 원본 인스턴스에 대한 참조
- clone() 메서드를 만드는 방법이 있으나 규약에 모호한 부분이 있고 예외처리가 복잡한 단점이 있음
## [실습] MyString에 복사 생성자 추가
## 보이지 않는 임시 객체
### 보이지 않는 임시 객체
- 클래스가 함수의 반환 자료형이 될 경우 (이름이 없는) 임시 객체를 생성
- String 클래스는 덧셈 연산 시 임시 객체 생성
	- 비효율의 직접적 원인이 될 수 있음
## 정적 멤버와 특이한 코드
### 정적 멤버
- 클래스 인스턴스가 없어도 **독립적으로 존재**가능
	- 필드(**모든 인스턴스에서 공유**), 메서드
- 일반 메서드와 달리 인스턴스 선언 없이 호출 가능
- 메서드에서 this를 사용할 수 없음
- 정적 필드는 final 선언 함으로써 심볼릭 상수로 활용하는 경우가 많음
### 정적 필드와 인스턴스 메모리 차이
- 정적 필드는 인스턴스 메모리와 독립적이며 메소드 코드는 인스턴스 마다 다르지 않고 하나만 존재
## [실습] 정적 메서드로 MyString 클래스 객체 생성하기
****
# 상속과 관계
## 상속에 대한 기본 이론
### 상속에 대한 기본 이론
	`class child extends parent`
- 객체단위 코드를 재사용(확장)하는 문법
- is-a, has-a 관계로 설명 가능
- 부모/자식 클래스, 기본/파생 클래스로 구분 할 수 있음
- C++과 달리 다중 상속은 허용하지 않음
- Java에서 모든 클래스는 Object의 파생형식
- **파생 클래스 생성 시 기본 클래스도 함께 생성**(생성자 호출)
- 파생 클래스는 기본 클래스 멤버에 접근 가능
	- 접근제어 지시자에 따라 제어
- 파생 클래스에서 **기본 클래스 메서드 재정의(Override) 가능**(다중 정의와 다름에 주의)
- 추상 자료형 개념 적용 가능
- 상속 관계가 적용될 경우 코드의 흐름이 2차원적 구조를 갖게 되어 감춰지는 경향이 있음
## 상속과 생성자 (신박한 바보짓)
### 상속과 생성자 호출스택
- **파생 클래스 생성자는 가장 먼저 호출되지만 가장 나중에 실행된다.**
- 재귀호출과 비슷하게 생성자 함수에 대한 호출 스택이 쌓여 올라가는 것이 특징
- 파생 클래스에서 기본 클래스 필드를 정의하는 것은 적절하지 않은 경우가 대부분
### 상속관계에서 인스턴스 메모리 구조
- 파생 클래스 인스턴스는 부모 클래스(들) 인스턴스를 내부에 포함하고 있는 구조
- 파생 클래스는 부모 클래스의 멤버를 가진것
	- private이면 파생 클래스 접근도 차단
	- protected면 파생 클래스 접근 허용
### 상속을 배우는 순간부터 알아야 할 시간차
- 부모 클래스와 파생 클래스가 정의되는 시점
	- 부모 클래스 기준 '현재'는 파생 클래스가 '미래'에 정의되는 것임을 확정
	- 6개월 후 미래의 당신은 오늘 이 클래스에 대해 얼마나 기억할 수 있을 것인지 고려
- 이해도 부족에 따른 문제
	- 증조 할아버지에 대해 얼마나 알고 있는가?
	- 상속에 상속이 이어지는 것은 결코 바람직하지 않음
- 미래의 파생 클래스를 고려해 현재 클래스 코드 작성
## 부모 클래스 생성자 선택
### 부모 클래스 생성자 선택
- 파생 클래스 생성자에서 부모 클래스의 (다중정의 된) 여러 생성자 중 원하는 것이 호출되도록 강제화
- `super();`
## 메서드 재정의(Overriding, ※매우 중요)
### 메서드 재정의(Overriding)
- 파생 클래스에서 기본 클래스 메서드 재정의(Override) 가능 (다중 정의와 다름에 주의)
	- @Override 어노테이션
- 기본 클래스 메서드를 재정의 하는 것은 기존 메서드를 대체하거나 코드를 추가할 목적으로 볼 수 있음
- 메서드 재정의 시 실제 인스턴스 형식이 우선
- final 선언으로 파생 클래스에서 메서드가 재정의되지 못하도록 차단할 수 있음
### 어노테이션(Annotaion) 소개
- 코드에 추가 할 수 있는 메타 데이터로 단순히 주석처럼 쓰이거나 코드를 간소화 할 수 있는 도구로 사용
- 대표적 표준 어노테이션
	- @Override (재정의)
	- @SuppressWarning (컴파일러 경고 메시지 무시)
	- 메타 어노테이션 (어노테이션에 대한 어노테이션)
	- 사용자 정의 어노테이션
## 불필요한 호출로 미래와 대화하기 (※매우 중요)
### 불필요한 호출로 미래와 대화하기
- 부모 클래스에서 정한 함수 호출 관계로 파생 클래스에서 재정의된 메서드가 호출 될 수 있음
- 구조가 정한 흐름을 확장해 (그 구조에) 내 코드를 추가하는 방식으로 올라 탈 수 있음
	- Called by framework
	- onXxx() 메서드
## [실습] 상속과 문자열 필터 구현
## 객체간 관계와 UML
## Java와 C++ 메모리 관리 차이
### UML(Unified Modeling Language)
- 모델링 언어 표준으로 클래스 및 연관 관계를 시작화 할 수 있는 방법론
- **Class, Sequence diagram**등에 대해서는 반드시 알아야함
#### Class diagram
- `public : +`로 표현
	- `+ getName: String`
- `private : -`로 표현
	- `- name: String`
### 클래스 관계

| 일반화 (상속)         | ㅡ▶️         |
| ---------------- | ----------- |
| 실체화 (상속)         | - - ▶️      |
| 의존               | - - >       |
| 연관               | ㅡ           |
| 직접연관             | ㅡ>          |
| 집합 (Aggregation) | 🔹(empty)ㅡ> |
| 합성 (Composite)   | 🔹ㅡ>        |
## 알아 두면 좋을 동적 바인딩
### 알아 두면 좋을 동적 바인딩
- 함수와 함수가 서로 호출 피호출 관계가 되는 것이 **바인딩**
- 바인딩 시점이 Compile-time이면 Static binding
- 바인딩 시점이 Run-time이면 Dynamic binding(Lately binding)
### C++ 가상 함수 테이블 (vtable)
- vtable은 클래스 멤버 함수 중 가상화 된 함수들에 대한 포인터의 배열
- 가상 함수는 함수 포인트 배열을 참조해 호출할 함수를 결정(Dynamic binding)
- 상속관계일 때 vtable의 값은 파생 클래스 생성자가 호출되는 시점에 업데이트 되는 것이 특징
****
# 다형성
## 다형성과 형변환 그리고 추상성
### 다형성(Polymorphism)
- 사전적 정의는 같은 종의 생물이면서도 어떤 형태나 형질이 다양하게 나타나는 현상
- 객체지향 프로그래밍의 중요한 특징
	- 추상화(혹은 일반화), 구체화
	- 추상성이 높은 수준에서 구조를 단순화 할 수 있음
	- Framework가 구현될 수 있는 원리
### 부모 자식 클래스간 형식 변환
- 클래스 A의 모든 파생형식은 A로 캐스팅 가능(업 캐스팅)
- 클래스 A 참조하는 대상 인스턴스는 A 혹은 A의 파생형식
## [실습] Shape 클래스
## 다운 캐스팅과 instanceof 연산자
### 다운 캐스팅
- 부모 클래스 형식 참조자가 가리키는 대상 인스턴스를 특정 파생형식으로 캐스팅하는 것
- 적절치 못한 캐스팅 시 오류 발생
- 모든 파생클래스는 부모 클래스에 대해 존립 의존적이지만 부모 클래스에서 다운 캐스팅하는 코드가 존재할 경우 **의존성이 역전되는 좋지 못한 코드가 될 수 있음**
### instanceof 연산자 활용
	`boolean result = obj instanceof instance`;
- 다운 캐스팅이 적절한 것인지 확인할 수 있는 연산자
- RTTI(Run Time Type Information)
## 추상 클래스
### 추상 클래스
	`public abstract class class-name`
- **new 연산으로 인스턴스 생성 불가**
	- C++의 순수 가상 클래스 개념
- 오직 파생 클래스를 위해 존재하는 클래스
- 설계적인 관점에서 존재
- 추상 메서드를 가지는 것이 일반적
	- `abstarct void getA();`
	- 파생형식에서 반드시 재정의 해야 함
## 인터페이스 (클래스)
### 인터페이스 만들기
	`[public] interface iface-name`
- 필드를 가지지 않는 추상 클래스를 선언하는 것으로 이해할 수 있음 (단, 상수 필드는 가질 수 있음)
- 인터페이스 파생은 `extends` 대신 `implements`
- 인터페이스는 메소드 원형을 기술하기 위한 것으로 구체적 정의가 없는 순수한 '선언'에 해당
	- 각종 심볼릭 상수 정의
	- C언어의 헤더 파일과 유사한 의미를 가짐
	- 다중상속 가능
## 열거형
### 열거형
	`public enum enum-name{value#0, value#n...}`
- 심볼릭 상수를 정의할 수 있는 문법으로 형안전성을 제공하고 가독성이 좋은 코드를 만들 수 있음
- `java.lang.Enum`의 파생 클래스
- 주요 멤버
	- `values(), valueOf(String name)`
	- `name()`
	- `ordinal()`
	- `toString()`
## 생각해볼 문제 (어쩌면 농담)
### 생각해볼 문제
#### OOP에 관한 논쟁은 늘 어디서든 있는 편
- 잔소리는 충고의 파생형식인가?
- 잔소리, 충고 모두 조언의 파생형식인가?
- 잔소리, 충고, 조언 모두 말하기의 파생형식인가?
****
# JVM(Java Virtual Machine) 기본 이론
## Java와 C++ 메모리 관리 차이
## JVM 구성요소 정리
## .class 파일과 바이트 코드 소개
## 클래스 로더 및 로딩 과정
### 클래스 로더
- 이름을 알고 있는 특정 클래스에 대한 정의(Byte stream)를 가져오는 역할을 수행
#### 부트스트랩 클래스 로더
- JVM에서 라이브러리로 취급(rt.jar, tools.jar)되는 것들을 로드 (핫스팟에서는 C++로 구현)
#### 플랫폼 클래스 로더 (기존 확장 클래스 로더)
- 클래스 라이브러리 로드
- 개념상 하드웨어와 애플리케이션 중간의 역할을 해줄 그런 코드들이 로드 된다 생각하면 된다.
#### 애플리케이션 클래스 로더
- `sun.misc.Launcher$AppClassLoader`를 의미
### Java 클래스 로딩
- 클래스 로딩 및 링킹 과정이 모두 런타임에 이루어짐
- 실행 성능이 일부 저하될 수 있으나 높은 확장성과 유연성을 제공하는 근간
	- 인터페이스만 맞으면 Runtime에 구현 클래스를 결정하지 않을 수 있음
	- 클래스 로더는 실행할 프로그램 코드를 네트워크로 수신하는 것도 가능
- 해석(Resolution) 단계는 동적 바인딩(혹은 늦은 바인딩)을 지원할 목적으로 초기화 후로 지연될 수 있음
#### 클래스 검증
- JVM 명세가 정하는 규칙과 제약을 만족하는지 확인
	- 파일 형식(.class)
	- 메타데이터
	- 바이트코드
	- 심벌 참조
- 보안위협에 대한 검증 포함
	- 바이트코드 검증 시 함께 확인
#### 준비 및 해석
- `java.lang.Class`인스턴스(메타 데이터)가 힙 영역에 생성되고 클래스 변수(정적 멤버) 메모리를 0으로 초기화
	- 로드되고 클래스의 인스턴스는 Using 단계에서 힙 사용
	- final 선언된 변수는 코드에서 정의한 초깃값으로 정의(0이 아닐 수 있음)
- 생성자 호출전 상태 (new 연산전)
	- 필드(인스턴스 변수) 초깃값은 생성자 호출 시 정의
	- 정적 필드에 초깃값 할당
- 해석은 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정
#### Heap 영역에 객체 생성
- JVM은 객체 저장을 위한 메모리 공간을 확보 후 0으로 초기화 (단, 객체 헤더 제외)
- 객체 초기화를 위한 구성설정 실시
	- 클래스 이름 및 메타 정보 확인 방법
	- 객체에 대한 해시코드
	- GC 세대 나이
- 생성자 호출
## 런타임 데이터 영역
### JVM runtime data area
****
# JVM과 GC 그리고 객체

****
# 불변 객체와 String 클래스

****
# 내부 클래스, 익명 객체, 패키지

****
# 연결 리스트 기반 주소록과 OOP 실습

****
# 예외 처리

****